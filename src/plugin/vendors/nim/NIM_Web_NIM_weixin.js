module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/entry/nim.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./external/socketio/socket.io.js":
/*!****************************************!*\
  !*** ./external/socketio/socket.io.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Socket.IO.js build:0.9.11, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */

function getGlobal () {
  if (typeof window !== 'undefined') {
    return window
  }
  if (typeof self !== 'undefined') {
    return self
  }
  if (typeof global !== 'undefined') {
    return global
  }
  return {}
}

var root = getGlobal()
// root.location = root.location || {}

var io =  false ? undefined : module.exports
if (typeof root.location === 'undefined') {
  root.location = null
}

// 将 io 挂在 root 上, 低版本 IE 要用到
if (!root.io) {
  root.io = io
} else {
  if (module) {
    module.exports = io = root.io
  }
}

(function () {
  /**
   * socket.io io
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, global) {
    /**
     * IO namespace.
     *
     * @namespace
     */

    var io = exports

    /**
     * Socket.IO version
     *
     * @api public
     */

    io.version = '0.9.11'

    /**
     * Protocol implemented.
     *
     * @api public
     */

    io.protocol = 1

    /**
     * Available transports, these will be populated with the available transports
     *
     * @api public
     */

    io.transports = []

    /**
     * Keep track of jsonp callbacks.
     *
     * @api private
     */

    io.j = []

    /**
     * Keep track of our io.Sockets
     *
     * @api private
     */
    io.sockets = {}

    /**
     * Manages connections to hosts.
     *
     * @param {String} uri
     * @Param {Boolean} force creation of new socket (defaults to false)
     * @api public
     */

    io.connect = function (host, details) {
      var uri = io.util.parseUri(host)
      var uuri
      var socket

      if (global && global.location) {
        uri.protocol = uri.protocol || global.location.protocol.slice(0, -1)
        uri.host =
          uri.host ||
          (global.document ? global.document.domain : global.location.hostname)
        uri.port = uri.port || global.location.port
      }

      uuri = io.util.uniqueUri(uri)

      var options = {
        host: uri.host,
        secure: uri.protocol === 'https',
        port: uri.port || (uri.protocol === 'https' ? 443 : 80),
        query: uri.query || ''
      }

      io.util.merge(options, details)

      if (options['force new connection'] || !io.sockets[uuri]) {
        socket = new io.Socket(options)
      }

      if (!options['force new connection'] && socket) {
        io.sockets[uuri] = socket
      }

      socket = socket || io.sockets[uuri]

      // if path is different from '' or /
      return socket.of(uri.path.length > 1 ? uri.path : '')
    }
  })( true ? module.exports : undefined, root);
  /**
   * socket.io util
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, global) {
    /**
     * Utilities namespace.
     *
     * @namespace
     */

    var util = (exports.util = {})

    /**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api public
     */

    var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/

    var parts = [
      'source',
      'protocol',
      'authority',
      'userInfo',
      'user',
      'password',
      'host',
      'port',
      'relative',
      'path',
      'directory',
      'file',
      'query',
      'anchor'
    ]

    util.parseUri = function (str) {
      var m = re.exec(str || ''),
        uri = {},
        i = 14

      while (i--) {
        uri[parts[i]] = m[i] || ''
      }

      return uri
    }

    /**
     * Produces a unique url that identifies a Socket.IO connection.
     *
     * @param {Object} uri
     * @api public
     */

    util.uniqueUri = function (uri) {
      var protocol = uri.protocol,
        host = uri.host,
        port = uri.port

      if ('document' in global && global.document) {
        host = host || document.domain
        port =
          port ||
          (protocol == 'https' && document.location.protocol !== 'https:'
            ? 443
            : document.location.port)
      } else {
        host = host || 'localhost'

        if (!port && protocol == 'https') {
          port = 443
        }
      }

      return (protocol || 'http') + '://' + host + ':' + (port || 80)
    }

    /**
     * Mergest 2 query strings in to once unique query string
     *
     * @param {String} base
     * @param {String} addition
     * @api public
     */

    util.query = function (base, addition) {
      var query = util.chunkQuery(base || ''),
        components = []

      util.merge(query, util.chunkQuery(addition || ''))
      for (var part in query) {
        if (query.hasOwnProperty(part)) {
          components.push(part + '=' + query[part])
        }
      }

      return components.length ? '?' + components.join('&') : ''
    }

    /**
     * Transforms a querystring in to an object
     *
     * @param {String} qs
     * @api public
     */

    util.chunkQuery = function (qs) {
      var query = {},
        params = qs.split('&'),
        i = 0,
        l = params.length,
        kv

      for (; i < l; ++i) {
        kv = params[i].split('=')
        if (kv[0]) {
          query[kv[0]] = kv[1]
        }
      }

      return query
    }

    /**
     * Executes the given function when the page is loaded.
     *
     *     io.util.load(function () { console.log('page loaded'); });
     *
     * @param {Function} fn
     * @api public
     */

    var pageLoaded = false

    util.load = function (fn) {
      if (
        (typeof document !== 'undefined' && document && document.readyState === 'complete') ||
        pageLoaded
      ) {
        return fn()
      }

      util.on(global, 'load', fn, false)
    }

    /**
     * Adds an event.
     *
     * @api private
     */

    util.on = function (element, event, fn, capture) {
      if (element.attachEvent) {
        element.attachEvent('on' + event, fn)
      } else if (element.addEventListener) {
        element.addEventListener(event, fn, capture)
      }
    }

    /**
     * Generates the correct `XMLHttpRequest` for regular and cross domain requests.
     *
     * @param {Boolean} [xdomain] Create a request that can be used cross domain.
     * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
     * @api private
     */

    util.request = function (xdomain) {
      if (xdomain && (typeof XDomainRequest !== 'undefined') && !util.ua.hasCORS) {
        return new XDomainRequest()
      }

      if (
        (typeof XMLHttpRequest !== 'undefined') &&
        (!xdomain || util.ua.hasCORS)
      ) {
        return new XMLHttpRequest()
      }

      if (!xdomain) {
        try {
          return new root[(['Active'].concat('Object').join('X'))](
            'Microsoft.XMLHTTP'
          )
        } catch (e) { }
      }

      return null
    }

    /**
     * XHR based transport constructor.
     *
     * @constructor
     * @api public
     */

    /**
     * Change the internal pageLoaded value.
     */

    if (typeof root !== 'undefined') {
      util.load(function () {
        pageLoaded = true
      })
    }

    /**
     * Defers a function to ensure a spinner is not displayed by the browser
     *
     * @param {Function} fn
     * @api public
     */

    util.defer = function (fn) {
      if (!util.ua.webkit || typeof importScripts !== 'undefined') {
        return fn()
      }

      util.load(function () {
        setTimeout(fn, 100)
      })
    }

    /**
     * Merges two objects.
     *
     * @api public
     */

    util.merge = function merge (target, additional, deep, lastseen) {
      var seen = lastseen || []
      var depth = typeof deep === 'undefined' ? 2 : deep
      var prop

      for (prop in additional) {
        if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
          if (typeof target[prop] !== 'object' || !depth) {
            target[prop] = additional[prop]
            seen.push(additional[prop])
          } else {
            util.merge(target[prop], additional[prop], depth - 1, seen)
          }
        }
      }

      return target
    }

    /**
     * Merges prototypes from objects
     *
     * @api public
     */

    util.mixin = function (ctor, ctor2) {
      util.merge(ctor.prototype, ctor2.prototype)
    }

    /**
     * Shortcut for prototypical and static inheritance.
     *
     * @api private
     */

    util.inherit = function (ctor, ctor2) {
      function f () { }
      f.prototype = ctor2.prototype
      ctor.prototype = new f()
    }

    /**
     * Checks if the given object is an Array.
     *
     *     io.util.isArray([]); // true
     *     io.util.isArray({}); // false
     *
     * @param Object obj
     * @api public
     */

    util.isArray =
      Array.isArray ||
      function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]'
      }

    /**
     * Intersects values of two arrays into a third
     *
     * @api public
     */

    util.intersect = function (arr, arr2) {
      var ret = [],
        longest = arr.length > arr2.length ? arr : arr2,
        shortest = arr.length > arr2.length ? arr2 : arr

      for (var i = 0, l = shortest.length; i < l; i++) {
        if (~util.indexOf(longest, shortest[i])) ret.push(shortest[i])
      }

      return ret
    }

    /**
     * Array indexOf compatibility.
     *
     * @see bit.ly/a5Dxa2
     * @api public
     */

    util.indexOf = function (arr, o, i) {
      for (
        var j = arr.length, i = i < 0 ? (i + j < 0 ? 0 : i + j) : i || 0;
        i < j && arr[i] !== o;
        i++
      ) { }

      return j <= i ? -1 : i
    }

    /**
     * Converts enumerables to array.
     *
     * @api public
     */

    util.toArray = function (enu) {
      var arr = []

      for (var i = 0, l = enu.length; i < l; i++) arr.push(enu[i])

      return arr
    }

    /**
     * UA / engines detection namespace.
     *
     * @namespace
     */

    util.ua = {}

    /**
     * Whether the UA supports CORS for XHR.
     *
     * @api public
     */

    util.ua.hasCORS =
      typeof XMLHttpRequest !== 'undefined' &&
      (function () {
        try {
          var a = new XMLHttpRequest()
        } catch (e) {
          return false
        }

        return a.withCredentials != undefined
      })()

    /**
     * Detect webkit.
     *
     * @api public
     */

    util.ua.webkit =
      typeof navigator !== 'undefined' && /webkit/i.test(navigator.userAgent)

    /**
     * Detect iPad/iPhone/iPod.
     *
     * @api public
     */

    util.ua.iDevice =
      typeof navigator !== 'undefined' &&
      /iPad|iPhone|iPod/i.test(navigator.userAgent)
  })(typeof io !== 'undefined' ? io : module.exports, root);
  /**
   * socket.io EventEmitter
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io) {
    /**
     * Expose constructor.
     */

    exports.EventEmitter = EventEmitter

    /**
     * Event emitter constructor.
     *
     * @api public.
     */

    function EventEmitter () { }

    /**
     * Adds a listener
     *
     * @api public
     */

    EventEmitter.prototype.on = function (name, fn) {
      if (!this.$events) {
        this.$events = {}
      }

      if (!this.$events[name]) {
        this.$events[name] = fn
      } else if (io.util.isArray(this.$events[name])) {
        this.$events[name].push(fn)
      } else {
        this.$events[name] = [this.$events[name], fn]
      }

      return this
    }

    EventEmitter.prototype.addListener = EventEmitter.prototype.on

    /**
     * Adds a volatile listener.
     *
     * @api public
     */

    EventEmitter.prototype.once = function (name, fn) {
      var self = this

      function on () {
        self.removeListener(name, on)
        fn.apply(this, arguments)
      }

      on.listener = fn
      this.on(name, on)

      return this
    }

    /**
     * Removes a listener.
     *
     * @api public
     */

    EventEmitter.prototype.removeListener = function (name, fn) {
      if (this.$events && this.$events[name]) {
        var list = this.$events[name]

        if (io.util.isArray(list)) {
          var pos = -1

          for (var i = 0, l = list.length; i < l; i++) {
            if (
              list[i] === fn ||
              (list[i].listener && list[i].listener === fn)
            ) {
              pos = i
              break
            }
          }

          if (pos < 0) {
            return this
          }

          list.splice(pos, 1)

          if (!list.length) {
            delete this.$events[name]
          }
        } else if (list === fn || (list.listener && list.listener === fn)) {
          delete this.$events[name]
        }
      }

      return this
    }

    /**
     * Removes all listeners for an event.
     *
     * @api public
     */

    EventEmitter.prototype.removeAllListeners = function (name) {
      if (name === undefined) {
        this.$events = {}
        return this
      }

      if (this.$events && this.$events[name]) {
        this.$events[name] = null
      }

      return this
    }

    /**
     * Gets all listeners for a certain event.
     *
     * @api publci
     */

    EventEmitter.prototype.listeners = function (name) {
      if (!this.$events) {
        this.$events = {}
      }

      if (!this.$events[name]) {
        this.$events[name] = []
      }

      if (!io.util.isArray(this.$events[name])) {
        this.$events[name] = [this.$events[name]]
      }

      return this.$events[name]
    }

    /**
     * Emits an event.
     *
     * @api public
     */

    EventEmitter.prototype.emit = function (name) {
      if (!this.$events) {
        return false
      }

      var handler = this.$events[name]

      if (!handler) {
        return false
      }

      var args = Array.prototype.slice.call(arguments, 1)

      if (typeof handler === 'function') {
        handler.apply(this, args)
      } else if (io.util.isArray(handler)) {
        var listeners = handler.slice()

        for (var i = 0, l = listeners.length; i < l; i++) {
          listeners[i].apply(this, args)
        }
      } else {
        return false
      }

      return true
    }
  })(
    typeof io !== 'undefined' ? io : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports
  );

  /**
   * socket.io JSON
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  /**
   * Based on JSON2 (http://www.JSON.org/js.html).
   */

  (function (exports, nativeJSON) {
    'use strict'

    // use native JSON if it's available
    if (nativeJSON && nativeJSON.parse) {
      return (exports.JSON = {
        parse: nativeJSON.parse,
        stringify: nativeJSON.stringify
      })
    }

    var JSON = (exports.JSON = {})

    function f (n) {
      // Format integers to have at least two digits.
      return n < 10 ? '0' + n : n
    }

    function date (d, key) {
      return isFinite(d.valueOf())
        ? d.getUTCFullYear() +
        '-' +
        f(d.getUTCMonth() + 1) +
        '-' +
        f(d.getUTCDate()) +
        'T' +
        f(d.getUTCHours()) +
        ':' +
        f(d.getUTCMinutes()) +
        ':' +
        f(d.getUTCSeconds()) +
        'Z'
        : null
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      gap,
      indent,
      meta = {
        // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '\\': '\\\\'
      },
      rep

    function quote (string) {
      // If the string contains no control characters, no quote characters, and no
      // backslash characters, then we can safely slap some quotes around it.
      // Otherwise we must also replace the offending characters with safe escape
      // sequences.

      escapable.lastIndex = 0
      return escapable.test(string)
        ? '"' +
        string.replace(escapable, function (a) {
          var c = meta[a]
          return typeof c === 'string'
            ? c
            : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)
        }) +
        '"'
        : '"' + string + '"'
    }

    function str (key, holder) {
      // Produce a string from holder[key].

      var i, // The loop counter.
        k, // The member key.
        v, // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key]

      // If the value has a toJSON method, call it to obtain a replacement value.

      if (value instanceof Date) {
        value = date(key)
      }

      // If we were called with a replacer function, then call the replacer to
      // obtain a replacement value.

      if (typeof rep === 'function') {
        value = rep.call(holder, key, value)
      }

      // What happens next depends on the value's type.

      switch (typeof value) {
        case 'string':
          return quote(value)

        case 'number':
          // JSON numbers must be finite. Encode non-finite numbers as null.

          return isFinite(value) ? String(value) : 'null'

        case 'boolean':
        case 'null':
          // If the value is a boolean or null, convert it to a string. Note:
          // typeof null does not produce 'null'. The case is included here in
          // the remote chance that this gets fixed someday.

          return String(value)

        // If the type is 'object', we might be dealing with an object or an array or
        // null.

        case 'object':
          // Due to a specification blunder in ECMAScript, typeof null is 'object',
          // so watch out for that case.

          if (!value) {
            return 'null'
          }

          // Make an array to hold the partial results of stringifying this object value.

          gap += indent
          partial = []

          // Is the value an array?

          if (Object.prototype.toString.apply(value) === '[object Array]') {
            // The value is an array. Stringify every element. Use null as a placeholder
            // for non-JSON values.

            length = value.length
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value) || 'null'
            }

            // Join all of the elements together, separated with commas, and wrap them in
            // brackets.

            v =
              partial.length === 0
                ? '[]'
                : gap
                  ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                  : '[' + partial.join(',') + ']'
            gap = mind
            return v
          }

          // If the replacer is an array, use it to select the members to be stringified.

          if (rep && typeof rep === 'object') {
            length = rep.length
            for (i = 0; i < length; i += 1) {
              if (typeof rep[i] === 'string') {
                k = rep[i]
                v = str(k, value)
                if (v) {
                  partial.push(quote(k) + (gap ? ': ' : ':') + v)
                }
              }
            }
          } else {
            // Otherwise, iterate through all of the keys in the object.

            for (k in value) {
              if (Object.prototype.hasOwnProperty.call(value, k)) {
                v = str(k, value)
                if (v) {
                  partial.push(quote(k) + (gap ? ': ' : ':') + v)
                }
              }
            }
          }

          // Join all of the member texts together, separated with commas,
          // and wrap them in braces.

          v =
            partial.length === 0
              ? '{}'
              : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}'
          gap = mind
          return v
      }
    }

    // If the JSON object does not yet have a stringify method, give it one.

    JSON.stringify = function (value, replacer, space) {
      // The stringify method takes a value and an optional replacer, and an optional
      // space parameter, and returns a JSON text. The replacer can be a function
      // that can replace values, or an array of strings that will select the keys.
      // A default replacer method can be provided. Use of the space parameter can
      // produce text that is more easily readable.

      var i
      gap = ''
      indent = ''

      // If the space parameter is a number, make an indent string containing that
      // many spaces.

      if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
          indent += ' '
        }

        // If the space parameter is a string, it will be used as the indent string.
      } else if (typeof space === 'string') {
        indent = space
      }

      // If there is a replacer, it must be a function or an array.
      // Otherwise, throw an error.

      rep = replacer
      if (
        replacer &&
        typeof replacer !== 'function' &&
        (typeof replacer !== 'object' || typeof replacer.length !== 'number')
      ) {
        throw new Error('socket.io:: replacer cannot JSON.stringify')
      }

      return str('', { '': value })
    }

    // If the JSON object does not yet have a parse method, give it one.

    JSON.parse = function (text, reviver) {
      // The parse method takes a text and an optional reviver function, and returns
      // a JavaScript value if the text is a valid JSON text.

      var j

      function walk (holder, key) {
        // The walk method is used to recursively walk the resulting structure so
        // that modifications can be made.

        var k,
          v,
          value = holder[key]
        if (value && typeof value === 'object') {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = walk(value, k)
              if (v !== undefined) {
                value[k] = v
              } else {
                delete value[k]
              }
            }
          }
        }
        return reviver.call(holder, key, value)
      }

      // Parsing happens in four stages. In the first stage, we replace certain
      // Unicode characters with escape sequences. JavaScript handles many characters
      // incorrectly, either silently deleting them, or treating them as line endings.

      text = String(text)
      cx.lastIndex = 0
      if (cx.test(text)) {
        text = text.replace(cx, function (a) {
          return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)
        })
      }

      // In the second stage, we run the text against regular expressions that look
      // for non-JSON patterns. We are especially concerned with '()' and 'new'
      // because they can cause invocation, and '=' because it can cause mutation.
      // But just to be safe, we want to reject all unexpected forms.

      // We split the second stage into 4 regexp operations in order to work around
      // crippling inefficiencies in IE's and Safari's regexp engines. First we
      // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
      // replace all simple value tokens with ']' characters. Third, we delete all
      // open brackets that follow a colon or comma or that begin the text. Finally,
      // we look to see that the remaining characters are only whitespace or ']' or
      // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (
        /^[\],:{}\s]*$/.test(
          text
            .replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
            .replace(
              /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
              ']'
            )
            .replace(/(?:^|:|,)(?:\s*\[)+/g, '')
        )
      ) {
        // In the third stage we use the eval function to compile the text into a
        // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
        // in JavaScript: it can begin a block or an object literal. We wrap the text
        // in parens to eliminate the ambiguity.

        j = eval('(' + text + ')')

        // In the optional fourth stage, we recursively walk the new structure, passing
        // each name/value pair to a reviver function for possible transformation.

        return typeof reviver === 'function' ? walk({ '': j }, '') : j
      }

      // If the text is not JSON parseable, then a SyntaxError is thrown.

      throw new SyntaxError('socket.io:: reviver cannot JSON.parse')
    }
  })(
    typeof io !== 'undefined' ? io : module.exports,
    typeof JSON !== 'undefined' ? JSON : undefined
  );

  /**
   * socket.io parser
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io) {
    /**
     * Parser namespace.
     *
     * @namespace
     */

    var parser = (exports.parser = {})

    /**
     * Packet types.
     */

    var packets = (parser.packets = [
      'disconnect',
      'connect',
      'heartbeat',
      'message',
      'json',
      'event',
      'ack',
      'error',
      'noop'
    ])

    /**
     * Errors reasons.
     */

    var reasons = (parser.reasons = [
      'transport not supported',
      'client not handshaken',
      'unauthorized'
    ])

    /**
     * Errors advice.
     */

    var advice = (parser.advice = ['reconnect'])

    /**
     * Shortcuts.
     */

    var JSON = io.JSON,
      indexOf = io.util.indexOf

    /**
     * Encodes a packet.
     *
     * @api private
     */

    parser.encodePacket = function (packet) {
      var type = indexOf(packets, packet.type),
        id = packet.id || '',
        endpoint = packet.endpoint || '',
        ack = packet.ack,
        data = null

      switch (packet.type) {
        case 'error':
          var reason = packet.reason ? indexOf(reasons, packet.reason) : '',
            adv = packet.advice ? indexOf(advice, packet.advice) : ''

          if (reason !== '' || adv !== '') { data = reason + (adv !== '' ? '+' + adv : '') }

          break

        case 'message':
          if (packet.data !== '') data = packet.data
          break

        case 'event':
          var ev = { name: packet.name }

          if (packet.args && packet.args.length) {
            ev.args = packet.args
          }

          data = JSON.stringify(ev)
          break

        case 'json':
          data = JSON.stringify(packet.data)
          break

        case 'connect':
          if (packet.qs) data = packet.qs
          break

        case 'ack':
          data =
            packet.ackId +
            (packet.args && packet.args.length
              ? '+' + JSON.stringify(packet.args)
              : '')
          break
      }

      // construct packet with required fragments
      var encoded = [type, id + (ack == 'data' ? '+' : ''), endpoint]

      // data fragment is optional
      if (data !== null && data !== undefined) encoded.push(data)

      return encoded.join(':')
    }

    /**
     * Encodes multiple messages (payload).
     *
     * @param {Array} messages
     * @api private
     */

    parser.encodePayload = function (packets) {
      var decoded = ''

      if (packets.length == 1) return packets[0]

      for (var i = 0, l = packets.length; i < l; i++) {
        var packet = packets[i]
        decoded += '\ufffd' + packet.length + '\ufffd' + packets[i]
      }

      return decoded
    }

    /**
     * Decodes a packet
     *
     * @api private
     */

    var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/

    parser.decodePacket = function (data) {
      var pieces = data.match(regexp)

      if (!pieces) return {}

      var id = pieces[2] || '',
        data = pieces[5] || '',
        packet = {
          type: packets[pieces[1]],
          endpoint: pieces[4] || ''
        }

      // whether we need to acknowledge the packet
      if (id) {
        packet.id = id
        if (pieces[3]) packet.ack = 'data'
        else packet.ack = true
      }

      // handle different packet types
      switch (packet.type) {
        case 'error':
          var pieces = data.split('+')
          packet.reason = reasons[pieces[0]] || ''
          packet.advice = advice[pieces[1]] || ''
          break

        case 'message':
          packet.data = data || ''
          break

        case 'event':
          try {
            var opts = JSON.parse(data)
            packet.name = opts.name
            packet.args = opts.args
          } catch (e) { }

          packet.args = packet.args || []
          break

        case 'json':
          try {
            packet.data = JSON.parse(data)
          } catch (e) { }
          break

        case 'connect':
          packet.qs = data || ''
          break

        case 'ack':
          var pieces = data.match(/^([0-9]+)(\+)?(.*)/)
          if (pieces) {
            packet.ackId = pieces[1]
            packet.args = []

            if (pieces[3]) {
              try {
                packet.args = pieces[3] ? JSON.parse(pieces[3]) : []
              } catch (e) { }
            }
          }
          break

        case 'disconnect':
        case 'heartbeat':
          break
      }

      return packet
    }

    /**
     * Decodes data payload. Detects multiple messages
     *
     * @return {Array} messages
     * @api public
     */

    parser.decodePayload = function (data) {
      // IE doesn't like data[i] for unicode chars, charAt works fine
      var _findEndChar = function (_start, _data) {
        var l = 0
        for (var i = _start; i < _data.length; i++) {
          if (_data.charAt(i) == '\ufffd') {
            return l
            break
          } else l++
        }
        return l
      }
      if (data.charAt(0) == '\ufffd') {
        var ret = []
        for (var i = 1, length = ''; i < data.length; i++) {
          if (data.charAt(i) == '\ufffd') {
            var _data = data.substr(i + 1).substr(0, length)
            if (
              data.charAt(i + 1 + Number(length)) != '\ufffd' &&
              i + 1 + Number(length) != data.length
            ) {
              var _len = Number(length)
              l = _findEndChar(i + _len + 1, data)
              _data = data.substr(i + 1).substr(0, _len + l)
              i += l
            }
            ret.push(parser.decodePacket(_data))
            i += Number(length) + 1
            length = ''
          } else {
            length += data.charAt(i)
          }
        }

        return ret
      } else {
        return [parser.decodePacket(data)]
      }
    }
  })(
    typeof io !== 'undefined' ? io : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports
  );
  /**
   * socket.io Transport template
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io) {
    /**
     * Expose constructor.
     */

    exports.Transport = Transport

    /**
     * This is the transport template for all supported transport methods.
     *
     * @constructor
     * @api public
     */

    function Transport (socket, sessid) {
      this.socket = socket
      this.sessid = sessid
    }

    /**
     * Apply EventEmitter mixin.
     */

    io.util.mixin(Transport, io.EventEmitter)

    /**
     * Indicates whether heartbeats is enabled for this transport
     *
     * @api private
     */

    Transport.prototype.heartbeats = function () {
      return true
    }

    /**
     * Handles the response from the server. When a new response is received
     * it will automatically update the timeout, decode the message and
     * forwards the response to the onMessage function for further processing.
     *
     * @param {String} data Response from the server.
     * @api private
     */

    Transport.prototype.onData = function (data) {
      // 当一个 transport 超时之后, 会尝试连接下一个 transport
      // 但是有可能第一个 transport 还是连上了
      // 那么这里加一个判断, 如果 this 不是当前的 transport, 那么直接返回 @hzzhangyingya
      if (this !== this.socket.transport) {
        return this
      }
      this.clearCloseTimeout()

      // If the connection in currently open (or in a reopening state) reset the close
      // timeout since we have just received data. This check is necessary so
      // that we don't reset the timeout on an explicitly disconnected connection.
      if (
        this.socket.connected ||
        this.socket.connecting ||
        this.socket.reconnecting
      ) {
        this.setCloseTimeout()
      }

      if (data !== '') {
        // todo: we should only do decodePayload for xhr transports
        var msgs = io.parser.decodePayload(data)

        if (msgs && msgs.length) {
          for (var i = 0, l = msgs.length; i < l; i++) {
            this.onPacket(msgs[i])
          }
        }
      }

      return this
    }

    /**
     * Handles packets.
     *
     * @api private
     */

    Transport.prototype.onPacket = function (packet) {
      this.socket.setHeartbeatTimeout()

      if (packet.type == 'heartbeat') {
        return this.onHeartbeat()
      }

      if (packet.type == 'connect' && packet.endpoint == '') {
        this.onConnect()
      }

      if (packet.type == 'error' && packet.advice == 'reconnect') {
        this.isOpen = false
      }

      this.socket.onPacket(packet)

      return this
    }

    /**
     * Sets close timeout
     *
     * @api private
     */

    Transport.prototype.setCloseTimeout = function () {
      if (!this.closeTimeout) {
        var self = this

        this.closeTimeout = setTimeout(function () {
          self.onDisconnect()
        }, this.socket.closeTimeout)
      }
    }

    /**
     * Called when transport disconnects.
     *
     * @api private
     */

    Transport.prototype.onDisconnect = function () {
      if (this.isOpen) this.close()
      this.clearTimeouts()
      // 如果当前 socket 的 transport 不是自己, 那么不管 @hzzhangyingya
      if (!this.socket) {
        return this
      }
      if (this.socket.transport === this) {
        this.socket.onDisconnect()
      } else {
        this.socket.setBuffer(false)
      }
      return this
    }

    /**
     * Called when transport connects
     *
     * @api private
     */

    Transport.prototype.onConnect = function () {
      this.socket.onConnect()
      return this
    }

    /**
     * Clears close timeout
     *
     * @api private
     */

    Transport.prototype.clearCloseTimeout = function () {
      if (this.closeTimeout) {
        clearTimeout(this.closeTimeout)
        this.closeTimeout = null
      }
    }

    /**
     * Clear timeouts
     *
     * @api private
     */

    Transport.prototype.clearTimeouts = function () {
      this.clearCloseTimeout()

      if (this.reopenTimeout) {
        clearTimeout(this.reopenTimeout)
      }
    }

    /**
     * Sends a packet
     *
     * @param {Object} packet object.
     * @api private
     */

    Transport.prototype.packet = function (packet) {
      this.send(io.parser.encodePacket(packet))
    }

    /**
     * Send the received heartbeat message back to server. So the server
     * knows we are still connected.
     *
     * @param {String} heartbeat Heartbeat response from the server.
     * @api private
     */

    Transport.prototype.onHeartbeat = function (heartbeat) {
      this.packet({ type: 'heartbeat' })
    }

    /**
     * Called when the transport opens.
     *
     * @api private
     */

    Transport.prototype.onOpen = function () {
      this.isOpen = true
      this.clearCloseTimeout()
      this.socket.onOpen()
    }

    /**
     * Notifies the base when the connection with the Socket.IO server
     * has been disconnected.
     *
     * @api private
     */

    Transport.prototype.onClose = function () {
      var self = this

      /* FIXME: reopen delay causing a infinit loop
      this.reopenTimeout = setTimeout(function () {
        self.open();
      }, this.socket.options['reopen delay']); */

      this.isOpen = false
      // 如果当前 socket 的 transport 不是自己, 那么不管 @hzzhangyingya
      if (this.socket.transport === this) {
        this.socket.onClose()
      } else {
        this.socket.setBuffer(false)
      }
      this.onDisconnect()
      if (this.onDisconnectDone instanceof Function) {
        this.onDisconnectDone(null)
      }
      if (this.onConnectionOver instanceof Function) {
        this.onConnectionOver(null)
      }
    }

    // 该方法用于重写进行回调，注册在Transport.onClose函数中，保证连接真正的被关闭
    Transport.prototype.onDisconnectDone = function () { }

    // 此方法用于给sdk回调触发ondisconnect
    Transport.prototype.onConnectionOver = function () {}

    /**
     * Generates a connection url based on the Socket.IO URL Protocol.
     * See <https://github.com/learnboost/socket.io-node/> for more details.
     *
     * @returns {String} Connection url
     * @api private
     */

    Transport.prototype.prepareUrl = function () {
      var options = this.socket.options

      return (
        this.scheme() +
        '://' +
        options.host +
        ':' +
        options.port +
        '/' +
        options.resource +
        '/' +
        io.protocol +
        '/' +
        this.name +
        '/' +
        this.sessid
      )
    }

    /**
     * Checks if the transport is ready to start a connection.
     *
     * @param {Socket} socket The socket instance that needs a transport
     * @param {Function} fn The callback
     * @api private
     */

    Transport.prototype.ready = function (socket, fn) {
      fn.call(this)
    }
  })(
    typeof io !== 'undefined' ? io : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports
  );
  /**
   * socket.io Socket
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io, global) {
    /**
     * Expose constructor.
     */

    exports.Socket = Socket

    /**
     * Create a new `Socket.IO client` which can establish a persistent
     * connection with a Socket.IO enabled server.
     *
     * @api public
     */

    function Socket (options) {
      this.options = {
        port: 80,
        secure: false,
        document: 'document' in global ? document : false,
        resource: 'socket.io',
        transports: options.transports || io.transports,
        'connect timeout': 10000,
        'try multiple transports': true,
        reconnect: true,
        'reconnection delay': 500,
        'reconnection limit': Infinity,
        'reopen delay': 3000,
        'max reconnection attempts': 10,
        'sync disconnect on unload': false,
        'auto connect': true,
        'flash policy port': 10843,
        manualFlush: false
      }

      io.util.merge(this.options, options)

      this.connected = false
      this.open = false
      this.connecting = false
      this.reconnecting = false
      this.namespaces = {}
      this.buffer = []
      this.doBuffer = false

      if (
        this.options['sync disconnect on unload'] &&
        (!this.isXDomain() || io.util.ua.hasCORS)
      ) {
        var self = this
        io.util.on(
          global,
          'beforeunload',
          function () {
            self.disconnectSync()
          },
          false
        )
      }

      if (this.options['auto connect']) {
        this.connect()
      }
    }

    /**
     * Apply EventEmitter mixin.
     */

    io.util.mixin(Socket, io.EventEmitter)

    /**
     * Returns a namespace listener/emitter for this socket
     *
     * @api public
     */

    Socket.prototype.of = function (name) {
      if (!this.namespaces[name]) {
        this.namespaces[name] = new io.SocketNamespace(this, name)

        if (name !== '') {
          this.namespaces[name].packet({ type: 'connect' })
        }
      }

      return this.namespaces[name]
    }

    /**
     * Emits the given event to the Socket and all namespaces
     *
     * @api private
     */

    Socket.prototype.publish = function () {
      this.emit.apply(this, arguments)

      var nsp

      for (var i in this.namespaces) {
        if (this.namespaces.hasOwnProperty(i)) {
          nsp = this.of(i)
          nsp.$emit.apply(nsp, arguments)
        }
      }
    }

    /**
     * Performs the handshake
     *
     * @api private
     */

    function empty () { }

    Socket.prototype.handshake = function (fn) {
      var self = this,
        options = this.options

      function complete (data) {
        if (data instanceof Error) {
          self.connecting = false
          self.onError(data.message)
        } else {
          console.log('SocketIO handshake success ' + data)
          fn.apply(null, data.split(':'))
        }
      }

      var url = [
        'http' + (options.secure ? 's' : '') + ':/',
        options.host + ':' + options.port,
        options.resource,
        io.protocol,
        io.util.query(this.options.query, 't=' + +new Date())
      ].join('/')
      // 微信小程序里没有document
      if (
        this.isXDomain() &&
        !io.util.ua.hasCORS &&
        typeof document !== 'undefined' &&
        document &&
        document.getElementsByTagName
      ) {
        var insertAt = document.getElementsByTagName('script')[0],
          script = document.createElement('script')

        script.src = url + '&jsonp=' + io.j.length
        // https://github.com/Automattic/socket.io/issues/1020#issuecomment-9684494
        // when script failed to load, trigger onError which will trigger reconnecting
        script.onreadystatechange = function () {
          // 'loaded' means failed (yeah, I know)
          // github上说loaded的时候是脚本失败了, 但是我发现在IE下, 脚本成功执行, 最后状态也是loaded
          // 所以再加一个条件, 在此 script 没有被移除的情况下才算失败
          if (this.readyState == 'loaded' && !!script.parentNode) {
            script.parentNode.removeChild(script)
            self.connecting = false
            !self.reconnecting && self.onError('Server down or port not open')
            // 注意, 下面这行代码是云信业务专用的, 云信是不自动重连, 需要手动控制重连的逻辑, 在这里通知外部握手失败, 这样就处理重连逻辑
            self.publish('handshake_failed')
          }
        }
        insertAt.parentNode.insertBefore(script, insertAt)

        io.j.push(function (data) {
          complete(data)
          script.parentNode.removeChild(script)
        })
      } else {
        var xhr = io.util.request()
        xhr.open('GET', url, true)
        xhr.timeout = 10000
        if (this.isXDomain()) {
          xhr.withCredentials = true
        }
        xhr.onreadystatechange = function () {
          // debugger
          if (xhr.readyState == 4) {
            xhr.onreadystatechange = empty

            if (xhr.status == 200) {
              complete(xhr.responseText)
            } else if (xhr.status == 403) {
              self.connecting = false
              self.onError(xhr.responseText)
              // 注意, 下面这行代码是云信业务专用的, 云信是不自动重连, 需要手动控制重连的逻辑, 在这里通知外部握手失败, 这样就处理重连逻辑
              self.publish('handshake_failed')
            } else {
              self.connecting = false
              !self.reconnecting && self.onError(xhr.responseText)
              // 注意, 下面这行代码是云信业务专用的, 云信是不自动重连, 需要手动控制重连的逻辑, 在这里通知外部握手失败, 这样就处理重连逻辑
              self.publish('handshake_failed')
            }
          }
        }
        xhr.ontimeout = function (e) {
          // XMLHttpRequest 超时。在此做某事。
          self.connecting = false
          !self.reconnecting && self.onError(xhr.responseText)
          self.publish('handshake_failed')
        }
        xhr.send(null)
      }
    }

    /**
     * Connects to the server.
     *
     * @param {Function} [fn] Callback.
     * @returns {io.Socket}
     * @api public
     */

    Socket.prototype.connect = function (fn) {
      if (this.connecting) {
        return this
      }

      var self = this
      self.connecting = true

      this.handshake(function (sid, heartbeat, close, transports) {
        self.sessionid = sid
        self.closeTimeout = close * 1000
        self.heartbeatTimeout = heartbeat * 1000
        if (!self.transports) {
          self.transports = self.origTransports = transports
            ? io.util.intersect(transports.split(','), self.options.transports)
            : self.options.transports
        }

        console.log('SocketIO transports: ' + self.transports + ' opt:' + self.options.transports)

        self.setHeartbeatTimeout()

        self.once('connect', function () {
          clearTimeout(self.connectTimeoutTimer)
          self.connectTimeoutTimer = null

          fn && typeof fn === 'function' && fn()
        })

        self.doConnect()
      })

      return this
    }

    Socket.prototype.doConnect = function () {
      var self = this

      if (self.transport) self.transport.clearTimeouts()

      self.transport = self.getTransport(self.transports)

      if (!self.transport) return self.publish('connect_failed')

      // once the transport is ready
      self.transport.ready(self, function () {
        self.connecting = true
        self.publish('connecting', self.transport.name)
        self.transport.open()

        if (self.options['connect timeout']) {
          if (self.connectTimeoutTimer) {
            clearTimeout(self.connectTimeoutTimer)
          }
          self.connectTimeoutTimer = setTimeout(
            self.tryNextTransport.bind(self),
            self.options['connect timeout']
          )
        }
      })
    }

    /**
     * Find an available transport based on the options supplied in the constructor.
     *
     * @api private
     */

    Socket.prototype.getTransport = function (override) {
      var transports = override || this.transports,
        match

      for (var i = 0, transport; (transport = transports[i]); i++) {
        console.log(
          'SocketIO check ' +
          transport +
          ' ' +
          io.Transport[transport].check(this) +
          ' , cors ' +
          io.Transport[transport].xdomainCheck(this)
        )
        if (
          io.Transport[transport] &&
          io.Transport[transport].check(this) &&
          (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))
        ) {
          var result = new io.Transport[transport](this, this.sessionid)
          return result
        }
      }

      return null
    }

    Socket.prototype.tryNextTransport = function () {
      console.log('SocketIO try next transport')
      var self = this
      if (!self.connected) {
        self.connecting = false

        if (self.options['try multiple transports']) {
          var remaining = self.transports

          while (
            remaining.length > 0 &&
            remaining.splice(0, 1)[0] != self.transport.name
          ) { }

          if (remaining.length) {
            self.doConnect()
          } else {
            self.publish('connect_failed')
          }
        }
      }
    }

    /**
     * Clears and sets a new heartbeat timeout using the value given by the
     * server during the handshake.
     *
     * @api private
     */

    Socket.prototype.setHeartbeatTimeout = function () {
      clearTimeout(this.heartbeatTimeoutTimer)
      if (this.transport && !this.transport.heartbeats()) return

      var self = this
      this.heartbeatTimeoutTimer = setTimeout(function () {
        self.transport && self.transport.onClose()
      }, this.heartbeatTimeout)
    }

    /**
     * Sends a message.
     *
     * @param {Object} data packet.
     * @returns {io.Socket}
     * @api public
     */

    Socket.prototype.packet = function (data) {
      if (this.connected && !this.doBuffer) {
        this.transport.packet(data)
      } else {
        this.buffer.push(data)
      }

      return this
    }

    /**
     * Sets buffer state
     *
     * @api private
     */

    Socket.prototype.setBuffer = function (v) {
      this.doBuffer = v

      if (!v && this.connected && this.buffer.length) {
        if (!this.options['manualFlush']) {
          this.flushBuffer()
        }
      }
    }

    /**
     * Flushes the buffer data over the wire.
     * To be invoked manually when 'manualFlush' is set to true.
     *
     * @api public
     */

    Socket.prototype.flushBuffer = function () {
      this.transport.payload(this.buffer)
      this.buffer = []
    }

    /**
     * Disconnect the established connect.
     *
     * @returns {io.Socket}
     * @api public
     */

    Socket.prototype.disconnect = function () {
      if (this.connected || this.connecting) {
        if (this.open) {
          this.of('').packet({ type: 'disconnect' })
        }

        // handle disconnection immediately
        this.onDisconnect('booted')
      }

      return this
    }

    /**
     * Disconnects the socket with a sync XHR.
     *
     * @api private
     */

    Socket.prototype.disconnectSync = function () {
      // ensure disconnection
      var xhr = io.util.request()
      var uri =
        [
          'http' + (this.options.secure ? 's' : '') + ':/',
          this.options.host + ':' + this.options.port,
          this.options.resource,
          io.protocol,
          '',
          this.sessionid
        ].join('/') + '/?disconnect=1'

      xhr.open('GET', uri, false)
      xhr.send(null)

      // handle disconnection immediately
      this.onDisconnect('booted')
    }

    /**
     * Check if we need to use cross domain enabled transports. Cross domain would
     * be a different port or different domain name.
     *
     * @returns {Boolean}
     * @api private
     */

    Socket.prototype.isXDomain = function () {
      var port =
        global.location.port ||
        (global.location.protocol == 'https:' ? 443 : 80)

      return (
        this.options.host !== global.location.hostname ||
        this.options.port != port
      )
    }

    /**
     * Called upon handshake.
     *
     * @api private
     */

    Socket.prototype.onConnect = function () {
      if (!this.connected) {
        this.connected = true
        this.connecting = false
        if (!this.doBuffer) {
          // make sure to flush the buffer
          this.setBuffer(false)
        }
        this.emit('connect')
      }
    }

    /**
     * Called when the transport opens
     *
     * @api private
     */

    Socket.prototype.onOpen = function () {
      this.open = true
    }

    /**
     * Called when the transport closes.
     *
     * @api private
     */

    Socket.prototype.onClose = function () {
      this.open = false
      clearTimeout(this.heartbeatTimeoutTimer)
    }

    /**
     * Called when the transport first opens a connection
     *
     * @param text
     */

    Socket.prototype.onPacket = function (packet) {
      this.of(packet.endpoint).onPacket(packet)
    }

    /**
     * Handles an error.
     *
     * @api private
     */

    // // 该方法用于重写进行回调，注册在Transport.onClose函数中，保证连接真正的被关闭
    // Socket.prototype.onDisconnectDone = function () {
    // }

    Socket.prototype.onError = function (err) {
      if (err && err.advice) {
        if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
          this.disconnect()
          if (this.options.reconnect) {
            this.reconnect()
          }
        }
      }
      this.publish('error', err && err.reason ? err.reason : err)
      // console.log(this.transport, 111111111)
      // if (this.transport.onDisconnectDone instanceof Function) {
      //   this.transport.onDisconnectDone(err)
      // }
    }

    /**
     * Called when the transport disconnects.
     *
     * @api private
     */

    Socket.prototype.onDisconnect = function (reason) {
      var wasConnected = this.connected,
        wasConnecting = this.connecting

      this.connected = false
      this.connecting = false
      this.open = false

      if (wasConnected || wasConnecting) {
        this.transport.close()
        this.transport.clearTimeouts()
        if (wasConnected) {
          this.publish('disconnect', reason)

          if (
            reason != 'booted' &&
            this.options.reconnect &&
            !this.reconnecting
          ) {
            this.reconnect()
          }
        }
        // 安卓微信有些机器, 在尝试 WS 方式时会直接 WS.prototype.onClose, 然后会走到这里
        // 此时 connectTimeoutTimer 还未触发, 所以手动尝试下一个 transport
        if (wasConnecting) {
          if (this.connectTimeoutTimer) {
            clearTimeout(this.connectTimeoutTimer)
          }
          this.tryNextTransport()
        }
      }
    }

    /**
     * Called upon reconnection.
     *
     * @api private
     */

    Socket.prototype.reconnect = function () {
      this.reconnecting = true
      this.reconnectionAttempts = 0
      this.reconnectionDelay = this.options['reconnection delay']

      var self = this,
        maxAttempts = this.options['max reconnection attempts'],
        tryMultiple = this.options['try multiple transports'],
        limit = this.options['reconnection limit']

      function reset () {
        if (self.connected) {
          for (var i in self.namespaces) {
            if (self.namespaces.hasOwnProperty(i) && i !== '') {
              self.namespaces[i].packet({ type: 'connect' })
            }
          }
          self.publish(
            'reconnect',
            self.transport.name,
            self.reconnectionAttempts
          )
        }

        clearTimeout(self.reconnectionTimer)

        self.removeListener('connect_failed', maybeReconnect)
        self.removeListener('connect', maybeReconnect)

        self.reconnecting = false

        delete self.reconnectionAttempts
        delete self.reconnectionDelay
        delete self.reconnectionTimer
        delete self.redoTransports

        self.options['try multiple transports'] = tryMultiple
      }

      function maybeReconnect () {
        if (!self.reconnecting) {
          return
        }

        if (self.connected) {
          return reset()
        }

        if (self.connecting && self.reconnecting) {
          return (self.reconnectionTimer = setTimeout(maybeReconnect, 1000))
        }

        if (self.reconnectionAttempts++ >= maxAttempts) {
          if (!self.redoTransports) {
            self.on('connect_failed', maybeReconnect)
            self.options['try multiple transports'] = true
            self.transports = self.origTransports
            self.transport = self.getTransport()
            self.redoTransports = true
            self.connect()
          } else {
            self.publish('reconnect_failed')
            reset()
          }
        } else {
          if (self.reconnectionDelay < limit) {
            self.reconnectionDelay *= 2 // exponential back off
          }

          self.connect()
          self.publish(
            'reconnecting',
            self.reconnectionDelay,
            self.reconnectionAttempts
          )
          self.reconnectionTimer = setTimeout(
            maybeReconnect,
            self.reconnectionDelay
          )
        }
      }

      this.options['try multiple transports'] = false
      this.reconnectionTimer = setTimeout(
        maybeReconnect,
        this.reconnectionDelay
      )

      this.on('connect', maybeReconnect)
    }
  })(
    typeof io !== 'undefined' ? io : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports,
    root
  );
  /**
   * socket.io SocketNamespace
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io) {
    /**
     * Expose constructor.
     */

    exports.SocketNamespace = SocketNamespace

    /**
     * Socket namespace constructor.
     *
     * @constructor
     * @api public
     */

    function SocketNamespace (socket, name) {
      this.socket = socket
      this.name = name || ''
      this.flags = {}
      this.json = new Flag(this, 'json')
      this.ackPackets = 0
      this.acks = {}
    }

    /**
     * Apply EventEmitter mixin.
     */

    io.util.mixin(SocketNamespace, io.EventEmitter)

    /**
     * Copies emit since we override it
     *
     * @api private
     */

    SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit

    /**
     * Creates a new namespace, by proxying the request to the socket. This
     * allows us to use the synax as we do on the server.
     *
     * @api public
     */

    SocketNamespace.prototype.of = function () {
      return this.socket.of.apply(this.socket, arguments)
    }

    /**
     * Sends a packet.
     *
     * @api private
     */

    SocketNamespace.prototype.packet = function (packet) {
      packet.endpoint = this.name
      this.socket.packet(packet)
      this.flags = {}
      return this
    }

    /**
     * Sends a message
     *
     * @api public
     */

    SocketNamespace.prototype.send = function (data, fn) {
      var packet = {
        type: this.flags.json ? 'json' : 'message',
        data: data
      }

      if (typeof fn === 'function') {
        packet.id = ++this.ackPackets
        packet.ack = true
        this.acks[packet.id] = fn
      }

      return this.packet(packet)
    }

    /**
     * Emits an event
     *
     * @api public
     */

    SocketNamespace.prototype.emit = function (name) {
      var args = Array.prototype.slice.call(arguments, 1),
        lastArg = args[args.length - 1],
        packet = {
          type: 'event',
          name: name
        }

      if (typeof lastArg === 'function') {
        packet.id = ++this.ackPackets
        packet.ack = 'data'
        this.acks[packet.id] = lastArg
        args = args.slice(0, args.length - 1)
      }

      packet.args = args

      return this.packet(packet)
    }

    /**
     * Disconnects the namespace
     *
     * @api private
     */

    SocketNamespace.prototype.disconnect = function () {
      if (this.name === '') {
        this.socket.disconnect()
      } else {
        this.packet({ type: 'disconnect' })
        this.$emit('disconnect')
      }

      return this
    }

    /**
     * Handles a packet
     *
     * @api private
     */

    SocketNamespace.prototype.onPacket = function (packet) {
      var self = this

      function ack () {
        self.packet({
          type: 'ack',
          args: io.util.toArray(arguments),
          ackId: packet.id
        })
      }

      switch (packet.type) {
        case 'connect':
          this.$emit('connect')
          break

        case 'disconnect':
          if (this.name === '') {
            this.socket.onDisconnect(packet.reason || 'booted')
          } else {
            this.$emit('disconnect', packet.reason)
          }
          break

        case 'message':
        case 'json':
          var params = ['message', packet.data]

          if (packet.ack == 'data') {
            params.push(ack)
          } else if (packet.ack) {
            this.packet({ type: 'ack', ackId: packet.id })
          }

          this.$emit.apply(this, params)
          break

        case 'event':
          var params = [packet.name].concat(packet.args)

          if (packet.ack == 'data') params.push(ack)

          this.$emit.apply(this, params)
          break

        case 'ack':
          if (this.acks[packet.ackId]) {
            this.acks[packet.ackId].apply(this, packet.args)
            delete this.acks[packet.ackId]
          }
          break

        case 'error':
          console.error('SocketIO on packet error: ', packet)
          if (packet.advice) {
            this.socket.onError(packet)
          } else {
            if (packet.reason === 'unauthorized') {
              this.$emit('connect_failed', packet.reason)
            } else {
              this.$emit('error', packet.reason)
            }
          }
          break
      }
    }

    /**
     * Flag interface.
     *
     * @api private
     */

    function Flag (nsp, name) {
      this.namespace = nsp
      this.name = name
    }

    /**
     * Send a message
     *
     * @api public
     */

    Flag.prototype.send = function () {
      this.namespace.flags[this.name] = true
      this.namespace.send.apply(this.namespace, arguments)
    }

    /**
     * Emit an event
     *
     * @api public
     */

    Flag.prototype.emit = function () {
      this.namespace.flags[this.name] = true
      this.namespace.emit.apply(this.namespace, arguments)
    }
  })(
    typeof io !== 'undefined' ? io : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports
  );

  /**
   * socket.io WebSocket
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io, global) {
    /**
     * Expose constructor.
     */

    exports.websocket = WS

    /**
     * The WebSocket transport uses the HTML5 WebSocket API to establish an
     * persistent connection with the Socket.IO server. This transport will also
     * be inherited by the FlashSocket fallback as it provides a API compatible
     * polyfill for the WebSockets.
     *
     * @constructor
     * @extends {io.Transport}
     * @api public
     */

    function WS (socket) {
      io.Transport.apply(this, arguments)
    }

    /**
     * Inherits from Transport.
     */

    io.util.inherit(WS, io.Transport)

    /**
     * Transport name
     *
     * @api public
     */

    WS.prototype.name = 'websocket'

    /**
     * Initializes a new `WebSocket` connection with the Socket.IO server. We attach
     * all the appropriate listeners to handle the responses from the server.
     *
     * @returns {Transport}
     * @api public
     */

    WS.prototype.open = function () {
      var query = io.util.query(this.socket.options.query),
        self = this,
        Socket

      if (!Socket) {
        Socket = global.MozWebSocket || global.WebSocket
      }

      this.websocket = new Socket(this.prepareUrl() + query)

      this.websocket.onopen = function () {
        self.onOpen()
        self.socket.setBuffer(false)
      }
      this.websocket.onmessage = function (ev) {
        self.onData(ev.data)
      }
      this.websocket.onclose = function () {
        // 先 setBuffer, 然后 onClose, 在 onClose 里面可能会再次调用 setBuffer @hzzhangyingya
        self.socket.setBuffer(true)
        self.onClose()
      }
      this.websocket.onerror = function (e) {
        self.onError(e)
      }

      return this
    }

    /**
     * Send a message to the Socket.IO server. The message will automatically be
     * encoded in the correct message format.
     *
     * @returns {Transport}
     * @api public
     */

    // Do to a bug in the current IDevices browser, we need to wrap the send in a
    // setTimeout, when they resume from sleeping the browser will crash if
    // we don't allow the browser time to detect the socket has been closed
    if (io.util.ua.iDevice) {
      WS.prototype.send = function (data) {
        var self = this
        setTimeout(function () {
          self.websocket.send(data)
        }, 0)
        return this
      }
    } else {
      WS.prototype.send = function (data) {
        this.websocket.send(data)
        return this
      }
    }

    /**
     * Payload
     *
     * @api private
     */

    WS.prototype.payload = function (arr) {
      for (var i = 0, l = arr.length; i < l; i++) {
        this.packet(arr[i])
      }
      return this
    }

    /**
     * Disconnect the established `WebSocket` connection.
     *
     * @returns {Transport}
     * @api public
     */

    WS.prototype.close = function () {
      this.websocket.close()
      return this
    }

    /**
     * Handle the errors that `WebSocket` might be giving when we
     * are attempting to connect or send messages.
     *
     * @param {Error} e The error.
     * @api private
     */

    WS.prototype.onError = function (e) {
      this.socket.onError(e)
    }

    /**
     * Returns the appropriate scheme for the URI generation.
     *
     * @api private
     */
    WS.prototype.scheme = function () {
      return this.socket.options.secure ? 'wss' : 'ws'
    }

    /**
     * Checks if the browser has support for native `WebSockets` and that
     * it's not the polyfill created for the FlashSocket transport.
     *
     * @return {Boolean}
     * @api public
     */

    WS.check = function () {
      return (
        ('WebSocket' in global && !('__addTask' in WebSocket)) ||
        'MozWebSocket' in global
      )
    }

    /**
     * Check if the `WebSocket` transport support cross domain communications.
     *
     * @returns {Boolean}
     * @api public
     */

    WS.xdomainCheck = function () {
      return true
    }

    /**
     * Add the transport to your public io.transports array.
     *
     * @api private
     */

    io.transports.push('websocket')
  })(
    typeof io !== 'undefined' ? io.Transport : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports,
    root
  );

  /**
   * socket.io XHR
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io, global) {
    /**
     * Expose constructor.
     *
     * @api public
     */

    exports.XHR = XHR

    /**
     * XHR constructor
     *
     * @costructor
     * @api public
     */

    function XHR (socket) {
      if (!socket) return

      io.Transport.apply(this, arguments)
      this.sendBuffer = []
    }

    /**
     * Inherits from Transport.
     */

    io.util.inherit(XHR, io.Transport)

    /**
     * Establish a connection
     *
     * @returns {Transport}
     * @api public
     */

    XHR.prototype.open = function () {
      this.socket.setBuffer(false)
      this.onOpen()
      this.get()

      // we need to make sure the request succeeds since we have no indication
      // whether the request opened or not until it succeeded.
      this.setCloseTimeout()

      return this
    }

    /**
     * Check if we need to send data to the Socket.IO server, if we have data in our
     * buffer we encode it and forward it to the `post` method.
     *
     * @api private
     */

    XHR.prototype.payload = function (payload) {
      var msgs = []

      for (var i = 0, l = payload.length; i < l; i++) {
        msgs.push(io.parser.encodePacket(payload[i]))
      }

      this.send(io.parser.encodePayload(msgs))
    }

    /**
     * Send data to the Socket.IO server.
     *
     * @param data The message
     * @returns {Transport}
     * @api public
     */

    XHR.prototype.send = function (data) {
      this.post(data)
      return this
    }

    /**
     * Posts a encoded message to the Socket.IO server.
     *
     * @param {String} data A encoded message.
     * @api private
     */

    function empty () { }

    XHR.prototype.post = function (data) {
      var self = this
      this.socket.setBuffer(true)

      function stateChange () {
        if (this.readyState == 4) {
          this.onreadystatechange = empty
          self.posting = false

          if (this.status == 200) {
            self.socket.setBuffer(false)
          } else {
            self.onClose()
          }
        }
      }

      function onload () {
        this.onload = empty
        self.socket.setBuffer(false)
      }

      this.sendXHR = this.request('POST')

      if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
        this.sendXHR.onload = this.sendXHR.onerror = onload
      } else {
        this.sendXHR.onreadystatechange = stateChange
      }

      this.sendXHR.send(data)
    }

    /**
     * Disconnects the established `XHR` connection.
     *
     * @returns {Transport}
     * @api public
     */

    XHR.prototype.close = function () {
      this.onClose()
      return this
    }

    /**
     * Generates a configured XHR request
     *
     * @param {String} url The url that needs to be requested.
     * @param {String} method The method the request should use.
     * @returns {XMLHttpRequest}
     * @api private
     */

    XHR.prototype.request = function (method) {
      var req = io.util.request(this.socket.isXDomain()),
        query = io.util.query(this.socket.options.query, 't=' + +new Date())

      req.open(method || 'GET', this.prepareUrl() + query, true)

      if (method == 'POST') {
        try {
          if (req.setRequestHeader) {
            req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8')
          } else {
            // XDomainRequest
            req.contentType = 'text/plain'
          }
        } catch (e) { }
      }

      return req
    }

    /**
     * Returns the scheme to use for the transport URLs.
     *
     * @api private
     */

    XHR.prototype.scheme = function () {
      return this.socket.options.secure ? 'https' : 'http'
    }

    /**
     * Check if the XHR transports are supported
     *
     * @param {Boolean} xdomain Check if we support cross domain requests.
     * @returns {Boolean}
     * @api public
     */

    XHR.check = function (socket, xdomain) {
      try {
        var request = io.util.request(xdomain),
          usesXDomReq =
            global.XDomainRequest && request instanceof XDomainRequest,
          socketProtocol =
            socket && socket.options && socket.options.secure
              ? 'https:'
              : 'http:',
          isXProtocol =
            global.location && socketProtocol != global.location.protocol
        if (request && !(usesXDomReq && isXProtocol)) {
          return true
        }
      } catch (e) { }

      return false
    }

    /**
     * Check if the XHR transport supports cross domain requests.
     *
     * @returns {Boolean}
     * @api public
     */

    XHR.xdomainCheck = function (socket) {
      return XHR.check(socket, true)
    }
  })(
    typeof io !== 'undefined' ? io.Transport : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports,
    root
  );

  /**
   * socket.io XHRPolling
   * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
   * MIT Licensed
   */

  (function (exports, io, global) {
    /**
     * Expose constructor.
     */

    exports['xhr-polling'] = XHRPolling

    /**
     * The XHR-polling transport uses long polling XHR requests to create a
     * "persistent" connection with the server.
     *
     * @constructor
     * @api public
     */

    function XHRPolling () {
      io.Transport.XHR.apply(this, arguments)
    }

    /**
     * Inherits from XHR transport.
     */

    io.util.inherit(XHRPolling, io.Transport.XHR)

    /**
     * Merge the properties from XHR transport
     */

    io.util.merge(XHRPolling, io.Transport.XHR)

    /**
     * Transport name
     *
     * @api public
     */

    XHRPolling.prototype.name = 'xhr-polling'

    /**
     * Indicates whether heartbeats is enabled for this transport
     *
     * @api private
     */

    XHRPolling.prototype.heartbeats = function () {
      return false
    }

    /**
     * Establish a connection, for iPhone and Android this will be done once the page
     * is loaded.
     *
     * @returns {Transport} Chaining.
     * @api public
     */

    XHRPolling.prototype.open = function () {
      var self = this

      io.Transport.XHR.prototype.open.call(self)
      return false
    }

    /**
     * Starts a XHR request to wait for incoming messages.
     *
     * @api private
     */

    function empty () { }

    XHRPolling.prototype.get = function () {
      if (!this.isOpen) return

      var self = this

      function stateChange () {
        if (this.readyState == 4) {
          this.onreadystatechange = empty

          if (this.status == 200) {
            self.onData(this.responseText)
            self.get()
          } else {
            self.onClose()
          }
        }
      }

      function onload () {
        this.onload = empty
        this.onerror = empty
        self.retryCounter = 1
        self.onData(this.responseText)
        self.get()
      }

      function onerror () {
        self.retryCounter++
        if (!self.retryCounter || self.retryCounter > 3) {
          self.onClose()
        } else {
          self.get()
        }
      }

      this.xhr = this.request()

      if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
        this.xhr.onload = onload
        this.xhr.onerror = onerror
      } else {
        this.xhr.onreadystatechange = stateChange
      }

      this.xhr.send(null)
    }

    /**
     * Handle the unclean close behavior.
     *
     * @api private
     */

    XHRPolling.prototype.onClose = function () {
      io.Transport.XHR.prototype.onClose.call(this)

      if (this.xhr) {
        this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty
        try {
          this.xhr.abort()
        } catch (e) { }
        this.xhr = null
      }
    }

    /**
     * Webkit based browsers show a infinit spinner when you start a XHR request
     * before the browsers onload event is called so we need to defer opening of
     * the transport until the onload event is called. Wrapping the cb in our
     * defer method solve this.
     *
     * @param {Socket} socket The socket instance that needs a transport
     * @param {Function} fn The callback
     * @api private
     */

    XHRPolling.prototype.ready = function (socket, fn) {
      var self = this

      io.util.defer(function () {
        fn.call(self)
      })
    }

    /**
     * Add the transport to your public io.transports array.
     *
     * @api private
     */

    io.transports.push('xhr-polling')
  })(
    typeof io !== 'undefined' ? io.Transport : module.exports,
    typeof io !== 'undefined' ? io : module.parent.exports,
    root
  )

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return io
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  }
})()

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/array/from.js":
/*!**********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/array/from.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/array/from */ "./node_modules/core-js/library/fn/array/from.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/assign.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/assign.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ "./node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol/iterator.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ "./node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/defineProperty.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/defineProperty.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/extends.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/extends.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(/*! ../core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/toConsumableArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/toConsumableArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(/*! ../core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/typeof.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/typeof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(/*! ../core-js/symbol/iterator */ "./node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(/*! ../core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/core-js/library/fn/array/from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/from.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/es6.array.from */ "./node_modules/core-js/library/modules/es6.array.from.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.from;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.symbol */ "./node_modules/core-js/library/modules/es6.symbol.js");
__webpack_require__(/*! ../../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
__webpack_require__(/*! ../../modules/es7.symbol.observable */ "./node_modules/core-js/library/modules/es7.symbol.observable.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Symbol;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js").f('iterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_classof.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_classof.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_cof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_create-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_create-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_defined.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-keys.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iobject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array-iter.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array-iter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-call.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-call.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-create.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-define.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-detect.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-detect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-step.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iterators.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_meta.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_meta.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-assign.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dps.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopd.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopd.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn-ext.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn-ext.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gops.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gpo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-pie.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared-key.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-at.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-integer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-iobject.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-length.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_uid.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-define.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-define.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.from.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.from.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/library/modules/_is-array-iter.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/library/modules/_create-property.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.assign.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-property.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.symbol.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.symbol.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/library/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/library/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.async-iterator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.observable.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('observable');


/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/deep-access/index.js":
/*!*******************************************!*\
  !*** ./node_modules/deep-access/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = deep;

function deep (obj, prop) {
  var segs = prop.split('.');
  while (segs.length) {
    var seg = segs.shift();
    var existential = false;
    if (seg[seg.length - 1] == '?') {
      seg = seg.slice(0, -1);
      existential = true;
    }
    obj = obj[seg];
    if (!obj && existential) return obj;
  }
  return obj;
}


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @api private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {Mixed} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Boolean} exists Only check if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Remove the listeners of a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {Mixed} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
         listeners.fn === fn
      && (!once || listeners.once)
      && (!context || listeners.context === context)
    ) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
           listeners[i].fn !== fn
        || (once && !listeners[i].once)
        || (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {String|Symbol} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! is-function */ "./node_modules/is-function/index.js")

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}


/***/ }),

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/is-function/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-function/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};


/***/ }),

/***/ "./node_modules/javascript-natural-sort/naturalSort.js":
/*!*************************************************************!*\
  !*** ./node_modules/javascript-natural-sort/naturalSort.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 */
/*jshint unused:false */
module.exports = function naturalSort (a, b) {
	"use strict";
	var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
		sre = /(^[ ]*|[ ]*$)/g,
		dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
		hre = /^0x[0-9a-f]+$/i,
		ore = /^0/,
		i = function(s) { return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s; },
		// convert all to strings strip whitespace
		x = i(a).replace(sre, '') || '',
		y = i(b).replace(sre, '') || '',
		// chunk/tokenize
		xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
		yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
		// numeric, hex or date detection
		xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),
		yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,
		oFxNcL, oFyNcL;
	// first try and sort Hex codes or Dates
	if (yD) {
		if ( xD < yD ) { return -1; }
		else if ( xD > yD ) { return 1; }
	}
	// natural sorting through split numeric strings and default strings
	for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
		// find floats not starting with '0', string or 0 if not defined (Clint Priest)
		oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
		oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
		// handle numeric vs string comparison - number < string - (Kyle Adams)
		if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
		// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
		else if (typeof oFxNcL !== typeof oFyNcL) {
			oFxNcL += '';
			oFyNcL += '';
		}
		if (oFxNcL < oFyNcL) { return -1; }
		if (oFxNcL > oFyNcL) { return 1; }
	}
	return 0;
};


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var trim = __webpack_require__(/*! trim */ "./node_modules/trim/index.js")
  , forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js")
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}

/***/ }),

/***/ "./node_modules/trim/index.js":
/*!************************************!*\
  !*** ./node_modules/trim/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {


exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/wolfy87-eventemitter/EventEmitter.js":
/*!***********************************************************!*\
  !*** ./node_modules/wolfy87-eventemitter/EventEmitter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * EventEmitter v5.2.4 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 * @preserve
 */

;(function (exports) {
    'use strict';

    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
    function EventEmitter() {}

    // Shortcuts to improve speed and size
    var proto = EventEmitter.prototype;
    var originalGlobalValue = exports.EventEmitter;

    /**
     * Finds the index of the listener for the event in its storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }

    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;

        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (evt instanceof RegExp) {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        }
        else {
            response = events[evt] || (events[evt] = []);
        }

        return response;
    };

    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;

        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }

        return flatListeners;
    };

    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;

        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }

        return response || listeners;
    };

    function isValidListener (listener) {
        if (typeof listener === 'function' || listener instanceof RegExp) {
            return true
        } else if (listener && typeof listener === 'object') {
            return isValidListener(listener.listener)
        } else {
            return false
        }
    }

    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListener = function addListener(evt, listener) {
        if (!isValidListener(listener)) {
            throw new TypeError('listener must be a function');
        }

        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }

        return this;
    };

    /**
     * Alias of addListener
     */
    proto.on = alias('addListener');

    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after its first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };

    /**
     * Alias of addOnceListener.
     */
    proto.once = alias('addOnceListener');

    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };

    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };

    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);

                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }

        return this;
    };

    /**
     * Alias of removeListener
     */
    proto.off = alias('removeListener');

    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };

    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };

    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;

        // If evt is an object then pass each of its properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    // Pass the single listener straight through to the singular method
                    if (typeof value === 'function') {
                        single.call(this, i, value);
                    }
                    else {
                        // Otherwise pass back to the multiple function
                        multiple.call(this, i, value);
                    }
                }
            }
        }
        else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }

        return this;
    };

    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;

        // Remove different things depending on the state of evt
        if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
        }
        else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        }
        else {
            // Remove all listeners in all events
            delete this._events;
        }

        return this;
    };

    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
    proto.removeAllListeners = alias('removeEvent');

    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emitEvent = function emitEvent(evt, args) {
        var listenersMap = this.getListenersAsObject(evt);
        var listeners;
        var listener;
        var i;
        var key;
        var response;

        for (key in listenersMap) {
            if (listenersMap.hasOwnProperty(key)) {
                listeners = listenersMap[key].slice(0);

                for (i = 0; i < listeners.length; i++) {
                    // If the listener returns true then it shall be removed from the event
                    // The function is executed either with a basic call or an apply if there is an args array
                    listener = listeners[i];

                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }

                    response = listener.listener.apply(this, args || []);

                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }

        return this;
    };

    /**
     * Alias of emitEvent
     */
    proto.trigger = alias('emitEvent');

    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };

    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };

    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
        }
        else {
            return true;
        }
    };

    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };

    /**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */
    EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };

    // Expose the class either via AMD, CommonJS or the global object
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return EventEmitter;
        }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else {}
}(this || {}));


/***/ }),

/***/ "./node_modules/x2js/x2js.js":
/*!***********************************!*\
  !*** ./node_modules/x2js/x2js.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	Copyright 2015 Axinom
	Copyright 2011-2013 Abdulla Abdurakhmanov
	Original sources are available at https://code.google.com/p/x2js/

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

/*
	Supported export methods:
	* AMD
	* <script> (window.X2JS)
	* Node.js

	Limitations:
	* Attribute namespace prefixes are not parsed as such.
	* Overall the serialization/deserializaton code is "best effort" and not foolproof.
*/

// Module definition pattern used is returnExports from https://github.com/umdjs/umd
(function (root, factory) {
	"use strict";

	/* global define */
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(this, function (CustomDOMParser) {
	"use strict";

	// We return a constructor that can be used to make X2JS instances.
	return function X2JS(config) {
		var VERSION = "3.1.1";

		config = config || {};

		function initConfigDefaults() {
			// If set to "property" then <element>_asArray will be created
			// to allow you to access any element as an array (even if there is only one of it).
			config.arrayAccessForm = config.arrayAccessForm || "none";

			// If "text" then <empty></empty> will be transformed to "".
			// If "object" then <empty></empty> will be transformed to {}.
			config.emptyNodeForm = config.emptyNodeForm || "text";

			// Function that will be called for each elements, if the function returns true, the element will be skipped
			// function(name, value) { return true; };
			config.jsAttributeFilter = config.jsAttributeFilter;

			// Function that will be called for each elements, the element value will be replaced by the returned value
			// function(name, value) { return parseFloat(value); };
			config.jsAttributeConverter = config.jsAttributeConverter;

			// Allows attribute values to be converted on the fly during parsing to objects.
			// 	"test": function(name, value) { return true; }
			//	"convert": function(name, value) { return parseFloat(value); };
			// convert() will be called for every attribute where test() returns true
			// and the return value from convert() will replace the original value of the attribute.
			config.attributeConverters = config.attributeConverters || [];

			// Any elements that match the paths here will have their text parsed
			// as an XML datetime value (2011-11-12T13:00:00-07:00 style).
			// The path can be a plain string (parent.child1.child2),
			// a regex (/.*\.child2/) or function(elementPath).
			config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];

			// Any elements that match the paths listed here will be stored in JavaScript objects
			// as arrays even if there is only one of them. The path can be a plain string
			// (parent.child1.child2), a regex (/.*\.child2/) or function(elementName, elementPath).
			config.arrayAccessFormPaths = config.arrayAccessFormPaths || [];

			// If true, a toString function is generated to print nodes containing text or cdata.
			// Useful if you want to accept both plain text and CData as equivalent inputs.
			if (config.enableToStringFunc === undefined) {
				config.enableToStringFunc = true;
			}

			// If true, empty text tags are ignored for elements with child nodes.
			if (config.skipEmptyTextNodesForObj === undefined) {
				config.skipEmptyTextNodesForObj = true;
			}

			// If true, whitespace is trimmed from text nodes.
			if (config.stripWhitespaces === undefined) {
				config.stripWhitespaces = true;
			}

			// If true, double quotes are used in generated XML.
			if (config.useDoubleQuotes === undefined) {
				config.useDoubleQuotes = true;
			}

			// If true, the root element of the XML document is ignored when converting to objects.
			// The result will directly have the root element's children as its own properties.
			if (config.ignoreRoot === undefined) {
				config.ignoreRoot = false;
			}

			// Whether XML characters in text are escaped when reading/writing XML.
			if (config.escapeMode === undefined) {
				config.escapeMode = true;
			}

			// Prefix to use for properties that are created to represent XML attributes.
			if (config.attributePrefix === undefined) {
				config.attributePrefix = "_";
			}

			// If true, empty elements will created as self closing elements (<element />)
			// If false, empty elements will be created with start and end tags (<element></element>)
			if (config.selfClosingElements === undefined) {
				config.selfClosingElements = true;
			}

			// If this property defined as false and an XML element has CData node ONLY, it will be converted to text without additional property "__cdata"
			if (config.keepCData === undefined) {
				config.keepCData = false;
			}

			// If true, will output dates in UTC
			if (config.jsDateUTC === undefined) {
				config.jsDateUTC = false;
			}
		}

		function initRequiredPolyfills() {
			function pad(number) {
				var r = String(number);
				if (r.length === 1) {
					r = '0' + r;
				}
				return r;
			}
			// Hello IE8-
			if (typeof String.prototype.trim !== 'function') {
				String.prototype.trim = function trim() {
					return this.replace(/^\s+|^\n+|(\s|\n)+$/g, '');
				};
			}
			if (typeof Date.prototype.toISOString !== 'function') {
				// Implementation from http://stackoverflow.com/questions/2573521/how-do-i-output-an-iso-8601-formatted-string-in-javascript
				Date.prototype.toISOString = function toISOString() {
					var MS_IN_S = 1000;

					return this.getUTCFullYear()
						+ '-' + pad(this.getUTCMonth() + 1)
						+ '-' + pad(this.getUTCDate())
						+ 'T' + pad(this.getUTCHours())
						+ ':' + pad(this.getUTCMinutes())
						+ ':' + pad(this.getUTCSeconds())
						+ '.' + String((this.getUTCMilliseconds() / MS_IN_S).toFixed(3)).slice(2, 5)
						+ 'Z';
				};
			}
		}

		initConfigDefaults();
		initRequiredPolyfills();

		var DOMNodeTypes = {
			"ELEMENT_NODE": 1,
			"TEXT_NODE": 3,
			"CDATA_SECTION_NODE": 4,
			"COMMENT_NODE": 8,
			"DOCUMENT_NODE": 9
		};

		function getDomNodeLocalName(domNode) {
			var localName = domNode.localName;
			if (localName == null) {
				// Yeah, this is IE!!
				localName = domNode.baseName;
			}
			if (localName == null || localName === "") {
				// ==="" is IE too
				localName = domNode.nodeName;
			}
			return localName;
		}

		function getDomNodeNamespacePrefix(node) {
			return node.prefix;
		}

		function escapeXmlChars(str) {
			if (typeof str === "string")
				return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
			else
				return str;
		}

		function unescapeXmlChars(str) {
			return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&amp;/g, '&');
		}

		function ensureProperArrayAccessForm(element, childName, elementPath) {
			switch (config.arrayAccessForm) {
				case "property":
					if (!(element[childName] instanceof Array))
						element[childName + "_asArray"] = [element[childName]];
					else
						element[childName + "_asArray"] = element[childName];
					break;
			}

			if (!(element[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
				var match = false;

				for (var i = 0; i < config.arrayAccessFormPaths.length; i++) {
					var arrayPath = config.arrayAccessFormPaths[i];
					if (typeof arrayPath === "string") {
						if (arrayPath === elementPath) {
							match = true;
							break;
						}
					} else if (arrayPath instanceof RegExp) {
						if (arrayPath.test(elementPath)) {
							match = true;
							break;
						}
					} else if (typeof arrayPath === "function") {
						if (arrayPath(childName, elementPath)) {
							match = true;
							break;
						}
					}
				}

				if (match)
					element[childName] = [element[childName]];
			}
		}

		function xmlDateTimeToDate(prop) {
			// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
			// Improved to support full spec and optional parts
			var MINUTES_PER_HOUR = 60;

			var bits = prop.split(/[-T:+Z]/g);

			var d = new Date(bits[0], bits[1] - 1, bits[2]);
			var secondBits = bits[5].split("\.");
			d.setHours(bits[3], bits[4], secondBits[0]);
			if (secondBits.length > 1)
				d.setMilliseconds(secondBits[1]);

			// Get supplied time zone offset in minutes
			if (bits[6] && bits[7]) {
				var offsetMinutes = bits[6] * MINUTES_PER_HOUR + Number(bits[7]);
				var sign = /\d\d-\d\d:\d\d$/.test(prop) ? '-' : '+';

				// Apply the sign
				offsetMinutes = 0 + (sign === '-' ? -1 * offsetMinutes : offsetMinutes);

				// Apply offset and local timezone
				d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset());
			} else if (prop.indexOf("Z", prop.length - 1) !== -1) {
				d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));
			}

			// d is now a local time equivalent to the supplied time
			return d;
		}

		function convertToDateIfRequired(value, childName, fullPath) {
			if (config.datetimeAccessFormPaths.length > 0) {
				var pathWithoutTextNode = fullPath.split("\.#")[0];

				for (var i = 0; i < config.datetimeAccessFormPaths.length; i++) {
					var candidatePath = config.datetimeAccessFormPaths[i];
					if (typeof candidatePath === "string") {
						if (candidatePath === pathWithoutTextNode)
							return xmlDateTimeToDate(value);
					} else if (candidatePath instanceof RegExp) {
						if (candidatePath.test(pathWithoutTextNode))
							return xmlDateTimeToDate(value);
					} else if (typeof candidatePath === "function") {
						if (candidatePath(pathWithoutTextNode))
							return xmlDateTimeToDate(value);
					}
				}
			}

			return value;
		}

		function deserializeRootElementChildren(rootElement) {
			var result = {};
			var children = rootElement.childNodes;

			// Alternative for firstElementChild which is not supported in some environments
			for (var i = 0; i < children.length; i++) {
				var child = children.item(i);
				if (child.nodeType === DOMNodeTypes.ELEMENT_NODE) {
					var childName = getDomNodeLocalName(child);

					if (config.ignoreRoot)
						result = deserializeDomChildren(child, childName);
					else
						result[childName] = deserializeDomChildren(child, childName);
				}
			}

			return result;
		}

		function deserializeElementChildren(element, elementPath) {
			var result = {};
			result.__cnt = 0;

			var nodeChildren = element.childNodes;

			// Child nodes.
			for (var iChild = 0; iChild < nodeChildren.length; iChild++) {
				var child = nodeChildren.item(iChild);
				var childName = getDomNodeLocalName(child);

				if (child.nodeType === DOMNodeTypes.COMMENT_NODE)
					continue;

				result.__cnt++;

				// We deliberately do not accept everything falsey here because
				// elements that resolve to empty string should still be preserved.
				if (result[childName] == null) {
					result[childName] = deserializeDomChildren(child, elementPath + "." + childName);
					ensureProperArrayAccessForm(result, childName, elementPath + "." + childName);
				} else {
					if (!(result[childName] instanceof Array)) {
						result[childName] = [result[childName]];
						ensureProperArrayAccessForm(result, childName, elementPath + "." + childName);
					}

					result[childName][result[childName].length] = deserializeDomChildren(child, elementPath + "." + childName);
				}
			}

			// Attributes
			for (var iAttribute = 0; iAttribute < element.attributes.length; iAttribute++) {
				var attribute = element.attributes.item(iAttribute);
				result.__cnt++;

				var adjustedValue = attribute.value;
				for (var iConverter = 0; iConverter < config.attributeConverters.length; iConverter++) {
					var converter = config.attributeConverters[iConverter];
					if (converter.test.call(null, attribute.name, attribute.value))
						adjustedValue = converter.convert.call(null, attribute.name, attribute.value);
				}

				result[config.attributePrefix + attribute.name] = adjustedValue;
			}

			// Node namespace prefix
			var namespacePrefix = getDomNodeNamespacePrefix(element);
			if (namespacePrefix) {
				result.__cnt++;
				result.__prefix = namespacePrefix;
			}

			if (result["#text"]) {
				result.__text = result["#text"];

				if (result.__text instanceof Array) {
					result.__text = result.__text.join("\n");
				}

				if (config.escapeMode)
					result.__text = unescapeXmlChars(result.__text);

				if (config.stripWhitespaces)
					result.__text = result.__text.trim();

				delete result["#text"];

				if (config.arrayAccessForm === "property")
					delete result["#text_asArray"];

				result.__text = convertToDateIfRequired(result.__text, "#text", elementPath + ".#text");
			}

			if (result.hasOwnProperty('#cdata-section')) {
				result.__cdata = result["#cdata-section"];
				delete result["#cdata-section"];

				if (config.arrayAccessForm === "property")
					delete result["#cdata-section_asArray"];
			}

			if (result.__cnt === 1 && result.__text) {
				result = result.__text;
			} else if (result.__cnt === 0 && config.emptyNodeForm === "text") {
				result = '';
			} else if (result.__cnt > 1 && result.__text !== undefined && config.skipEmptyTextNodesForObj) {
				if (config.stripWhitespaces && result.__text === "" || result.__text.trim() === "") {
					delete result.__text;
				}
			}
			delete result.__cnt;

			if (!config.keepCData && (!result.hasOwnProperty('__text') && result.hasOwnProperty('__cdata'))) {
				return (result.__cdata ? result.__cdata : '');
			}

			if (config.enableToStringFunc && (result.__text || result.__cdata)) {
				result.toString = function toString() {
					return (this.__text ? this.__text : '') + (this.__cdata ? this.__cdata : '');
				};
			}

			return result;
		}

		function deserializeDomChildren(node, parentPath) {
			if (node.nodeType === DOMNodeTypes.DOCUMENT_NODE) {
				return deserializeRootElementChildren(node);
			} else if (node.nodeType === DOMNodeTypes.ELEMENT_NODE) {
				return deserializeElementChildren(node, parentPath);
			} else if (node.nodeType === DOMNodeTypes.TEXT_NODE || node.nodeType === DOMNodeTypes.CDATA_SECTION_NODE) {
				return node.nodeValue;
			} else {
				return null;
			}
		}

		function serializeStartTag(jsObject, elementName, attributeNames, selfClosing) {
			var resultStr = "<" + ((jsObject && jsObject.__prefix) ? (jsObject.__prefix + ":") : "") + elementName;

			if (attributeNames) {
				for (var i = 0; i < attributeNames.length; i++) {
					var attributeName = attributeNames[i];
					var attributeValue = jsObject[attributeName];

					if (config.escapeMode)
						attributeValue = escapeXmlChars(attributeValue);

					resultStr += " " + attributeName.substr(config.attributePrefix.length) + "=";

					if (config.useDoubleQuotes)
						resultStr += '"' + attributeValue + '"';
					else
						resultStr += "'" + attributeValue + "'";
				}
			}

			if (!selfClosing)
				resultStr += ">";
			else
				resultStr += " />";

			return resultStr;
		}

		function serializeEndTag(jsObject, elementName) {
			return "</" + ((jsObject && jsObject.__prefix) ? (jsObject.__prefix + ":") : "") + elementName + ">";
		}

		function endsWith(str, suffix) {
			return str.indexOf(suffix, str.length - suffix.length) !== -1;
		}

		function isSpecialProperty(jsonObj, propertyName) {
			if ((config.arrayAccessForm === "property" && endsWith(propertyName.toString(), ("_asArray")))
				|| propertyName.toString().indexOf(config.attributePrefix) === 0
				|| propertyName.toString().indexOf("__") === 0
				|| (jsonObj[propertyName] instanceof Function))
				return true;
			else
				return false;
		}

		function getDataElementCount(jsObject) {
			var count = 0;

			if (jsObject instanceof Object) {
				for (var propertyName in jsObject) {
					if (isSpecialProperty(jsObject, propertyName))
						continue;

					count++;
				}
			}

			return count;
		}

		function getDataAttributeNames(jsObject) {
			var names = [];

			if (jsObject instanceof Object) {
				for (var attributeName in jsObject) {
					if (attributeName.toString().indexOf("__") === -1
						&& attributeName.toString().indexOf(config.attributePrefix) === 0) {
						names.push(attributeName);
					}
				}
			}

			return names;
		}

		function serializeComplexTextNodeContents(textNode) {
			var result = "";

			if (textNode.__cdata) {
				result += "<![CDATA[" + textNode.__cdata + "]]>";
			}

			if (textNode.__text) {
				if (config.escapeMode)
					result += escapeXmlChars(textNode.__text);
				else
					result += textNode.__text;
			}

			return result;
		}

		function serializeTextNodeContents(textNode) {
			var result = "";

			if (textNode instanceof Object) {
				result += serializeComplexTextNodeContents(textNode);
			} else if (textNode !== null) {
				if (config.escapeMode)
					result += escapeXmlChars(textNode);
				else
					result += textNode;
			}

			return result;
		}

		function serializeArray(elementArray, elementName, attributes) {
			var result = "";

			if (elementArray.length === 0) {
				result += serializeStartTag(elementArray, elementName, attributes, true);
			} else {
				for (var i = 0; i < elementArray.length; i++) {
					result += serializeJavaScriptObject(elementArray[i], elementName, getDataAttributeNames(elementArray[i]));
				}
			}

			return result;
		}

		function serializeJavaScriptObject(element, elementName, attributes) {
			var result = "";

			// Filter out elements
			if (config.jsAttributeFilter && config.jsAttributeFilter.call(null, elementName, element)) {
				return result;
			}
			// Convert element
			if (config.jsAttributeConverter) {
				element = config.jsAttributeConverter.call(null, elementName, element);
			}
			if ((element === undefined || element === null || element === '') && config.selfClosingElements) {
				result += serializeStartTag(element, elementName, attributes, true);
			} else if (typeof element === 'object') {
				if (Object.prototype.toString.call(element) === '[object Array]') {
					result += serializeArray(element, elementName, attributes);
				} else if (element instanceof Date) {
					result += serializeStartTag(element, elementName, attributes, false);
					// Serialize date
					result += config.jsDateUTC ? element.toUTCString() : element.toISOString();
					result += serializeEndTag(element, elementName);
				} else {
					var childElementCount = getDataElementCount(element);
					if (childElementCount > 0 || element.__text || element.__cdata) {
						result += serializeStartTag(element, elementName, attributes, false);
						result += serializeJavaScriptObjectChildren(element);
						result += serializeEndTag(element, elementName);
					} else if (config.selfClosingElements) {
						result += serializeStartTag(element, elementName, attributes, true);
					} else {
						result += serializeStartTag(element, elementName, attributes, false);
						result += serializeEndTag(element, elementName);
					}
				}
			} else {
				result += serializeStartTag(element, elementName, attributes, false);
				result += serializeTextNodeContents(element);
				result += serializeEndTag(element, elementName);
			}

			return result;
		}

		function serializeJavaScriptObjectChildren(jsObject) {
			var result = "";

			var elementCount = getDataElementCount(jsObject);

			if (elementCount > 0) {
				for (var elementName in jsObject) {
					if (isSpecialProperty(jsObject, elementName))
						continue;

					var element = jsObject[elementName];
					var attributes = getDataAttributeNames(element);

					result += serializeJavaScriptObject(element, elementName, attributes);
				}
			}

			result += serializeTextNodeContents(jsObject);

			return result;
		}

		function parseXml(xml) {
			if (xml === undefined) {
				return null;
			}

			if (typeof xml !== "string") {
				return null;
			}

			var parser = null;
			var domNode = null;

			if (CustomDOMParser) {
				// This branch is used for node.js, with the xmldom parser.
				parser = new CustomDOMParser();

				domNode = parser.parseFromString(xml, "text/xml");
			} else if (window && window.DOMParser) {
				parser = new window.DOMParser();
				var parsererrorNS = null;

				var isIEParser = window.ActiveXObject || "ActiveXObject" in window;

				// IE9+ now is here
				if (!isIEParser) {
					try {
						parsererrorNS = parser.parseFromString("INVALID", "text/xml").childNodes[0].namespaceURI;
					} catch (err) {
						parsererrorNS = null;
					}
				}

				try {
					domNode = parser.parseFromString(xml, "text/xml");
					if (parsererrorNS !== null && domNode.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
						domNode = null;
					}
				} catch (err) {
					domNode = null;
				}
			} else {
				// IE :(
				if (xml.indexOf("<?") === 0) {
					xml = xml.substr(xml.indexOf("?>") + 2);
				}

				/* global ActiveXObject */
				domNode = new ActiveXObject("Microsoft.XMLDOM");
				domNode.async = "false";
				domNode.loadXML(xml);
			}

			return domNode;
		}

		this.asArray = function asArray(prop) {
			if (prop === undefined || prop === null) {
				return [];
			} else if (prop instanceof Array) {
				return prop;
			} else {
				return [prop];
			}
		};

		this.toXmlDateTime = function toXmlDateTime(dt) {
			if (dt instanceof Date) {
				return dt.toISOString();
			} else if (typeof (dt) === 'number') {
				return new Date(dt).toISOString();
			} else {
				return null;
			}
		};

		this.asDateTime = function asDateTime(prop) {
			if (typeof (prop) === "string") {
				return xmlDateTimeToDate(prop);
			} else {
				return prop;
			}
		};

		/*
			Internally the logic works in a cycle:
			DOM->JS - implemented by custom logic (deserialization).
			JS->XML - implemented by custom logic (serialization).
			XML->DOM - implemented by browser.
		*/

		// Transformns an XML string into DOM-tree
		this.xml2dom = function xml2dom(xml) {
			return parseXml(xml);
		};

		// Transforms a DOM tree to JavaScript objects.
		this.dom2js = function dom2js(domNode) {
			return deserializeDomChildren(domNode, null);
		};

		// Transforms JavaScript objects to a DOM tree.
		this.js2dom = function js2dom(jsObject) {
			var xml = this.js2xml(jsObject);
			return parseXml(xml);
		};

		// Transformns an XML string into JavaScript objects.
		this.xml2js = function xml2js(xml) {
			var domNode = parseXml(xml);
			if (domNode != null)
				return this.dom2js(domNode);
			else
				return null;
		};

		// Transforms JavaScript objects into an XML string.
		this.js2xml = function js2xml(jsObject) {
			return serializeJavaScriptObjectChildren(jsObject);
		};

		this.getVersion = function getVersion() {
			return VERSION;
		};
	};
});


/***/ }),

/***/ "./node_modules/xhr/index.js":
/*!***********************************!*\
  !*** ./node_modules/xhr/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var window = __webpack_require__(/*! global/window */ "./node_modules/global/window.js")
var isFunction = __webpack_require__(/*! is-function */ "./node_modules/is-function/index.js")
var parseHeaders = __webpack_require__(/*! parse-headers */ "./node_modules/parse-headers/parse-headers.js")
var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
    try {
        if (xhr.responseType === "document") {
            return xhr.responseXML
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
            return xhr.responseXML
        }
    } catch (e) {}

    return null
}

function noop() {}


/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./src/entry/mixin.js":
/*!****************************!*\
  !*** ./src/entry/mixin.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// CLI报错：Error: 找不到模块: ringo/engine
var platform = __webpack_require__(/*! platform */ "./src/polyfill/weixin-app/platform.js");
var xhr = __webpack_require__(/*! xhr */ "./node_modules/xhr/index.js");
var io = __webpack_require__(/*! socketio */ "./external/socketio/socket.io.js");
var naturalSort = __webpack_require__(/*! javascript-natural-sort */ "./node_modules/javascript-natural-sort/naturalSort.js");
var deepAccess = __webpack_require__(/*! deep-access */ "./node_modules/deep-access/index.js");
// WAService.js:15 appLaunch with an already exist webviewId 46
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var support = __webpack_require__(/*! utiljs/support */ "./src/util/support.js");
var blob = __webpack_require__(/*! utiljs/blob */ "./src/util/blob.js");
var ajax = __webpack_require__(/*! utiljs/ajax */ "./src/util/ajax/index.js");
// CLI报错：Error: 找不到模块: vertx
// const Promise = require('es6-promise').Promise;
var LoggerPlugin = __webpack_require__(/*! utiljs/loggerPlugin */ "./src/util/loggerPlugin.js");
var usePlugin = __webpack_require__(/*! utiljs/usePlugin */ "./src/util/usePlugin.js");

module.exports = function (obj) {
  util.merge(obj, {
    platform: platform,
    xhr: xhr,
    io: io,
    naturalSort: naturalSort,
    deepAccess: deepAccess,
    util: util,
    support: support,
    blob: blob,
    ajax: ajax,
    LoggerPlugin: LoggerPlugin,
    usePlugin: usePlugin
  });
};

/***/ }),

/***/ "./src/entry/nim.js":
/*!**************************!*\
  !*** ./src/entry/nim.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! polyfill */ "./src/polyfill/weixin-app.js");

var NIM = __webpack_require__(/*! im/api/nim */ "./src/im/api/nim/index.js");

var mixin = __webpack_require__(/*! ./mixin */ "./src/entry/mixin.js");
mixin(NIM);

module.exports = NIM;

/**
 * SDK 使用 {@link https://github.com/bestiejs/platform.js/|platform.js} 来检测浏览器平台, 通过 `NIM.platform` 来获取此库的引用
 * @name platform
 * @memberOf NIM
 * @type {Object}
 */

/**
 * SDK 使用 {@link https://github.com/Raynos/xhr|xhr} 来发送 Ajax 请求, 通过 `NIM.xhr` 来获取此库的引用
 * @memberOf NIM
 * @name xhr
 * @type {Function}
 */

/**
 * SDK 使用 {@link https://github.com/socketio/socket.io-client/tree/0.9|socket.io-client 0.9} 来建立 Socket 连接, 通过 `NIM.io` 来获取此库的引用
 * @name io
 * @memberOf NIM
 * @type {Object}
 */

/**
 * SDK 使用 {@link https://github.com/Bill4Time/javascript-natural-sort|natural sort} 来对数组进行排序, 通过 `NIM.naturalSort` 来获取此库的引用
 * @name naturalSort
 * @memberOf NIM
 * @type {Function}
 */

/**
 * SDK 使用 {@link https://github.com/juliangruber/deep-access|deep access} 来获取对象的属性值, 通过 `NIM.deepAccess` 来获取此库的引用
 * @name deepAccess
 * @type {Function}
 */

/***/ }),

/***/ "./src/im/api/base/avSignal.js":
/*!*************************************!*\
  !*** ./src/im/api/base/avSignal.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  通用独立音视频信令
*/
var ApiBaseFn = __webpack_require__(/*! ./index */ "./src/im/api/base/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var protocolConfigBase = __webpack_require__(/*! ../../protocol/map/configBase */ "./src/im/protocol/map/configBase.js");
var avSignalUtil = __webpack_require__(/*! ../../model/avSignal */ "./src/im/model/avSignal.js");

/**
 *  请使用 {@link NIM.getInstance} 来初始化信令SDK环境.
 * @class
 * @name Signaling
 * @see {@link NIM.getInstance|NIM初始化}
 */

/**
 *  独立呼叫信令-创建频道
 *
 * @memberof Signaling#
 * @method signalingCreate
 * @param {Object} options 参数对象
 * @param {Number} options.type 通话类型,1:音频;2:视频;3:其他，必须
 * @param {String} options.channelName 频道名，可缺省
 * @param {String} options.ext 频道的自定义扩展信息，可缺省
 *
 * @return {Promise}
 * @example
 * nim.signalingCreate({
 *   type: 1,
 *   channelName: '11'
 * });
 */
ApiBaseFn.signalingCreate = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var type = options.type,
      channelName = options.channelName,
      ext = options.ext;

  util.verifyOptions(options, 'type', 'api::signalling');
  return this.sendCmdUsePromise('signalingCreate', {
    avSignalTag: {
      type: type,
      channelName: channelName,
      ext: ext
    }
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 独立呼叫信令-延迟频道有效期（同时延迟操作者和房间）
 * @method signalingDelay
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id，必须
 * @returns {Promise}
 * @example
 * nim.signalingDelay({
 *   channelId: 'qq',
 * });
 */
ApiBaseFn.signalingDelay = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  util.verifyOptions(options, 'channelId', 'api::signalling');
  return this.sendCmdUsePromise('signalingDelay', {
    avSignalTag: options
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 独立呼叫信令-关闭频道.
 * 该接口可以由创建者和频道内所有成员调用，无权限限制。调用该接口成功后，其他所有频道内的成员都回收到频道结束的通知，被动离开频道。此时其他成员不需要调用离开接口，也不会收到别人的离开通知。
 * @method signalingClose
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id，必须
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认false
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @returns {Promise}
 * @example
 * nim.signalingClose({
 *   channelId: 'qq',
 *   offlineEnabled: true
 * });
 */
ApiBaseFn.signalingClose = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var offlineEnabled = options.offlineEnabled;

  util.verifyOptions(options, 'channelId', 'api::signalling');
  return this.sendCmdUsePromise('signalingClose', {
    avSignalTag: util.merge(options, {
      isSave: offlineEnabled === true ? 1 : 0
    })
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    avSignalTag.offlineEnabled = avSignalTag.isSave === 1 ? true : false;
    delete avSignalTag.isSave;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 独立呼叫信令-加入频道
 * @method signalingJoin
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id,必须
 * @param {Number} options.uid 自己在频道中对应的uid，大于零有效，无效时服务器会分配随机唯一的uid
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认false
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @returns {Promise}
 */
ApiBaseFn.signalingJoin = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var offlineEnabled = options.offlineEnabled;

  util.verifyOptions(options, 'channelId', 'api::signalling');
  return this.sendCmdUsePromise('signalingJoin', {
    avSignalTag: util.merge(options, {
      isSave: offlineEnabled === true ? 1 : 0
    })
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    var members = avSignalTag.members;
    if (typeof avSignalTag.members === 'string') {
      members = JSON.parse(avSignalTag.members).map(function (member) {
        return avSignalUtil.parseAvSignalMember(member);
      });
    }
    // 加入房间回包没有isSave
    avSignalTag.members = members;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 独立呼叫信令-离开频道
 * @method signalingLeave
 * @memberof Signaling#
 * @param {Object} options 参数对象，必填
 * @param {String} options.channelId 对应的频道id
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认false
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @returns {Promise}
 */
ApiBaseFn.signalingLeave = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var offlineEnabled = options.offlineEnabled;

  util.verifyOptions(options, 'channelId', 'api::signalling');
  return this.sendCmdUsePromise('signalingLeave', {
    avSignalTag: util.merge(options, {
      isSave: offlineEnabled === true ? 1 : 0
    })
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    avSignalTag.offlineEnabled = avSignalTag.isSave === 1 ? true : false;
    delete avSignalTag.isSave;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 独立呼叫信令-根据channelName查询房间信息，包括channelId, members
 *
 * @memberof Signaling#
 * @method signalingGetChannelInfo
 * @param {Object} options 参数对象
 * @param {String} options.channelName 频道名，可缺省
 * @param {String} options.ext 频道的自定义扩展信息，可缺省
 *
 * @return {Promise}
 * @example
 * nim.signalingGetChannelInfo({
 *   channelName: '11'
 * }).then(function(channelInfo){
 *   console.log('channelInfo:',channelInfo)
 *   console.log('房间id',channelInfo.channelId)
 *   let members = channelInfo.members;
 *   console.log('房间人数为':memner.length)
 *   console.log('房间内的用户列表':memner)
 * });
 */
ApiBaseFn.signalingGetChannelInfo = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var channelName = options.channelName;

  util.verifyOptions(options, 'channelName', 'api::signalling');
  return this.sendCmdUsePromise('signalingGetChannelInfo', {
    avSignalTag: {
      channelName: channelName
    }
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    var members = avSignalTag.members;
    if (typeof avSignalTag.members === 'string') {
      members = JSON.parse(avSignalTag.members).map(function (member) {
        return avSignalUtil.parseAvSignalMember(member);
      });
    }
    avSignalTag.members = members;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 邀请别人加入频道
 * @method signalingInvite
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id，必须
 * @param {String} options.account 对方accid，必须
 * @param {String} options.requestId 必须，邀请者邀请的请求id，需要邀请者填写，之后取消邀请、拒绝、接受需要复用该requestId
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认false
 * @param {String} options.attachExt 邀请者附加的自定义信息，透传给被邀请者，可缺省
 * @param {Object} options.pushInfo 推送信息
 * @param {Boolean} pushInfo.needPush 是否需要推送，默认false
 * @param {Boolean} pushInfo.needBadge 是否计入未读计数,默认true
 * @param {String} pushInfo.pushTitle 推送标题
 * @param {String} pushInfo.pushContent 推送内容
 * @param {String} pushInfo.pushPayload 推送自定义字段,必须JSON
 * @returns {Promise}
 */
ApiBaseFn.signalingInvite = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var account = options.account,
      offlineEnabled = options.offlineEnabled,
      _options$pushInfo = options.pushInfo,
      pushInfo = _options$pushInfo === undefined ? {} : _options$pushInfo;

  util.verifyOptions(options, 'channelId requestId account', 'api::signalling');
  if ((0, _typeof3.default)(pushInfo.pushPayload) === 'object') {
    pushInfo.pushPayload = JSON.stringify(pushInfo.pushPayload);
  }
  var signalOptions = util.merge(options, pushInfo, {
    to: account,
    isSave: offlineEnabled === true ? 1 : 0,
    needPush: pushInfo.needPush === true ? 1 : 0,
    needBadge: pushInfo.needBadge === false ? 0 : 1
  });
  return this.sendCmdUsePromise('signalingInvite', {
    avSignalTag: signalOptions
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    avSignalTag.offlineEnabled = avSignalTag.isSave === 1 ? true : false;
    avSignalTag.needBadge = avSignalTag.needBadge === 1 ? true : false;
    avSignalTag.needPush = avSignalTag.needPush === 1 ? true : false;
    delete avSignalTag.isSave;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 取消邀请别人加入频道
 * @method signalingCancel
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id，必填
 * @param {String} options.account 对方accid，必填
 * @param {String} options.requestId 邀请者邀请的请求id，用于取消对应的请求消息，必填
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认false
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @returns {Promise}
 */
ApiBaseFn.signalingCancel = function (options) {
  var account = options.account,
      offlineEnabled = options.offlineEnabled;

  util.verifyOptions(options, 'channelId requestId account', 'api::signalling');
  return this.sendCmdUsePromise('signalingCancel', {
    avSignalTag: util.merge(options, {
      to: account,
      isSave: offlineEnabled === true ? 1 : 0
    })
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    avSignalTag.offlineEnabled = avSignalTag.isSave === 1 ? true : false;
    delete avSignalTag.isSave;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 如果不存在房间则创建并加入，如果存在则加入
 * @method signalingCreateAndJoin
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {Number} options.type 通话类型,1:音频;2:视频;3:其他
 * @param {String} options.channelName 频道名，可缺省
 * @param {String} options.ext 频道的自定义扩展信息，可缺省
 * @param {String} options.uid 自己在频道中对应的uid，大于零有效，无效时服务器会分配随机唯一的uid，可缺省填0
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认0
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 */
ApiBaseFn.signalingCreateAndJoin = function (options) {
  var _this = this;

  var channelName = options.channelName,
      _options$uid = options.uid,
      uid = _options$uid === undefined ? 0 : _options$uid,
      _options$offlineEnabl = options.offlineEnabled,
      offlineEnabled = _options$offlineEnabl === undefined ? true : _options$offlineEnabl,
      _options$attachExt = options.attachExt,
      attachExt = _options$attachExt === undefined ? '' : _options$attachExt;

  var channelId = '';
  return this.signalingCreate(options).catch(function (error) {
    if (error.code === 10405) {
      _this.logger.warn('api::avSignal:signalingCall room already exists:', error);
      return _this.signalingGetChannelInfo({
        channelName: channelName
      });
    }
    return Promise.reject(error);
  }).then(function (obj) {
    channelId = obj.channelId;
    var config = {
      channelId: channelId,
      offlineEnabled: offlineEnabled,
      attachExt: attachExt
    };
    if (uid) {
      util.merge(config, {
        uid: uid
      });
    }
    return _this.signalingJoin(config);
  });
};

/**
 * 用于用户新开一个频道并邀请对方加入频道
 * @method signalingCall
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {Number} options.type 通话类型,1:音频;2:视频;3:其他
 * @param {String} options.channelName 频道名，可缺省
 * @param {String} options.ext 频道的自定义扩展信息，可缺省
 * @param {String} options.uid 自己在频道中对应的uid，大于零有效，无效时服务器会分配随机唯一的uid，可缺省填0
 * @param {String} options.account 被邀请者的账号
 * @param {String} options.requestId 邀请者邀请的请求id，用于被邀请者回传request_id_作对应的回应操作
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认0
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @param {String} options.pushInfo 推送信息
 */
ApiBaseFn.signalingCall = function (options) {
  var _this2 = this;

  var account = options.account,
      offlineEnabled = options.offlineEnabled,
      requestId = options.requestId;

  util.verifyOptions(options, 'type requestId account', 'api::signalling');
  var channelId = '';
  return this.signalingCreateAndJoin(options).then(function (obj) {
    _this2.logger.log('api::avSignal:signalingCall join:', obj);
    channelId = obj.channelId || channelId;
    var config = {
      channelId: channelId,
      account: account,
      requestId: requestId,
      offlineEnabled: offlineEnabled,
      attachExt: options.attachExt || '',
      pushInfo: options.pushInfo || {}
    };
    return _this2.signalingInvite(config);
  });
};

/**
 * 拒绝别人的邀请
 * @method signalingReject
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id
 * @param {String} options.account 邀请者的账号
 * @param {String} options.requestId 邀请者邀请的请求id，用于被邀请者回传request_id_作对应的回应操作
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认false
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @returns {Promise}
 */
ApiBaseFn.signalingReject = function (options) {
  var account = options.account,
      offlineEnabled = options.offlineEnabled;

  util.verifyOptions(options, 'channelId requestId account', 'api::signalling');
  return this.sendCmdUsePromise('signalingReject', {
    avSignalTag: util.merge(options, {
      to: account,
      isSave: offlineEnabled === true ? 1 : 0
    })
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    avSignalTag.offlineEnabled = avSignalTag.isSave === 1 ? true : false;
    delete avSignalTag.isSave;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 接受别人的邀请
 * @method signalingAccept
 * @memberof Signaling#
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id
 * @param {String} options.account 邀请者的账号
 * @param {String} options.requestId 邀请者邀请的请求id，用于被邀请者回传request_id_作对应的回应操作
 * @param {Boolean} options.offlineEnabled 是否存离线通知，默认false
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @param {Boolean} options.autoJoin 是否自动加入房间，默认不打开，打开后后续参数uid、joinAttachExt有效
 * @param {String} options.uid 自己在频道中对应的uid，大于零有效，无效时服务器会分配随机唯一的uid，可缺省
 * @param {String} options.joinAttachExt 加入频道的自定义扩展信息，将在加入频道通知中带给其他频道成员，可缺省
 * @returns {Promise}
 */
ApiBaseFn.signalingAccept = function (options) {
  var _this3 = this;

  var account = options.account,
      offlineEnabled = options.offlineEnabled;

  util.verifyOptions(options, 'channelId requestId account', 'api::signalling');
  return this.sendCmdUsePromise('signalingAccept', {
    avSignalTag: util.merge(options, {
      to: account,
      isSave: offlineEnabled === true ? 1 : 0
    })
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    avSignalTag.offlineEnabled = avSignalTag.isSave === 1 ? true : false;
    delete avSignalTag.isSave;
    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  }).then(function (resp) {
    var autoJoin = options.autoJoin;

    if (autoJoin) {
      var params = {
        channelId: options.channelId,
        offlineEnabled: options.offlineEnabled,
        attachExt: options.joinAttachExt,
        uid: options.uid
      };
      return _this3.signalingJoin(params);
    } else {
      return resp;
    }
  });
};

/**
 * 用户自定义控制指令接口，该接口用于在频道中透传一些自定义指令，协助频道管理，该接口允许非频道内成员调用，但接收者必须是频道内成员或创建者。
 * @method signalingControl
 * @memberof NIM/Signaling#
 * @param {Object} options 参数对象
 * @param {String} options.channelId 对应的频道id
 * @param {String} options.account 对方accid，如果为空，则通知所有人
 * @param {String} options.attachExt 操作者附加的自定义信息，透传给其他人，可缺省
 * @returns {Promise}
 */
ApiBaseFn.signalingControl = function (options) {
  var account = options.account;

  util.verifyOptions(options, 'channelId', 'api::signalling');
  return this.sendCmdUsePromise('signalingControl', {
    avSignalTag: util.merge(options, account ? {
      to: account
    } : {})
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 同步离线时的信令消息
 * @method signalingSync
 * @memberof NIM/Signaling#
 * @param {Void}s
 * @returns {Promise}
 */
ApiBaseFn.signalingSync = function () {
  return this.sendCmdUsePromise('sync', {
    sync: {
      avSignal: 0
    }
  }).then(function (obj) {
    var avSignalTag = obj.avSignalTag;

    return Promise.resolve(avSignalTag);
  }).catch(function (error) {
    return Promise.reject(avSignalUtil.parseAvSignalError(error));
  });
};

/**
 * 标记信令消息已读
 * @method signalingMarkMsgRead
 * @memberof Signaling#
 * @param {Object} options 参数对象
 * @param {String[]} options.msgid 需要标记的已读消息id
 * @returns {Promise}
 */
ApiBaseFn.signalingMarkMsgRead = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  util.verifyOptions(options, 'msgid', 'api::signalling');
  var avSignal = protocolConfigBase.idMap.avSignal;

  var ids = void 0;
  if (typeof options.msgid === 'string') {
    ids = [options.msgid];
  } else {
    ids = options.msgid;
  }
  return this.sendCmd('batchMarkRead', {
    sid: avSignal.id,
    cid: avSignal.signalingNotify,
    ids: ids
  });
};

/***/ }),

/***/ "./src/im/api/base/connect.js":
/*!************************************!*\
  !*** ./src/im/api/base/connect.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ApiBaseFn = __webpack_require__(/*! ./index */ "./src/im/api/base/index.js").fn;

ApiBaseFn.isConnected = function () {
  if (this.protocol) {
    return this.protocol.isConnected();
  }
  return false;
};

ApiBaseFn.connect = function () {
  this.protocol.appLogin = 0;
  this.protocol.connect(true);
};

ApiBaseFn.disconnect = function (options) {
  options = options || {};
  this.protocol.disconnect(options.done);
};

/***/ }),

/***/ "./src/im/api/base/index.js":
/*!**********************************!*\
  !*** ./src/im/api/base/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
var nim1 = NIM.getInstance({
    account: 'zyy1',
    onmsg: function(msg) {
        console.log('=======', msg)
    }
})
// true
nim1 === nim

var nim2 = new NIM({
    account: 'zyy1'
})
// true
nim2 === nim

var chatroom1 = Chatroom.getInstance({
    account: 'zyy1',
    chatroomId: 21,
    onmsgs: function(msgs) {
        console.log('========', msgs)
    }
})
// true
chatroom1 === chatroom

var chatroom2 = new Chatroom({
    account: 'zyy1',
    chatroomId: 21
})
// true
chatroom2 === chatroom
 */

var EventEmitter = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
// const Promise = require('es6-promise').Promise
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var Logger = __webpack_require__(/*! utiljs/logger */ "./src/util/logger.js");
var CONFIG = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
// const defaultReportUrl =
//   process.env.NODE_ENV === 'production'
//     ? 'https://dr.netease.im/1.gif'
//     : 'https://webtest.netease.im/1.gif'

function ApiBase() {}

var instances = {};

ApiBase.getInstance = function (options) {
  var constructor = this;
  options = _checkNosParam(options);
  util.verifyOptions(options, 'account', 'api::Base.getInstance');
  var name = constructor.genInstanceName(options);
  var instance = instances[name];
  // 如果此账号已经初始化过实例，那么直接返回该实例
  if (!instance) {
    instance = instances[name] = new constructor(options);
  } else {
    ApiBase.updateInstance(instance, options);
  }
  return instance;
};

// 更新配置并连接
ApiBase.updateInstance = function (instance, options) {
  instance.setOptions(options);
  instance.connect();
};

var ApiBaseFn = ApiBase.fn = ApiBase.prototype = Object.create(new EventEmitter());
// 校验 nos有效期参数 必须大于一天 单位秒
var _checkNosParam = function _checkNosParam(options) {
  if (options.nosSurvivalTime) {
    util.verifyParamType('nosSurvivalTime', options.nosSurvivalTime, 'number', 'api::Base.getInstance');
    util.verifyParamMin('nosSurvivalTime', options.nosSurvivalTime, 86400, 'api::Base.getInstance');
  } else {
    options.nosSurvivalTime = Infinity;
  }
  return options;
};

ApiBaseFn.updatePrivateConf = function (options) {
  if (options && (0, _typeof3.default)(options.privateConf) === 'object') {
    var privateConf = options.privateConf;
    if (typeof privateConf.lbs_web === 'string') {
      options.lbsUrl = privateConf.lbs_web;
    }
    if (typeof privateConf.link_ssl_web === 'boolean') {
      options.secure = privateConf.link_ssl_web;
    }
    if (typeof privateConf.https_enabled === 'boolean') {
      options.httpsEnabled = privateConf.https_enabled;
    }
    // 私有化通配符url
    // 拿到一个 bucket  = nim  object = pic ，那么上传得到的地址是 http(s)://nos.netease.com/nim/pic，那么无论是本地还是传给对面，都是这个域名。
    // 而只有正在在下载的时候才会做加速地址的处理，最后替换完的地址是不暴露给上层开发者知道的
    options.uploadUrl = privateConf.nos_uploader_web ? privateConf.nos_uploader_web : null;
    options.chunkUploadUrl = privateConf.nos_uploader_web ? privateConf.nos_uploader_web : null;
    options.replaceUrl = privateConf.nos_downloader ? privateConf.nos_downloader : null;
    options.downloadUrl = privateConf.nos_accelerate ? privateConf.nos_accelerate : null;
    options.downloadHost = privateConf.nos_accelerate_host ? privateConf.nos_accelerate_host : null;
    options.ntServerAddress = privateConf.nt_server || null; // web 私有化上报地址
    // 以下为私有化v2.1增加的上报地址，需要传给agent
    options.kibanaServer = privateConf.kibana_server;
    options.statisticServer = privateConf.statistic_server;
    options.reportGlobalServer = privateConf.report_global_server;
  }
  // options.httpsEnabled 是否开启https 默认false 开了强制https
  // 预留统计上报地址
  if (options.ntServerAddress === null || options.ntServerAddress === '') {
    CONFIG.ntServerAddress = null;
  } else {
    CONFIG.ntServerAddress = options.ntServerAddress || CONFIG.defaultReportUrl;
  }
  CONFIG.uploadUrl = options.uploadUrl || CONFIG.uploadUrl;
  CONFIG.chunkUploadUrl = options.chunkUploadUrl || CONFIG.chunkUploadUrl;
  CONFIG.downloadUrl = options.downloadUrl || CONFIG.downloadUrl;
  CONFIG.downloadHost = options.downloadHost || CONFIG.downloadHost;
  CONFIG.replaceUrl = options.replaceUrl || CONFIG.replaceUrl;
  CONFIG.httpsEnabled = options.httpsEnabled || CONFIG.httpsEnabled;
  return options;
};

// new 的时候最终会走到这里，在这里限制单例，逻辑跟 getInstance 一致
ApiBaseFn.init = function (options) {
  var self = this;
  util.verifyOptions(options, 'account', 'api::Base.init');
  // 私有化配置
  options = this.updatePrivateConf(options);
  // 将帐号转为字符串
  var account = self.account = options.account = options.account + '';

  // 如果此账号已经初始化过实例，那么直接返回该实例
  var constructor = options.constructor;
  var name = constructor.genInstanceName(options);
  var instance = instances[name];

  // 跳过单例, 用于 debug
  if (options._disableSingleton) {
    instance = null;
  }

  // 如果此账号已经初始化过实例，那么直接返回该实例
  if (instance) {
    ApiBase.updateInstance(instance, options);
    return instance;
  } else {
    self.name = name;
    instances[name] = self;
  }

  // 初始化 logger
  self.logger = options.logger = new Logger({
    debug: options.debug,
    logFunc: options.logFunc,
    prefix: self.subType
  });

  // 初始化 protocol
  options.api = self;
  var protocol = self.protocol = new options.Protocol(options);
  protocol.name = 'Protocol-' + name;
  protocol.account = account;
  protocol.api = self;

  // 初始化 Message
  protocol.message = self.message = new options.Message({
    account: account
  });

  self.options = util.copy(options);
  self.reset();
  return self;
};

ApiBaseFn.destroy = function (options) {
  options = options || {};
  var instanceName = this.name;
  if (!instanceName) {
    // 之前已经调用过
    return;
  }
  // rn push监听注销
  if (this.protocol && this.protocol.resetPush) {
    this.protocol.resetPush();
  }
  var self = this;
  function destroyDone(err) {
    self.logger.warn('ApiBase::destroy: instance destroyed ...');
    Object.getOwnPropertyNames(self).forEach(function (prop) {
      delete self[prop];
    });
    // Object.keys(self.__proto__).forEach(prop => {
    //   delete self.__proto__[prop]
    // })
    if (instances) {
      delete instances[instanceName];
      instances[instanceName] = null;
    }
    if (options.done instanceof Function) {
      options.done(err);
    }
  }
  this.disconnect({
    done: destroyDone
  });
};

ApiBaseFn.reset = function () {
  var options = this.updatePrivateConf(this.options);
  util.verifyBooleanWithDefault(options, 'exifOrientation', true, '', 'api::Base.reset');
};

ApiBaseFn.setOptions = function (newOptions) {
  this.reset();
  this.protocol.setOptions(newOptions);
};

// 还是不要 destroy 了, destroy 之后还是可以创建新的对象, 还是会有多个链接
// ApiBaseFn.destroy = function() {
//     var self = this
//     self.disconnect()
//     delete instances[self.name]
// }

/**
 * 异步请求回调函数, 成功时error为null, 发生错误时error包含具体错误信息
 *
 * @private
 * @callback done
 *
 * @param {Object} error            错误
 * @param {Number} error.code       错误码
 * @param {String} error.message    错误信息
 * @param {Object} obj              操作失败时包含调用时传入的参数, 操作成功时可能会返回不一样的信息或者会追加一些信息
 *
 * @see {@link NIMError.codeMap|错误码错误信息表}
 * @see {@link NIM}
 */
ApiBaseFn.processCallback = function (options, useOptionsAsObj) {
  _completeOption(options, useOptionsAsObj);
};

/**
 * 用于音视频的补充回调，返回一个promise
 * @private
 * @param {Object} options
 * @param {any} useOptionsAsObj 我也不知道是什么
 * @returns promise
 */
ApiBaseFn.processCallbackPromise = function (options, useOptionsAsObj) {
  var promise = new Promise(function (resolve, reject) {
    _completeOption(options, useOptionsAsObj, true, resolve, reject);
  });
  return promise;
};
/**
 * 补全配置
 * @private
 * @param {Object} option
 */
var _completeOption = function _completeOption(options, useOptionsAsObj, usePromise, resolve, reject) {
  var callFunc = 'api::processCallback';
  if (usePromise) {
    callFunc = 'api::processCallbackPromise';
  }
  util.verifyCallback(options, 'done', callFunc);
  options.callback = function (error, obj, content) {
    var rawOptions = options.callback.options;
    obj = obj || rawOptions;
    if (useOptionsAsObj) {
      obj = rawOptions;
    }
    // 某些协议需要额外特殊处理返回的数据
    if (util.isFunction(options.cbaop)) {
      var aopRtn = options.cbaop(error, obj);
      if (notundef(aopRtn)) {
        obj = aopRtn;
      }
    }
    var done = options.done;
    // 删除不需要传给用户的数据
    if (util.isObject(obj)) {
      delete obj.done;
      delete obj.cb;
      delete obj.callback;
    }
    if (usePromise) {
      if (error) {
        reject({
          message: '生成接口回调错误',
          callFunc: callFunc,
          event: error
        });
      } else {
        resolve(obj);
      }
    } else {
      done(error, obj, content);
    }
  };
  // 记录原始的options
  options.callback.options = util.copy(options);
};

ApiBaseFn.processPs = function (options) {
  if (util.notexist(options.ps)) {
    options.ps = '';
  }
};

ApiBaseFn.processCustom = function (options) {
  if (util.notexist(options.custom)) {
    options.custom = '';
  }
};

// sendCmd 的callback有三个参数，分别为error, package.obj, package.content
// obj为发送参数带回来，content为resp参数
ApiBaseFn.sendCmd = function () {
  this.protocol.sendCmd.apply(this.protocol, arguments);
};

// sendCmdWithResp 的callback有两个参数，分别为error, package.content
ApiBaseFn.sendCmdWithResp = function (cmd, obj, callback) {
  this.sendCmd(cmd, obj, function (error, req, res) {
    if (util.isFunction(callback)) {
      if (error) {
        callback(error, req);
      } else {
        callback(null, res);
      }
    }
  });
};

// 该方法考虑逐步弃用
ApiBaseFn.cbAndSendCmd = function (type, options) {
  var promise = this.processCallbackPromise(options);
  this.sendCmd(type, options);
  return promise;
};

ApiBaseFn.sendCmdUsePromise = function (type, options) {
  var _this = this;

  return new Promise(function (resolve, reject) {
    _this.sendCmd(type, options, function (error, req, res) {
      if (error) {
        reject(error);
      } else {
        var obj = util.merge({}, req, res);
        resolve(obj);
      }
    });
  });
};

ApiBase.use = function (plugin, options) {
  if (plugin && plugin.install && util.isFunction(plugin.install)) {
    plugin.install(this, options);
  }
};

ApiBase.rmAllInstances = function () {
  for (var instanceName in instances) {
    instances[instanceName].destroy();
  }
  instances = {};
};

ApiBaseFn.logout = function (options) {
  this.protocol.shouldReconnect = false;
  this.protocol.doLogout = true;
  this.processCallback(options);
  this.sendCmd('logout', options, options.callback);
};

module.exports = ApiBase;

__webpack_require__(/*! ./connect */ "./src/im/api/base/connect.js");
__webpack_require__(/*! ./msg */ "./src/im/api/base/msg.js");
__webpack_require__(/*! ./nos */ "./src/im/api/base/nos.js");
__webpack_require__(/*! ./nosViewImage */ "./src/im/api/base/nosViewImage.js");
__webpack_require__(/*! ./misc */ "./src/im/api/base/misc.js");
__webpack_require__(/*! ./report */ "./src/im/api/base/report.js");
__webpack_require__(/*! ./avSignal */ "./src/im/api/base/avSignal.js");
// require('./audio')

/***/ }),

/***/ "./src/im/api/base/misc.js":
/*!*********************************!*\
  !*** ./src/im/api/base/misc.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var ApiBaseFn = __webpack_require__(/*! ./index */ "./src/im/api/base/index.js").fn;
// const ajax = require('utiljs/ajax')
// const Config = require('utiljs/config')

ApiBaseFn.uploadSdkLogUrl = function (options) {
  util.verifyOptions(options, 'url', 'misc::uploadSdkLogUrl');
  return this.cbAndSendCmd('uploadSdkLogUrl', options);
};

/**
 * 文件上传进度回调
 * @private
 * @callback uploadprogress
 * @param {Object} obj                  进度信息
 * @param {Number} obj.total            文件总大小
 * @param {Number} obj.loaded           已经上传的大小
 * @param {Number} obj.percentage       上传百分比
 * @param {String} obj.percentageText   上传百分比的文字表示
 * @see {@link NIM#previewFile|预览文件}
 * @see {@link NIM#sendFile|发送文件消息}
 */

/**
 * 获取反垃圾词库
 *
 * - 开发者可以通过此接口获取反垃圾的词库
 *     - 通过回调参数，开发者可以检查词库是否合规
 *     - 回调函数第一个参数为该接口是否有错，第二个参数为词库对象，词库加载后会自动保存在内存中，开发者可以手动传入或者直接使用
 *
 * @memberOf NIM#
 * @method getClientAntispamLexicon
 * @return {Void}
 *
 * 反垃圾词库文件file包含
 * - version 词库版本
 * - md5 词库文件的md5
 * - nosurl 词库文件的下载地址
 * - thesaurus 词库内容
 * @example
 * nim.getClientAntispamLexicon({
 *     done: function(error, file) {
 *        console.log(error, file)
 *     }
 * });
 */
// 获取反垃圾词库 http://doc.hz.netease.com/pages/viewpage.action?pageId=107203234

ApiBaseFn.getClientAntispamLexicon = function (options) {
  var _this = this;

  options = options || {};
  var callback = options.done;
  if (!(callback instanceof Function)) {
    callback = function callback() {};
  }
  options = {
    clientAntispam: {
      version: 0 // int 词库版本
    }
  };
  var self = this;
  return this.protocol.sendCmd('getClientAntispam', options, function (error, obj, content) {
    if (error) {
      self.protocol.logger.error('misc::getClientAntispamLexicon:', error);
      callback.call(_this, error, {});
    } else {
      callback.call(_this, null, content);
      self.antispamLexicon = content.clientAntispam || {};
    }
  });
};

/**
 * 检查客户端反垃圾
 *
 * - 开发者在`getClientAntispamLexicon`获取反垃圾词库以后，可以通过此接口识别判断是否是垃圾文本
 * @param  {String} content 待检查文本
 * @param  {Object} antispamLexicon 反垃圾词库，可选
 * @method filterClientAntispam
 * @return {Object}
 * @param  {String} code 错误码
 * @param  {Integer} type 反垃圾类型
 * @param  {String} content 过滤后文本
 *
 * @example
 * nim.filterClientAntispam({
 *   content: '啦啦啦'
 * });
 */
// 获取反垃圾词库 http://doc.hz.netease.com/pages/viewpage.action?pageId=107203234
// 客户端反垃圾，词库获取函数为 getClientAntispamLexicon，在auth完成后执行
ApiBaseFn.filterClientAntispam = function (options) {
  var content = options.content,
      antispamLexicon = options.antispamLexicon;

  if (!content) {
    return {
      code: 404,
      errmsg: '待反垃圾文本content不存在'
    };
  }
  antispamLexicon = antispamLexicon || this.antispamLexicon || {};
  var thesaurus = this.antispamLexicon && this.antispamLexicon.thesaurus;
  if (!thesaurus) {
    return {
      code: 404,
      errmsg: '没有反垃圾词库或者词库格式不合法'
    };
  }
  try {
    thesaurus = JSON.parse(thesaurus).thesaurus;
  } catch (error) {
    this.protocol.logger.error('misc::filterClientAntispam: parse thesaurus error');
    return {
      code: 500,
      errmsg: '反垃圾词库格式不合法'
    };
  }
  var cnt = content;
  for (var i = 0; i < thesaurus.length; i++) {
    cnt = filterContent.call(this, cnt, thesaurus[i]);
    if ((typeof cnt === 'undefined' ? 'undefined' : (0, _typeof3.default)(cnt)) === 'object') {
      if (cnt.code === 2) {
        // 拒绝发送
        return {
          code: 200,
          type: 2,
          errmsg: '建议拒绝发送',
          content: content,
          result: ''
        };
      } else if (cnt.code === 3) {
        // 服务器处理（命中客户端反垃圾，交给服务器处理）,消息Property需要带上TalkMsgTag.clientAntiSpam
        return {
          code: 200,
          type: 3,
          errmsg: '建议服务器处理反垃圾，发消息带上字段clientAntiSpam',
          content: content,
          result: content
        };
      }
    } else {}
  }
  if (cnt === content) {
    return {
      code: 200,
      type: 0,
      errmsg: '',
      content: content,
      result: cnt
    };
  } else {
    return {
      code: 200,
      type: 1,
      errmsg: '已对特殊字符做了过滤',
      content: content,
      result: cnt
    };
  }
};

function matchContent(cnt, keyword, matchType, operateType) {
  var isMatched = false;
  var regWord = '';
  if (matchType === 1) {
    // 1: 关键词匹配
    if (cnt.indexOf(keyword) >= 0) {
      isMatched = true;
      regWord = keyword;
    }
  } else if (matchType === 2) {
    // 2: 正则表达式匹配
    regWord = new RegExp(keyword, 'g');
    if (regWord.test(cnt)) {
      isMatched = true;
    }
  }
  if (isMatched && regWord !== '') {
    switch (operateType) {
      // 1：替换
      case 1:
        return cnt.replace(regWord, '**');
      // 2：拒绝发送
      case 2:
        return { code: 2
          // 3：服务器处理（命中客户端反垃圾，交给服务器处理）,消息Property需要带上TalkMsgTag.clientAntiSpam
        };case 3:
        return { code: 3 };
    }
  }
  return cnt;
}

function filterContent(body, thesaurus) {
  var self = this;
  var match = thesaurus.match;
  var operate = thesaurus.operate;
  var cnt = body;
  for (var i = 0; i < thesaurus.keys.length; i++) {
    var item = thesaurus.keys[i];
    var matchType = item.match || match;
    var operateType = item.operate || operate;
    try {
      cnt = matchContent(cnt, item.key, matchType, operateType);
      if ((typeof cnt === 'undefined' ? 'undefined' : (0, _typeof3.default)(cnt)) === 'object') {
        return cnt;
      }
    } catch (error) {
      // 有些正则表达式web不支持
      self.logger.warn('misc::filterContent: js cannot parse this regexp ', error);
    }
  }
  return cnt;
}

/***/ }),

/***/ "./src/im/api/base/msg.js":
/*!********************************!*\
  !*** ./src/im/api/base/msg.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ApiBaseFn = __webpack_require__(/*! ./index */ "./src/im/api/base/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var X2JS = __webpack_require__(/*! x2js */ "./node_modules/x2js/x2js.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var nos = __webpack_require__(/*! utiljs/nos */ "./src/util/nos.js");
var Upload = __webpack_require__(/*! utiljs/upload */ "./src/util/upload.js");
var blob = __webpack_require__(/*! utiljs/blob */ "./src/util/blob.js");

ApiBaseFn.sendText = function (options) {
  var self = this;
  self.processCallback(options);
  options.msg = new self.message.TextMessage(options);
  return self.sendMsg(options);
};

ApiBaseFn.previewFile = function (options) {
  util.verifyOptions(options, 'done', 'msg::previewFile');
  if (!options.type) {
    options.type = 'file';
  }
  util.verifyParamPresentJustOne(options, 'dataURL blob fileInput filePath wxFilePath fileObject', 'msg::previewFile');
  if (util.exist(options.maxSize)) {
    util.verifyParamType('maxSize', options.maxSize, 'number', 'api::previewFile');
  }
  if (util.exist(options.commonUpload)) {
    util.verifyParamType('commonUpload', options.commonUpload, 'boolean', 'api::previewFile');
  }
  if (options.nosSurvivalTime) {
    util.verifyParamType('nosSurvivalTime', options.nosSurvivalTime, 'number', 'api::Base.getInstance');
    util.verifyParamMin('nosSurvivalTime', options.nosSurvivalTime, 86400, 'api::Base.getInstance');
  } else {
    options.nosSurvivalTime = this.nosSurvivalTime;
  }
  options.filePath = options.filePath || options.wxFilePath;
  delete options.wxFilePath;
  // 如果传入dataURL, 那么转成blob
  if (options.dataURL) {
    options.blob = blob.fromDataURL(options.dataURL);
  } else if (options.blob) {
    // 如果是 blob, 什么都不做
  } else if (options.fileInput) {
    // 如果是 fileInput, 记录下名字
    options.fileInput = util.verifyFileInput(options.fileInput, 'msg::previewFile');
    if (options.fileInput.files) {
      if (!options.fileInput.files.length) {
        options.done(NIMError.newNoFileError('请选择' + options.type + '文件', {
          callFunc: 'msg::previewFile',
          fileInput: options.fileInput
        }), options);
        return;
      }
      options.fileSize = options.fileInput.files[0].size;
    }
    options.fileInputName = util.getFileName(options.fileInput);
  }

  this.processCallback(options);
  var body = JSON.stringify(nos.genResponseBody(options.type) || {}).replace(/"/gi, '\\"');
  var responseBody = null;

  // 是否带转码协议
  var fn = options.transcode ? 'getNosTokenTrans' : 'getNosToken';
  if (options.transcode) {
    util.verifyOptions(options, 'fileInput', 'msg::previewFile');
    var fileInfo = util.getFileInfo(options.fileInput);
    responseBody = {
      transToken: {
        name: fileInfo.name,
        // tyte，文档类型，1表示ppt，2表示pptx，3表示pdf
        type: fileInfo.transcodeType,
        // byte，文档转码格式，10表示jpg，11表示png
        transType: options.transcode === 'png' ? 11 : 10,
        // long，文档原始大小，单位：字节
        size: fileInfo.size,
        body: body
      }
    };
  } else {
    responseBody = body;
  }
  this[fn]({
    responseBody: responseBody,
    nosToken: {
      nosScene: options.nosScene || this.nosScene,
      nosSurvivalTime: options.nosSurvivalTime
    },
    callback: function (error, data) {
      if (error) {
        options.done(error);
      } else {
        if (options.transcode) {
          options.nosToken = data.nosToken;
          options.docId = data.docId;
        } else {
          options.nosToken = data;
        }
        this._doPreviewFile(options);
      }
    }.bind(this)
  });
};

ApiBaseFn._doPreviewFile = function (options) {
  var self = this;
  var olduploaddone = options.uploaddone;
  var commonUrl = Config.genUploadUrl(options.nosToken.bucket);
  var chunkUrl = Config.genChunkUploadUrl(options.nosToken);
  var url;
  if (options.commonUpload || !chunkUrl || Config.isWeixinApp || Config.isNodejs || Config.isRN) {
    // 6.2.0 版本开始使用直传（分片上传）
    options.commonUpload = true;
    url = commonUrl;
  } else {
    url = chunkUrl;
  }
  var params = this.assembleUploadParams(options.nosToken);
  var fileName = 'file';
  function uploaddone(error, json, quickTransfer) {
    options.uploaddone = olduploaddone;
    if (error) {
      options.done(error, options.callback.options);
    } else {
      json = nos.parseResponse(json, self.options.exifOrientation);
      if (!quickTransfer) {
        json.url = Config.genDownloadUrl(options.nosToken, params.Object);
        // 如果开启了nos文件安全验证，则会返回短链，此时需要使用（发送/返回）短链
        if (options.nosToken.shortUrl) {
          json._url_safe = options.nosToken.shortUrl;
        }
      }
      if (util.exist(options.fileInputName)) {
        json.name = options.fileInputName;
      } else if (options.blob) {
        var name = options.blob.name;
        json.name = name || 'blob-' + json.md5;
        if (!name) {
          var type = options.blob.type;
          json.ext = type.slice(type.lastIndexOf('/') + 1);
        }
      } else if (options.filePath) {
        json.name = options.filePath;
      } else if (options.fileObject) {
        json.name = options.fileObject.fileName;
      }
      if (!json.ext) {
        var lastDotIndex = json.name.lastIndexOf('.');
        if (lastDotIndex === -1) {
          json.ext = 'unknown';
        } else {
          json.ext = json.name.slice(lastDotIndex + 1);
        }
      }
      // react-native可能取不到size与md5，所以这些参数可能不准
      json.size = json.size || 0;
      options.done(null, util.copy(json));
    }
  }
  if (Config.isWeixinApp) {
    util.verifyOptions(options, 'filePath', 'msg::_doPreviewFile');
    // eslint-disable-next-line no-undef
    self.fileQuickTransfer(options, uploaddone, function () {
      wx.uploadFile({
        url: url,
        filePath: options.filePath,
        name: fileName,
        formData: params,
        fail: function fail(err) {
          console.log('error:', 'api::msg:upload file failed', err);
        },
        success: function success(res) {
          if (res.statusCode === 200) {
            try {
              uploaddone(null, JSON.parse(res.data));
            } catch (e) {
              console.log('error:', 'parse wx upload file res error', e);
              uploaddone({
                code: 'PARSE_WX_UPLOAD_FILE_RES_ERROR',
                str: res.data,
                msg: res.errMsg
              });
            }
          } else {
            uploaddone({
              code: res.statusCode,
              msg: res.errMsg
            });
          }
        }
      });
    });
  } else if (Config.isNodejs) {
    var uploadConfig = {
      url: url,
      name: fileName,
      formData: params,
      success: function success(res) {
        if (res.statusCode === 200) {
          try {
            uploaddone(null, JSON.parse(res.data));
          } catch (e) {
            console.log('error:', 'parse nodejs upload file res error', e);
            uploaddone({
              code: 'PARSE_NODEJS_UPLOAD_FILE_RES_ERROR',
              str: res.data,
              msg: res.errMsg
            });
          }
        } else {
          uploaddone({
            code: res.statusCode,
            msg: res.errMsg
          });
        }
      },
      fail: function fail(err) {
        console.log('error:', 'api::msg:upload file failed', err);
      }
    };
    if (options.filePath) {
      uploadConfig.filePath = options.filePath;
    } else {
      if ((0, _typeof3.default)(options.fileObject) !== 'object') {
        throw new NIMError('Nodejs上传fileObject参数类型应如 {fileName:..,fileData:..} ');
      }
      uploadConfig.fileData = options.fileObject.fileData;
    }
    self.fileQuickTransfer(options, uploaddone, function () {
      Upload.uploadFile(uploadConfig);
    });
  } else if (Config.isRN) {
    var _uploadConfig = {
      url: url,
      name: fileName,
      formData: params,
      filePath: options.filePath,
      success: function success(res) {
        if (res.ok && res.status === 200) {
          try {
            res.md5 = res.headers.map && res.headers.map.etag && res.headers.map.etag[0] || 'UNKNOWN';

            uploaddone(null, res);
          } catch (e) {
            console.log('error:', 'parse React Native upload file res error', e);
            uploaddone({
              code: 'PARSE_React_Native_UPLOAD_FILE_RES_ERROR',
              res: res
            });
          }
        } else {
          uploaddone({
            code: res.status,
            msg: res.statusText
          });
        }
      },
      fail: function fail(err) {
        console.log('error:', 'api::msg:upload file failed', err);
      }
    };
    self.fileQuickTransfer(options, uploaddone, function () {
      Upload.uploadFile(_uploadConfig);
    });
  } else {
    options.uploaddone = uploaddone;
    options.url = url;
    options.params = params;
    options.fileName = fileName;
    // eslint-disable-next-line no-new
    self.fileQuickTransfer(options, uploaddone, function () {
      return new Upload(options);
    });
  }
};
// 文件快传 当传入了 fastPass json字符串 包含 md5 (图片还需包含 w,h 音频还需包含 dur, 视频还需包含 w,h,dur) 并且文件大小能获取 小于 Config.threshold 则使用快传地址
ApiBaseFn.fileQuickTransfer = function (param, callback, goOnFn) {
  var self = this;
  param = param || {};
  if (!(callback instanceof Function)) {
    callback = function callback() {};
  }
  if (!(goOnFn instanceof Function)) {
    goOnFn = function goOnFn() {};
  }
  var fastPass = param.fastPass;
  if (fastPass) {
    try {
      fastPass = JSON.parse(fastPass);
      param.fastPass = fastPass;
    } catch (e) {
      self.protocol.logger.error('快传参数解析失败');
    }
  }
  var name = param.fileInputName || param.name || param.blob && param.blob.name || '';
  var size = param.fileSize || param.size || param.blob && param.blob.size || 0;
  var md5 = fastPass ? ((fastPass.md5 || param.digest || '') + '').trim() : '';
  var type = param.type || param.blob && param.blob.type;
  if (md5 && size >= Config.threshold) {
    var paramPass = true;
    var callbackParam = {
      name: name,
      md5: md5,
      ext: name.slice(name.lastIndexOf('.') + 1),
      type: type
    };
    switch (type) {
      case 'image':
        if (!fastPass || !fastPass.w || !fastPass.h) {
          paramPass = false;
          self.protocol.logger.error('快传 image 文件缺少参数 w 或 h');
        } else {
          callbackParam.w = fastPass.w;
          callbackParam.h = fastPass.h;
        }
        break;
      case 'video':
        if (!fastPass || !fastPass.w || !fastPass.h || !fastPass.dur) {
          paramPass = false;
          self.protocol.logger.error('快传 video 文件缺少参数 w 或 h 或 dur');
        } else {
          callbackParam.w = fastPass.w;
          callbackParam.h = fastPass.h;
          callbackParam.dur = fastPass.dur;
        }
        break;
      case 'audio':
        if (!fastPass || !fastPass.dur) {
          paramPass = false;
          self.protocol.logger.error('快传 audio 文件缺少参数 dur');
        } else {
          callbackParam.dur = fastPass.dur;
        }
        break;
    }
    if (!paramPass) {
      goOnFn();
      return;
    }

    var fqtParm = { fileQuickTransfer: { md5: md5 } };
    if (size) {
      fqtParm.fileQuickTransfer.size = size;
    }
    return this.protocol.sendCmd('fileQuickTransfer', fqtParm, function (error, fqtParm, obj) {
      if (error || !obj || !obj.fileQuickTransfer || !obj.fileQuickTransfer.url) {
        self.protocol.logger.error('misc::fileQuickTransfer: not found', error, fqtParm, obj);
        goOnFn();
      }
      if (obj && obj.fileQuickTransfer && obj.fileQuickTransfer.threshold) {
        Config.threshold = obj.fileQuickTransfer.threshold || 0;
      }
      if (obj && obj.fileQuickTransfer && obj.fileQuickTransfer.url) {
        callbackParam.size = size || obj.fileQuickTransfer.size;
        callbackParam.url = obj.fileQuickTransfer.url;
        if (obj.fileQuickTransfer._url_safe) {
          callbackParam._url_safe = obj.fileQuickTransfer._url_safe;
        }
        callback(error, callbackParam, true);
      }
    });
  }
  goOnFn();
};

ApiBaseFn.sendFile = function (options) {
  var self = this;
  if (!options.type) {
    options.type = 'file';
  }
  util.verifyParamPresentJustOne(options, 'dataURL blob fileInput file filePath wxFilePath fileObject', 'msg::sendFile');
  if (util.exist(options.maxSize)) {
    util.verifyParamType('maxSize', options.maxSize, 'number', 'api::previewFile');
  }
  if (util.exist(options.commonUpload)) {
    util.verifyParamType('commonUpload', options.commonUpload, 'boolean', 'api::previewFile');
  }
  self.processCallback(options);
  options.filePath = options.filePath || options.wxFilePath;
  delete options.wxFilePath;
  // 如果传入dataURL, 直接预览发送
  if (options.dataURL) {
    self._previewAndSendFile(options);
  } else if (options.blob) {
    // 如果传入blob, 直接预览发送
    self._previewAndSendFile(options);
  } else if (options.fileInput) {
    // 如果传入file input, 那么先处理参数后再预览发送
    options.fileInput = util.verifyFileInput(options.fileInput, 'msg::sendFile');
    if (!!options.fileInput.files && !options.fileInput.files.length) {
      options.done(NIMError.newNoFileError('请选择' + options.type + '文件', {
        callFunc: 'msg::sendFile',
        fileInput: options.fileInput
      }), options.callback.options);
      return;
    }
    self._previewAndSendFile(options);
  } else if (options.filePath || options.fileObject) {
    // 微信上传文件
    self._previewAndSendFile(options);
  } else if (options.file) {
    // 处理nos安全短链，用户自己的上传操作可以返回源链和短链
    var originUrl;
    var safeUrl = options.file._url_safe;
    if (safeUrl) {
      originUrl = options.file.url;
      options.file.url = safeUrl;
      delete options.file._url_safe;
    }
    // 如果传入文件对象, 那么直接发送
    options.msg = new self.message.FileMessage(options);
    return self.sendMsg(options, originUrl); // 如果有Nos文件安全短链
  }
};

ApiBaseFn._previewAndSendFile = function (options) {
  var self = this;
  util.verifyCallback(options, 'uploaddone beforesend', 'msg::_previewAndSendFile');
  // 缓存 done 回调
  var done = options.done;
  options.done = function (error, json) {
    // 恢复 done 回调
    options.done = done;
    if (error) {
      options.uploaddone(error, options.callback.options);
      // 6.3.0 增加 上传失败后也会调用 done 回调通知
      options.done(error, options.callback.options);
    } else {
      // 欢欢留下的坑 以后去掉吧 不需要判断
      if (/chatroom/.test(options.scene)) return;
      options.uploaddone(null, util.copy(json));
      // 处理nos安全短链，用户自己的上传操作可以返回源链和短链
      var originUrl;
      var safeUrl = json._url_safe;
      if (safeUrl) {
        originUrl = json.url;
        json.url = safeUrl;
        delete json._url_safe;
      }
      options.file = json;
      options.msg = new self.message.FileMessage(options);
      options.beforesend(self.sendMsg(options, originUrl)); // 如果有Nos文件安全短链
    }
  };
  self.previewFile(options);
};

ApiBaseFn.assembleUploadParams = function (nosToken) {
  if (nosToken) {
    return {
      Object: decodeURIComponent(nosToken.objectName),
      'x-nos-token': nosToken.token,
      'x-nos-entity-type': 'json'
    };
  }
  return null;
};

ApiBaseFn.deleteFile = function (options) {
  util.verifyParamPresentJustOne(options, 'docId', 'msg::deleteFile');
  this.removeFile({
    docId: options.docId,
    callback: function callback(error, data) {
      if (error) {
        options.error && options.error(error, data);
      } else {
        options.success && options.success(data);
      }
    }
  });
};
ApiBaseFn.getFile = function (options) {
  util.verifyParamPresentJustOne(options, 'docId', 'msg::getFile');
  this.fetchFile({
    docId: options.docId,
    callback: function callback(error, data) {
      if (error) {
        options.error && options.error(error, data);
      } else {
        options.success && options.success(data.info);
      }
    }
  });
};
// 获取文档列表，默认获取10条
ApiBaseFn.getFileList = function (options) {
  var _options$fromDocId = options.fromDocId,
      fromDocId = _options$fromDocId === undefined ? '' : _options$fromDocId,
      _options$limit = options.limit,
      limit = _options$limit === undefined ? 10 : _options$limit;

  var param = { limit: limit };
  if (fromDocId) {
    param.fromDocId = fromDocId;
  }
  this.fetchFileList({
    fileListParam: param,
    callback: function callback(error, data) {
      if (error) {
        if (limit > 30) {
          error.message = error.message + '::文档条数超过限制:30';
        }
        options.error && options.error(error, data);
      } else {
        options.success && options.success(data);
      }
    }
  });
};
ApiBaseFn.sendGeo = function (options) {
  var self = this;
  self.processCallback(options);
  options.msg = new self.message.GeoMessage(options);
  return self.sendMsg(options);
};

ApiBaseFn.sendTipMsg = function (options) {
  var self = this;
  self.processCallback(options);
  options.msg = new self.message.TipMessage(options);
  return self.sendMsg(options);
};

ApiBaseFn.sendCustomMsg = function (options) {
  var self = this;
  self.processCallback(options);
  options.msg = new self.message.CustomMessage(options);
  return self.sendMsg(options);
};

ApiBaseFn.sendRobotMsg = function (options) {
  var self = this;
  self.processCallback(options);
  options.msg = new self.message.RobotMessage(options);
  return self.sendMsg(options);
};

ApiBaseFn.sendMsg = function (options, originUrl) {
  var self = this;
  var protocol = self.protocol;
  var msg = options.msg;
  var content = {};
  // 是否是本地消息, 本地消息不会被发送, 非本地消息不允许设置时间
  var isLocal = !!options.isLocal;
  if (isLocal) {
    if (options.time) {
      msg.time = options.time;
    }
    // 本地消息允许重置idClient为自定义
    if (options.idClient) {
      msg.idClient = options.idClient;
    }
  }
  // 重发
  if (options.resend) {
    if (options.flow !== 'out' || options.status !== 'fail') {
      return util.onError('只能重发发送失败的消息');
    }
  }
  // 将 idClient 记录下来, 如果发送失败, 那么可以其返回给开发者
  options.callback.options.idClient = msg.idClient;
  // 子类处理
  self.beforeSendMsg(options, content);

  var rtnMsg = options.rtnMsg = self.formatReturnMsg(msg);
  if (originUrl && !self.options.keepNosSafeUrl && rtnMsg.file) {
    // 处理nos安全短链，用户自己的上传操作可以返回源链和短链
    rtnMsg.file._url_safe = rtnMsg.file.url;
    rtnMsg.file.url = originUrl;
    if (rtnMsg.type === 'audio') {
      rtnMsg.file.mp3Url = originUrl + (~originUrl.indexOf('?') ? '&' : '?') + 'audioTrans&type=mp3';
    }
  }
  if (rtnMsg.hasOwnProperty('chatroomId') && !rtnMsg.chatroomId) {
    return util.onError('聊天室未连接');
  }

  // self.protocol.filterClientAntispam(rtnMsg)
  // 如果是本地消息, 那么修改状态
  if (isLocal) {
    rtnMsg.status = 'success';
    rtnMsg.isLocal = true;
  }
  // 记录 Promise
  if (protocol.storeSendMsg) {
    content.promise = protocol.storeSendMsg(rtnMsg);
  }
  // 处理错误
  options.cbaop = function (error) {
    // 错误包括
    // - 服务器返回的错误
    //   - 被加入黑名单
    // - 客户端检测到的错误
    //   - 断网
    //   - 超时
    // 如果是客户端检测到的错误，需要将错误写入数据库
    if (error && error.from !== 'server') {
      rtnMsg.status = 'fail';
      if (protocol.updateSendMsgError) {
        protocol.updateSendMsgError(rtnMsg);
      }
      return rtnMsg;
    }
  };

  // 发消息, 不发本地消息，不发反垃圾未通过消息
  // if (!isLocal && !rtnMsg.failReason) {
  // if (rtnMsg.text) {
  //   // 反垃圾替换后的词
  //   msg.body = rtnMsg.text
  //   if (this.subType === 'chatroom') {
  //     msg.attach = rtnMsg.text
  //   }
  // }
  // if (rtnMsg.clientAntiSpam) {
  //   msg.clientAntiSpam = rtnMsg.clientAntiSpam
  // }
  if (!isLocal) {
    // 自己上传的文件知道源链不用再请求，这里记录
    if (originUrl && !self.options.keepNosSafeUrl && options.callback) {
      options.callback.originUrl = originUrl;
    }
    content.msg = msg;
    self.sendCmd(options.cmd, content, options.callback);
  }
  self.afterSendMsg(options);
  // 如果是本地消息, 那么模拟异步发送成功
  if (isLocal) {
    setTimeout(function () {
      rtnMsg = util.simpleClone(rtnMsg);
      options.done(null, rtnMsg);
    }, 0);
  }
  // if (rtnMsg.status === 'fail' && rtnMsg.failReason) {
  //   setTimeout(function () {
  //     rtnMsg = util.simpleClone(rtnMsg)
  //     options.done(
  //       new NIMError('消息无法发送，因含有敏感词', 'ANTISPAM_ERROR', {
  //         callFunc: 'msg::sendMsg'
  //       }),
  //       rtnMsg
  //     )
  //   }, 0)
  // }
  return util.copy(rtnMsg);
};

ApiBaseFn.beforeSendMsg = function () {};

ApiBaseFn.afterSendMsg = function () {};

ApiBaseFn.formatReturnMsg = function (msg) {
  var self = this;
  msg = util.copy(msg);
  self.protocol.completeMsg(msg);
  msg.status = 'sending';
  msg = self.message.reverse(msg);
  return msg;
};

ApiBaseFn.resendMsg = function (options) {
  var self = this;
  util.verifyOptions(options, 'msg', 'msg::resendMsg');
  self.trimMsgFlag(options);
  options.resend = true;
  return self._sendMsgByType(options);
};

ApiBaseFn.forwardMsg = function (options) {
  var self = this;
  util.verifyOptions(options, 'msg', 'msg::forwardMsg');
  self.trimMsgFlag(options);
  self.beforeForwardMsg(options);
  options.forward = true;
  options.msg.idClient = util.guid();
  return self._sendMsgByType(options);
};

ApiBaseFn.trimMsgFlag = function (options) {
  if (options && options.msg) {
    options.msg = util.copy(options.msg);
    delete options.msg.resend;
    delete options.msg.forward;
  }
};

ApiBaseFn.beforeForwardMsg = function () {};

ApiBaseFn._sendMsgByType = function (options) {
  var self = this;
  util.verifyOptions(options, 'msg', 'msg::_sendMsgByType');
  util.verifyParamValid('msg.type', options.msg.type, self.message.validTypes, 'msg::_sendMsgByType');
  util.merge(options, options.msg);
  switch (options.type) {
    case 'text':
      return self.sendText(options);
    case 'image':
    case 'audio':
    case 'video':
    case 'file':
      return self.sendFile(options);
    case 'geo':
      return self.sendGeo(options);
    case 'custom':
      return self.sendCustomMsg(options);
    case 'tip':
      return self.sendTipMsg(options);
    default:
      throw new NIMError('不能发送类型为 ' + options.type + ' 的消息');
  }
};

ApiBaseFn.parseRobotTemplate = function (content) {
  if (/<template[^>\/]+\/>/.test(content)) {
    return {
      raw: content,
      json: [{
        type: 'text',
        name: '',
        text: ''
      }]
    };
  }
  if (!/<template[^>\/]+>/.test(content)) {
    return {
      raw: content,
      json: [{
        type: 'text',
        name: '',
        text: content
      }]
    };
  }
  var x2js = new X2JS({
    escapeMode: false
    // arrayAccessForm: 'property'
  });
  content = content.replace(/<template [^>]+>/, '<template>');
  var jsonObj = x2js.xml2js(content);
  jsonObj = jsonObj.template.LinearLayout;
  if (!Array.isArray(jsonObj)) {
    jsonObj = [jsonObj];
  }

  var tplArray = [];
  jsonObj = jsonObj.forEach(function (item) {
    if (item.image) {
      tplArray = tplArray.concat(parseImageJson(item));
    }
    if (item.text) {
      tplArray = tplArray.concat(parseTextJson(item));
    }
    if (item.link) {
      tplArray = tplArray.concat(parseLinkJson(item));
    }
  });

  return {
    raw: content,
    json: tplArray
    // html: htmlStr
  };

  function parseLinkJson(item) {
    if (item.link) {
      var link = item.link;
      // item.type = 'link'
      if (!Array.isArray(link)) {
        link = [link];
      }
      link = link.map(function (linkItem) {
        if (linkItem.image) {
          linkItem.image = parseImageJson(linkItem);
        }
        if (linkItem.text) {
          linkItem.text = parseTextJson(linkItem);
        }
        if (linkItem._type === 'url') {
          linkItem.type = 'url';
          linkItem.style = linkItem._style || '';
          linkItem.target = linkItem._target;
          delete linkItem._target;
          delete linkItem._style;
        } else if (linkItem._type === 'block') {
          linkItem.type = 'block';
          linkItem.style = linkItem._style || '';
          linkItem.params = linkItem._params || '';
          linkItem.target = linkItem._target;
          delete linkItem._params;
          delete linkItem._target;
          delete linkItem._style;
        }
        delete linkItem._type;
        return linkItem;
      });
      item.link = link;
    }
    return item.link;
  }

  function parseTextJson(obj) {
    // if (obj.text) {
    //   obj.type = 'text'
    // }
    if (!Array.isArray(obj.text)) {
      obj.text = [obj.text];
    }
    obj.text = obj.text.map(function (item) {
      return {
        type: 'text',
        name: item._name,
        text: item.__text
      };
    });
    return obj.text;
  }

  function parseImageJson(obj) {
    // if (obj.image) {
    //   obj.type = 'image'
    // }
    if (!Array.isArray(obj.image)) {
      obj.image = [obj.image];
    }
    obj.image = obj.image.map(function (item) {
      return {
        type: 'image',
        name: item._name,
        url: item._url
      };
    });
    return obj.image;
  }
};

/***/ }),

/***/ "./src/im/api/base/nos.js":
/*!********************************!*\
  !*** ./src/im/api/base/nos.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var ApiBaseFn = __webpack_require__(/*! ./index */ "./src/im/api/base/index.js").fn;
var ImageOp = __webpack_require__(/*! im/model/ImageOp */ "./src/im/model/ImageOp.js");
var nos = __webpack_require__(/*! utiljs/nos */ "./src/util/nos.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");

/**
  *  文档转码
  * @method transDoc
  * @private
  * @param {Object} options         配置参数
  * @param {String} options.fileInput 文件节点
  * @param {String} options.transcode 转码格式 png/jpg
  * @return {Void}
  */
ApiBaseFn.transDoc = function (options) {
  util.verifyOptions(options, 'fileInput done', 'nos::transDoc');
  try {
    var file = options.fileInput.files[0];
    var validExts = ['ppt', 'pdf', 'pptx'];
    var fileName = options.fileInputName = file.name;
    var map = {
      'ppt': 1,
      'pptx': 2,
      'pdf': 3
    };
    var type = fileName.substring(fileName.lastIndexOf('.') + 1);
    if (validExts.indexOf(type) < 0) {
      options.done(NIMError.newNoFileError('请上传正确格式的文件【ppt, pptx, pdf】', {
        callFunc: 'nos: transDoc',
        fileInput: options.fileInput
      }), options);
      return;
    }
  } catch (error) {
    options.done(NIMError.newNoFileError('请上传正确的文件节点', {
      callFunc: 'msg::previewFile',
      fileInput: options.fileInput
    }), options);
    return;
  }
  var body = JSON.stringify(nos.genResponseBody('file') || {}).replace(/"/gi, '\\"');
  var responseBody = {
    transToken: {
      name: fileName,
      // tyte，文档类型，1表示ppt，2表示pptx，3表示pdf
      type: map[type],
      // byte，文档转码格式，10表示jpg，11表示png
      transType: options.transcode === 'png' ? 11 : 10,
      // long，文档原始大小，单位：字节
      size: file.size,
      body: body
    }
  };
  this.getNosTokenTrans({
    responseBody: responseBody,
    nosToken: {
      nosScene: options.nosScene || this.nosScene,
      nosSurvivalTime: options.nosSurvivalTime
    },
    callback: function (error, data) {
      if (error) {
        options.done(error);
      } else {
        options.nosToken = data.nosToken;
        options.docId = data.docId;
        this._doPreviewFile(options);
      }
    }.bind(this) });
};

ApiBaseFn.getSimpleNosToken = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  options.num = 1;
  util.verifyOptions(options);
  return this.cbAndSendCmd('getSimpleNosToken', options);
};

// 开启文件安全验证后会返回短链
ApiBaseFn.getNosToken = function (_ref) {
  var callback = _ref.callback,
      nosToken = _ref.nosToken,
      responseBody = _ref.responseBody;

  var nosTokenParams = {
    tag: nosToken.nosScene
  };
  if (nosToken.nosSurvivalTime && nosToken.nosSurvivalTime !== Infinity) {
    nosTokenParams.expireSec = nosToken.nosSurvivalTime;
  }
  this.sendCmd('getNosToken', {
    responseBody: responseBody,
    nosToken: nosTokenParams
  }, callback);
};

ApiBaseFn.getNosTokenTrans = function (options) {
  this.sendCmd('getNosTokenTrans', options.responseBody, options.callback);
};

ApiBaseFn.packFileDownloadName = function (options) {
  util.verifyOptions(options, 'url name', true, '', 'nos::packFileDownloadName');
  var url = options.url;
  return url + util.genUrlSep(url) + 'download=' + encodeURIComponent(options.name);
};

ApiBaseFn.audioToMp3 = function (options) {
  util.verifyOptions(options, 'url', 'nos::audioToMp3');
  var url = options.url;
  return url + util.genUrlSep(url) + 'audioTrans&type=mp3';
};

// 文件相关操作
ApiBaseFn.removeFile = function (options) {
  this.sendCmd('removeFile', options, options.callback);
};
ApiBaseFn.fetchFile = function (options) {
  this.sendCmd('fetchFile', options, options.callback);
};
ApiBaseFn.fetchFileList = function (options) {
  this.sendCmd('fetchFileList', options, options.callback);
};

/*
 * 图片处理相关的操作
 */

ApiBaseFn.stripImageMeta = function (options) {
  return this.beforeProcessImage(options, 'stripmeta');
};

ApiBaseFn.qualityImage = function (options) {
  return this.beforeProcessImage(options, 'quality');
};

ApiBaseFn.interlaceImage = function (options) {
  return this.beforeProcessImage(options, 'interlace');
};

ApiBaseFn.rotateImage = function (options) {
  return this.beforeProcessImage(options, 'rotate');
};

ApiBaseFn.blurImage = function (options) {
  return this.beforeProcessImage(options, 'blur');
};

ApiBaseFn.cropImage = function (options) {
  return this.beforeProcessImage(options, 'crop');
};

ApiBaseFn.thumbnailImage = function (options) {
  return this.beforeProcessImage(options, 'thumbnail');
};

ApiBaseFn.beforeProcessImage = function (options, type) {
  var op = util.copy(options);
  op.type = type;
  options.ops = [op];
  return this.processImage(options);
};

ApiBaseFn.processImage = function (options) {
  var self = this;
  util.verifyOptions(options, 'url ops', true, '', 'nos::processImage');
  util.verifyParamType('ops', options.ops, 'array', 'nos::processImage');
  var imageOps = options.ops.map(function (op) {
    util.verifyOptions(op, 'type', true, '', 'nos::processImage');
    util.verifyParamValid('type', op.type, ImageOp.validTypes, 'nos::processImage');
    return self['gen' + op.type.slice(0, 1).toUpperCase() + op.type.slice(1) + 'Op'](op);
  });
  self.processCallback(options);
  self.sendCmd('processImage', {
    url: options.url,
    imageOps: imageOps
  }, options.callback);
};

ApiBaseFn.genStripmetaOp = function (options) {
  return new ImageOp({
    type: options.type,
    stripmeta: options.strip ? 1 : 0
  });
};

ApiBaseFn.genQualityOp = function (options) {
  util.verifyOptions(options, 'quality', true, '', 'nos::genQualityOp');
  util.verifyParamType('quality', options.quality, 'number', 'nos::genQualityOp');
  util.verifyParamMin('quality', options.quality, 0, 'nos::genQualityOp');
  util.verifyParamMax('quality', options.quality, 100, 'nos::genQualityOp');
  var quality = Math.round(options.quality);
  return new ImageOp({
    type: options.type,
    qualityQuality: quality
  });
};

ApiBaseFn.genInterlaceOp = function (options) {
  return new ImageOp({
    type: options.type
  });
};

ApiBaseFn.genRotateOp = function (options) {
  util.verifyOptions(options, 'angle', true, '', 'nos::genRotateOp');
  util.verifyParamType('angle', options.angle, 'number', 'nos::genRotateOp');
  while (options.angle < 0) {
    options.angle = options.angle + 360;
  }
  options.angle = options.angle % 360;
  var angle = Math.round(options.angle);
  return new ImageOp({
    type: options.type,
    rotateAngle: angle
  });
};

ApiBaseFn.genBlurOp = function (options) {
  util.verifyOptions(options, 'radius sigma', 'nos::genBlurOp');
  util.verifyParamType('radius', options.radius, 'number', 'nos::genBlurOp');
  util.verifyParamMin('radius', options.radius, 1, 'nos::genBlurOp');
  util.verifyParamMax('radius', options.radius, 50, 'nos::genBlurOp');
  util.verifyParamType('sigma', options.sigma, 'number', 'nos::genBlurOp');
  util.verifyParamMin('sigma', options.sigma, 0, 'nos::genBlurOp');
  var radius = Math.round(options.radius);
  var sigma = Math.round(options.sigma);
  return new ImageOp({
    type: options.type,
    blurRadius: radius,
    blurSigma: sigma
  });
};

ApiBaseFn.genCropOp = function (options) {
  util.verifyOptions(options, 'x y width height', 'nos::genCropOp');
  util.verifyParamType('x', options.x, 'number', 'nos::genCropOp');
  util.verifyParamMin('x', options.x, 0, 'nos::genCropOp');
  util.verifyParamType('y', options.y, 'number', 'nos::genCropOp');
  util.verifyParamMin('y', options.y, 0, 'nos::genCropOp');
  util.verifyParamType('width', options.width, 'number', 'nos::genCropOp');
  util.verifyParamMin('width', options.width, 0, 'nos::genCropOp');
  util.verifyParamType('height', options.height, 'number', 'nos::genCropOp');
  util.verifyParamMin('height', options.height, 0, 'nos::genCropOp');
  var x = Math.round(options.x);
  var y = Math.round(options.y);
  var width = Math.round(options.width);
  var height = Math.round(options.height);
  return new ImageOp({
    type: options.type,
    cropX: x,
    cropY: y,
    cropWidth: width,
    cropHeight: height
  });
};

ApiBaseFn.genThumbnailOp = function () {
  var modes = {
    cover: 'z',
    contain: 'x',
    crop: 'y'
  };
  return function (options) {
    util.verifyOptions(options, 'mode', 'nos::genThumbnailOp');
    util.verifyParamValid('mode', options.mode, Object.keys(modes), 'nos::genThumbnailOp');
    if (options.mode === 'contain') {
      util.verifyParamAtLeastPresentOne(options, 'width height', 'nos::genThumbnailOp');
    } else {
      util.verifyOptions(options, 'width height', 'nos::genThumbnailOp');
    }
    if (util.undef(options.width)) {
      options.width = 0;
    }
    if (util.undef(options.height)) {
      options.height = 0;
    }
    util.verifyParamType('width', options.width, 'number', 'nos::genThumbnailOp');
    util.verifyParamMin('width', options.width, 0, 'nos::genThumbnailOp');
    util.verifyParamType('height', options.height, 'number', 'nos::genThumbnailOp');
    util.verifyParamMin('height', options.height, 0, 'nos::genThumbnailOp');
    var width = Math.round(options.width);
    var height = Math.round(options.height);
    var imageOp = new ImageOp({
      type: options.type,
      thumbnailMode: modes[options.mode],
      thumbnailWidth: width,
      thumbnailHeight: height
    });
    if (options.mode === 'crop') {
      if (util.notundef(options.axis)) {
        if (util.undef(options.axis.x)) {
          options.axis.x = 5;
        }
        if (util.undef(options.axis.y)) {
          options.axis.y = 5;
        }
        util.verifyParamMin('axis.x', options.axis.x, 0, 'nos::genThumbnailOp');
        util.verifyParamMax('axis.x', options.axis.x, 10, 'nos::genThumbnailOp');
        util.verifyParamMin('axis.y', options.axis.y, 0, 'nos::genThumbnailOp');
        util.verifyParamMax('axis.y', options.axis.y, 10, 'nos::genThumbnailOp');
        var x = Math.round(options.axis.x);
        var y = Math.round(options.axis.y);
        imageOp.thumbnailAxisX = x;
        imageOp.thumbnailAxisY = y;
      }
    }
    if (util.notundef(options.enlarge)) {
      util.verifyParamType('enlarge', options.enlarge, 'boolean', 'nos::genThumbnailOp');
      if (options.enlarge) {
        imageOp.thumbnailEnlarge = 1;
      }
    }
    return imageOp;
  };
}();

/**
  * 通过nos安全短链获取nos源链
  * @method getNosOriginUrl
  * @private
  * @param {Object} options           参数
  * @param {String} options.safeShortUrl   nos文件安全短链地址
  * @return {Void}
  */
// 考虑到用户升级成本、与其他端互通兼容，web sdk 所有的短链收到后经过处理后再返回给用户，用户也可以调用此 api 用短链获取源链
ApiBaseFn.getNosOriginUrl = function (options) {
  var self = this;
  util.verifyOptions(options, 'safeShortUrl', true, '', 'nos::getNosOriginUrl');
  util.verifyParamType('safeShortUrl', options.safeShortUrl, 'string', 'nos::getNosOriginUrl');
  if (!/^http(s)?:/.test(options.safeShortUrl) || !~options.safeShortUrl.indexOf('im_url=1')) {
    options.done(new NIMError('参数 “safeShortUrl” 内容非文件安全短链', {
      callFunc: 'nos: getNosOriginUrl'
    }), options);
    return;
  }
  self.processCallback(options);
  self.sendCmd('getNosOriginUrl', {
    nosFileUrlTag: {
      safeUrl: options.safeShortUrl
    }
  }, options.callback);
};

/***/ }),

/***/ "./src/im/api/base/nosViewImage.js":
/*!*****************************************!*\
  !*** ./src/im/api/base/nosViewImage.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _url2 = __webpack_require__(/*! utiljs/url */ "./src/util/url.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var ApiBaseFn = __webpack_require__(/*! ./index */ "./src/im/api/base/index.js").fn;


// 参数 strip boolean
//
ApiBaseFn.viewImageSync = function (options) {
  var linkOptions = this.options;
  util.verifyOptions(options, 'url', 'nos::viewImageSync');
  var url = options.url; // + '?imageView&quality=20'

  var _url2object = (0, _url2.url2object)(url),
      protocol = _url2object.protocol,
      hostname = _url2object.hostname,
      path = _url2object.path,
      query = _url2object.query;

  if (typeof options.strip === 'boolean') {
    query['stripmeta'] = options.strip ? 1 : 0;
  }
  if (typeof options.quality === 'number') {
    util.verifyParamMin('quality', options.quality, 0, 'nos::viewImageSync');
    util.verifyParamMax('quality', options.quality, 100, 'nos::viewImageSync');
    query['quality'] = Math.round(options.quality);
  }
  if (typeof options.interlace === 'boolean') {
    query['interlace'] = options.interlace ? 1 : 0;
  }
  if (typeof options.rotate === 'number') {
    query['rotate'] = Math.round(options.rotate);
  }
  // 缩略图模式
  if ((0, _typeof3.default)(options.thumbnail) === 'object') {
    var mode = options.thumbnail.mode || 'crop';
    var width = options.thumbnail.width;
    var height = options.thumbnail.height;
    if (width >= 0 && height >= 0 && width < 4096 && height < 4096) {
      if (width > 0 || height > 0) {
        switch (mode) {
          case 'crop':
            mode = 'y';
            break;
          case 'contain':
            mode = 'x';
            break;
          case 'cover':
            mode = 'z';
            break;
          default:
            mode = 'x';
        }
        query['thumbnail'] = '' + width + mode + height;
      }
    }
  }
  if (linkOptions.downloadUrl) {
    // 拿原来地址的object，bucket
    var objUrl = (0, _url2.url2object)(options.url);
    var downloadUrl = linkOptions.downloadUrl;
    var _url = objUrl.path;
    var index = _url.indexOf('/');
    if (index !== -1) {
      var nosBucket = _url.substring(0, index);
      var nosObj = _url.substring(index + 1);
      downloadUrl = downloadUrl.replace('{bucket}', nosBucket).replace('{object}', nosObj);
    }
    var obj = (0, _url2.url2object)(downloadUrl);
    return (0, _url2.object2url)({
      protocol: obj.protocol,
      hostname: obj.hostname,
      path: obj.path,
      query: util.merge(obj.query, query)
    });
  } else {
    return (0, _url2.object2url)({ protocol: protocol, hostname: hostname, path: path, query: query });
  }
};

ApiBaseFn.viewImageStripMeta = function (options) {
  util.verifyOptions(options, 'url strip', 'nos::viewImageStripMeta');
  util.verifyParamType('strip', options.strip, 'boolean', 'nos::viewImageStripMeta');
  var ps = 'stripmeta=' + (options.strip ? 1 : 0);
  var sep = (0, _url2.genUrlSep)(options.url);
  return options.url + sep + ps;
};

ApiBaseFn.viewImageQuality = function (options) {
  util.verifyOptions(options, 'url quality', 'nos::viewImageQuality');
  util.verifyParamType('quality', options.quality, 'number', 'nos::viewImageQuality');
  util.verifyParamMin('quality', options.quality, 0, 'nos::viewImageQuality');
  util.verifyParamMax('quality', options.quality, 100, 'nos::viewImageQuality');
  var quality = Math.round(options.quality);
  var ps = 'quality=' + quality;
  var sep = (0, _url2.genUrlSep)(options.url);
  return options.url + sep + ps;
};

ApiBaseFn.viewImageInterlace = function (options) {
  util.verifyOptions(options, 'url', 'nos::viewImageInterlace');
  var ps = 'interlace=1';
  var sep = (0, _url2.genUrlSep)(options.url);
  return options.url + sep + ps;
};

ApiBaseFn.viewImageRotate = function (options) {
  util.verifyOptions(options, 'url angle', 'nos::viewImageRotate');
  util.verifyParamType('angle', options.angle, 'number', 'nos::viewImageRotate');
  while (options.angle < 0) {
    options.angle = options.angle + 360;
  }
  options.angle = options.angle % 360;
  var angle = Math.round(options.angle);
  var ps = 'rotate=' + angle;
  var sep = (0, _url2.genUrlSep)(options.url);
  return options.url + sep + ps;
};

ApiBaseFn.viewImageBlur = function (options) {
  util.verifyOptions(options, 'url radius sigma', 'nos::viewImageBlur');
  util.verifyParamType('radius', options.radius, 'number', 'nos::viewImageBlur');
  util.verifyParamMin('radius', options.radius, 1, 'nos::viewImageBlur');
  util.verifyParamMax('radius', options.radius, 50, 'nos::viewImageBlur');
  util.verifyParamType('sigma', options.sigma, 'number', 'nos::viewImageBlur');
  util.verifyParamMin('sigma', options.sigma, 0, 'nos::viewImageBlur');
  var radius = Math.round(options.radius);
  var sigma = Math.round(options.sigma);
  var ps = 'blur=' + radius + 'x' + sigma;
  var sep = (0, _url2.genUrlSep)(options.url);
  return options.url + sep + ps;
};

ApiBaseFn.viewImageCrop = function (options) {
  util.verifyOptions(options, 'url x y width height', 'nos::viewImageCrop');
  util.verifyParamType('x', options.x, 'number', 'nos::viewImageCrop');
  util.verifyParamMin('x', options.x, 0, 'nos::viewImageCrop');
  util.verifyParamType('y', options.y, 'number', 'nos::viewImageCrop');
  util.verifyParamMin('y', options.y, 0, 'nos::viewImageCrop');
  util.verifyParamType('width', options.width, 'number', 'nos::viewImageCrop');
  util.verifyParamMin('width', options.width, 0, 'nos::viewImageCrop');
  util.verifyParamType('height', options.height, 'number', 'nos::viewImageCrop');
  util.verifyParamMin('height', options.height, 0, 'nos::viewImageCrop');
  var x = Math.round(options.x);
  var y = Math.round(options.y);
  var width = Math.round(options.width);
  var height = Math.round(options.height);
  var ps = 'crop=' + x + '_' + y + '_' + width + '_' + height;
  var sep = (0, _url2.genUrlSep)(options.url);
  return options.url + sep + ps;
};

ApiBaseFn.viewImageThumbnail = function () {
  var modes = {
    cover: 'z',
    contain: 'x',
    crop: 'y'
  };
  return function (options) {
    util.verifyOptions(options, 'url mode', 'nos::viewImageThumbnail');
    util.verifyParamValid('mode', options.mode, Object.keys(modes), 'nos::viewImageThumbnail');
    if (options.mode === 'contain') {
      util.verifyParamAtLeastPresentOne(options, 'width height', 'nos::viewImageThumbnail');
    } else {
      util.verifyOptions(options, 'width height', 'nos::viewImageThumbnail');
    }
    if (util.undef(options.width)) {
      options.width = 0;
    }
    if (util.undef(options.height)) {
      options.height = 0;
    }
    util.verifyParamType('width', options.width, 'number', 'nos::viewImageThumbnail');
    util.verifyParamMin('width', options.width, 0, 'nos::viewImageThumbnail');
    util.verifyParamType('height', options.height, 'number', 'nos::viewImageThumbnail');
    util.verifyParamMin('height', options.height, 0, 'nos::viewImageThumbnail');
    var width = Math.round(options.width);
    var height = Math.round(options.height);
    var ps = 'thumbnail=' + width + modes[options.mode] + height;
    if (options.mode === 'crop') {
      if (util.notundef(options.axis)) {
        if (util.undef(options.axis.x)) {
          options.axis.x = 5;
        }
        if (util.undef(options.axis.y)) {
          options.axis.y = 5;
        }
        util.verifyParamMin('axis.x', options.axis.x, 0, 'nos::viewImageThumbnail');
        util.verifyParamMax('axis.x', options.axis.x, 10, 'nos::viewImageThumbnail');
        util.verifyParamMin('axis.y', options.axis.y, 0, 'nos::viewImageThumbnail');
        util.verifyParamMax('axis.y', options.axis.y, 10, 'nos::viewImageThumbnail');
        var x = Math.round(options.axis.x);
        var y = Math.round(options.axis.y);
        ps = ps + '&axis=' + x + '_' + y;
      }
    }
    if (util.notundef(options.enlarge)) {
      util.verifyParamType('enlarge', options.enlarge, 'boolean', 'nos::viewImageThumbnail');
      if (options.enlarge) {
        ps = ps + '&enlarge=1';
      }
    }
    var sep = (0, _url2.genUrlSep)(options.url);
    return options.url + sep + ps;
  };
}();

/***/ }),

/***/ "./src/im/api/base/report.js":
/*!***********************************!*\
  !*** ./src/im/api/base/report.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ApiBaseFn = __webpack_require__(/*! ./index */ "./src/im/api/base/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var ajax = __webpack_require__(/*! utiljs/ajax */ "./src/util/ajax/index.js");
// const reportUrl = process.env.NODE_ENV === 'production' ? 'https://dr.netease.im/1.gif' : 'https://webtest.netease.im/1.gif'
var CONFIG = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var platform = __webpack_require__(/*! platform */ "./src/polyfill/weixin-app/platform.js");

platform = platform || {};
platform.name = platform.name || '';
platform.version = platform.version || '';

ApiBaseFn.reportLogs = function () {
  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var self = this;
  var options = self.options;
  var reportUrl = CONFIG.ntServerAddress;
  if (!reportUrl) {
    return;
  }
  var info = CONFIG.info;
  data = util.merge(data, {
    appkey: options.appKey,
    uid: options.account,
    os: 'web',
    session: self.protocol.sdkSession || '',
    ver: info.sdkVersion,
    type: self.subType,
    platform: '' + platform.name.toLowerCase() + platform.version.replace(/(\.\d+)+$/, '')
  });
  var url = reportUrl + util.genUrlSep(reportUrl);
  var urlArr = [];
  for (var key in data) {
    urlArr.push(key + '=' + data[key]);
  }
  url += urlArr.join('&');
  ajax(url, {
    proxyUrl: util.url2origin(url) + '/lbs/res/cors/nej_proxy_frame.html',
    timeout: CONFIG.xhrTimeout,
    onload: function onload() {},
    onerror: function onerror(error) {
      self.logger.info('report::ajax report error', error);
    }
  });
};

// appkey	当前 App 的 appkey
// uid	当前登录账号 uid ，如果没有则不填
// os
// 客户端系统[ios，aos，pc，web]
// session
// 本地 sessionId(即每次 SDK 初始化时生成的 uuid，用于无 uid 时跟踪会话)
// event
// 当前统计项名
// ver	SDK 版本

/***/ }),

/***/ "./src/im/api/nim/audio.js":
/*!*********************************!*\
  !*** ./src/im/api/nim/audio.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * 音频转文字
 *
 * - 仅支持通过{@link NIM#previewFile|previewFile}或者{@link NIM#sendFile|sendFile}拿到的音频 url, 或者收到的音频消息的 url
 *
 * @memberOf NIM#
 * @method audioToText
 * 
 * @param  {Object} options 配置参数
 * @param {String} options.url 音频 url
 * @param {Function} options.done 结果回调函数, 成功时会额外附上文本 text
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ1MTg5MDI2MjY0MF9lYzk1MWMyZC1hMzRmLTQ1YzctYWI2ZS1kZWE2NTA2M2Q4NjY=';
 * nim.audioToText({
 *     url: url,
 *     done: audioToTextDone
 * });
 * function audioToTextDone(error, obj) {
 *     console.log('语音转文字' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.audioToText = function (options) {
  util.verifyOptions(options, 'url', 'audio::audioToText');
  options.audioToText = util.filterObj(options, 'url');
  var self = this;
  self.processCallback(options);
  self.sendCmd('audioToText', options);
};

/***/ }),

/***/ "./src/im/api/nim/chatroom.js":
/*!************************************!*\
  !*** ./src/im/api/nim/chatroom.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var CONFIG = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");

/**
 * 获取聊天室服务器地址
 *
 * - 可以在 IM 连接上获取聊天室服务器地址
 *
 * @memberOf NIM#
 * @method getChatroomAddress
 *
 * @param  {Object} options 配置参数
 * @param {String} [options.chatroomId] 聊天室 id
 * @return {Void}
 *
 * @example
 * nim.getChatroomAddress({
 *     chatroomId: 'chatroomId',
 *     done: getChatroomAddressDone
 * });
 * function getChatroomAddressDone(error, obj) {
 *     console.log('获取聊天室地址' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.getChatroomAddress = function (options) {
  util.verifyOptions(options, 'chatroomId', 'chatroom::getChatroomAddress');
  var self = this;
  options.isWeixinApp = CONFIG.isWeixinApp;
  self.processCallback(options);
  self.sendCmd('getChatroomAddress', options);
};

/***/ }),

/***/ "./src/im/api/nim/connect.js":
/*!***********************************!*\
  !*** ./src/im/api/nim/connect.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * 是否连接上服务器
 * @private
 * @return {Boolean} 连接状态
 *
 * @see {@link NIM#connect|connect}
 * @see {@link NIM#disconnect|disconnect}
 *
 * @example
 * if (!nim.isConnected()) {
 *     console.log('未连接');
 * }
 */

/**
 * 登录 SDK
 *
 * @memberOf NIM#
 * @method connect
 *
 * @return {Void}
 *
 * @see {@link NIM#disconnect|disconnect}
 *
 * @example
 * nim.connect();
 */

/**
 * 登出 SDK
 *
 * @memberOf NIM#
 * @method disconnect
 *
 * @return {Void}
 *
 * @see {@link NIM#connect|connect}
 *
 * @example
 * nim.disconnect();
 */

/**
 * 踢当前用户登录的其它端
 *
 * @method kick
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String[]}   options.deviceIds   要踢掉的端的设备号数组
 * @param  {done}       options.done        结果回调函数, 成功时会收到被踢掉的设备号数组
 * @return {Void}
 *
 * @example
 * nim.kick({
 *     deviceIds: ['device1'],
 *     done: onKick
 * });
 * function onKick(error, obj) {
 *     console.log('踢其它端' + (!error?'成功':'失败'));
 *     console.log(error);
 *     console.log(obj);
 * }
 */
NIMFn.kick = function (options) {
  util.verifyOptions(options, 'deviceIds', 'link::kick');
  this.processCallback(options);
  this.sendCmd('kick', { deviceIds: options.deviceIds.slice(0) }, options.callback);
};

/***/ }),

/***/ "./src/im/api/nim/db.js":
/*!******************************!*\
  !*** ./src/im/api/nim/db.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;

NIMFn.clearDB = function (options) {
  var self = this;
  var db = self.db;
  self.processCallback(options);
  var done = options.done;
  if (db.enable) {
    db.clear().then(done, done);
  } else {
    done();
  }
};

NIMFn.removeDB = function (options) {
  var self = this;
  var db = self.db;
  self.processCallback(options);
  var done = options.done;
  if (db.enable) {
    db.destroy().then(done, done);
  } else {
    done();
  }
};

NIMFn.closeDB = function (options) {
  var self = this;
  var db = self.db;
  self.processCallback(options);
  var done = options.done;
  if (db.enable) {
    db.close().then(done, done);
  } else {
    done();
  }
};

/***/ }),

/***/ "./src/im/api/nim/eventService.js":
/*!****************************************!*\
  !*** ./src/im/api/nim/eventService.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// const Promise = require('es6-promise').Promise
var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var MsgEvent = __webpack_require__(/*! im/model/msgEvent */ "./src/im/model/msgEvent.js");
var MsgEventSubscribe = __webpack_require__(/*! im/model/msgEventSubscribe */ "./src/im/model/msgEventSubscribe.js");

// 逆转化返回对象的数据格式
function formatReturnEventObj(obj) {
  if ((typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object') {
    if (obj.msgEventSubscribes) {
      obj = obj.msgEventSubscribes;
    } else if (obj.msgEventSubscribe) {
      obj = obj.msgEventSubscribe;
    } else if (obj.accounts) {
      obj = obj.accounts;
    } else if (obj.msgEvent) {
      obj = obj.msgEvent;
      if (obj.time) {
        obj.time = +obj.time;
      }
    }
    if (obj.sync === 1) {
      obj.sync = true;
    } else if (obj.sync === 0) {
      obj.sync = false;
    }
  }
  return obj;
}

// 批量发送事件消息接口，因为accids一次最多只能发100个
// usages: this.batchSendEventsCmds('subscribeEvent', {msgEventSubscribe, accounts: tempAccounts}, callback)
NIMFn.batchSendEventsCmds = function (cmd, options, callback) {
  var self = this;
  // 一次最多请求服务器的accounts数目
  var accidsCount = 100;
  var accountArray = util.dropArrayDuplicates(options.accounts);
  accountArray = util.reshape2d(accountArray, accidsCount);
  var promiseList = [];
  accountArray.forEach(function (tempAccounts) {
    promiseList.push(new Promise(function (resolve, reject) {
      var tempOptions = util.simpleClone(options);
      tempOptions.accounts = tempAccounts;
      self.sendCmdWithResp(cmd, tempOptions, function (err, content) {
        if (err) {
          reject(err);
        } else {
          resolve(formatReturnEventObj(content));
        }
      }); // end this.sendCmd
    }) // end new Promise
    );
  }); // end forEach
  Promise.all(promiseList).then(function (resolve) {
    var result = null;
    if (resolve.length > 0) {
      if (resolve[0].msgEventSubscribe) {
        var msgEventSubscribe = resolve[0].msgEventSubscribe;
        msgEventSubscribe = formatReturnEventObj(msgEventSubscribe);
        var accounts = [];
        resolve.forEach(function (item) {
          accounts = accounts.concat(item.accounts);
        });
        result = { accounts: accounts, msgEventSubscribe: msgEventSubscribe };
      } else {
        result = [];
        resolve.forEach(function (item) {
          result = result.concat(item);
        });
      }
    }
    callback(null, result);
  }, function (error) {
    callback(error, null);
  });
};

/**
 * 发布事件
 *
 * @method publishEvent
 * @memberOf NIM#
 *
 * @param {Object} options    配置参数
 * @param {Int}    options.type    事件类型 必须指定100000以上 由上层做自定义映射
 * @param {Int}    options.value    事件状态/事件内容，由上层做自定义映射
 * @param {String} options.custom [可选]用户自定义事件扩展属性，最长256字节
 * @param {Int}    options.vaildTime [可选]发布事件的有效时间 单位秒 60s~7天(604800s)，默认7天
 * @param {Int} options.broadcastType [可选] 广播类型 1:仅在线 2:在线和离线，默认2(在线和离线)
 * @param {Boolean} options.sync [可选] true:同步给自己，false:不同步给自己，默认false
 * @param {done}   options.done    结果回调函数
 * @return {Void}
 *
 * @callback
 * @param {Object} error
 * @param {Object} msgEvent  回调函数返回事件对象
 * @param {String} msgEvent.idClient 消息标识
 * @param {String} msgEvent.idServer 消息标识
 * @param {String} msgEvent.time 事件发布时间戳
 *
 * @example
 * nim.publishEvent({
 *     type: 100000,
 *     value: 2,
 *     custom: 'hello world',
 *     vaildTime: 60,
 *     sync: false,
 *     done: publishEventDone
 * });
 * function publishEventDone(error, obj) {
 *     console.log('发布事件' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.publishEvent = function (options) {
  var self = this;
  var msgEvent = new MsgEvent(options);
  msgEvent = msgEvent.assembleEvent();
  self.processCallback(options);
  this.sendCmdWithResp('publishEvent', { msgEvent: msgEvent }, function onPublishEvent(err, obj) {
    if (!err) {
      obj = formatReturnEventObj(obj);
    }
    options.callback(err, obj);
  });
};

/**
 * 订阅事件
 *
 * @method subscribeEvent
 * @memberOf NIM#
 *
 * @param {Object} options    配置参数
 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
 * @param {Int}    options.subscribeTime   [可选]订阅关系的有效时间 单位秒 60s~30天(2592000)，默认30天
 * @param {Boolean} options.sync  [可选]订阅后是否立即同步最新事件，true:同步，false:不同步，默认同步
 * @param {Array} options.accounts 订阅好友的账号列表。当accounts元素数量大于100时，SDK会以每100个帐号做为一组事务进行处理，按组并行执行操作(每组操作为一个事务)，任意一组失败都会抛出异常，但之前成功的组不会因后续失败的组而异常回滚；若用户有较强烈的事务处理要求，可多次调用此接口，且每次accounts元素数量小于100，进行上层实现
 * @param {done}   options.done  结果回调函数
 * @return {Void}
 *
 * @callback
 * @param {Object} error
 * @param {Object} result  回调函数返回事件对象
 * @param {StringArray} result.failedAccounts 订阅失败的accounts数组，数组长度为0则全部成功
 *
 * @example
 * nim.subscribeEvent({
 *     type: 100000,
 *     accounts: ['cs3'],
 *     subscribeTime: 70,
 *     sync: true,
 *     done: subscribeEventDone
 * });
 * function subscribeEventDone(error, obj) {
 *     console.log('订阅事件' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.subscribeEvent = function (options) {
  var self = this;
  util.verifyOptions(options, 'accounts', 'event::subscribeEvent');
  // 默认更新后同步吧
  var msgEventSubscribe = new MsgEventSubscribe(options);
  util.verifyParamType('accounts', options.accounts, 'array', 'event::subscribeEvent');
  self.processCallback(options);
  msgEventSubscribe = msgEventSubscribe.assembleEvent();
  // this.sendCmd('subscribeEvent', {msgEventSubscribe, accounts: options.accounts}, options.callback)
  this.batchSendEventsCmds('subscribeEvent', { msgEventSubscribe: msgEventSubscribe, accounts: options.accounts }, function (err, obj) {
    if (!err && obj) {
      obj = { failedAccounts: obj };
    }
    options.callback(err, obj);
  });
};
/**
 * 按账号取消指定事件的订阅关系
 *
 * @method unSubscribeEventsByAccounts
 * @memberOf NIM#
 *
 * @param {Object} options    配置参数
 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
 * @param {Array} options.accounts 取消订阅好友的账号列表。当accounts元素数量大于100时，SDK会以每100个帐号做为一组事务进行处理，按组并行执行操作(每组操作为一个事务)，任意一组失败都会抛出异常，但之前成功的组不会因后续失败的组而异常回滚；若用户有较强烈的事务处理要求，可多次调用此接口，且每次accounts元素数量小于100，进行上层实现
 * @param {done}   options.done  结果回调函数
 * @return {Void}
 *
 * @callback
 * @param {Object} error
 * @param {Object} result  回调函数返回事件对象
 * @param {StringArray} result.failedAccounts 订阅失败的accounts数组，数组长度为0则全部成功
 *
 * @example
 * nim.unSubscribeEventsByAccounts({
 *     type: 100000,
 *     accounts: ['cs3'],
 *     done: unSubscribeEventDone
 * });
 * function unSubscribeEventDone(error, obj) {
 *     console.log('取消订阅事件' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.unSubscribeEventsByAccounts = function (options) {
  var self = this;
  util.verifyOptions(options, 'accounts', 'event::unSubscribeEventsByAccounts');
  util.verifyParamType('accounts', options.accounts, 'array', 'event::unSubscribeEventsByAccounts');
  var msgEventSubscribe = new MsgEventSubscribe(options);
  msgEventSubscribe = msgEventSubscribe.assembleEvent();
  self.processCallback(options);
  // this.sendCmd('unSubscribeEventsByAccounts', {msgEventSubscribe, accounts: options.accounts}, options.callback)
  this.batchSendEventsCmds('unSubscribeEventsByAccounts', { msgEventSubscribe: msgEventSubscribe, accounts: options.accounts }, function (err, obj) {
    if (!err && obj) {
      obj = { failedAccounts: obj };
    }
    options.callback(err, obj);
  });
};
/**
 * 取消指定事件的全部订阅关系
 *
 * @method unSubscribeEventsByType
 * @memberOf NIM#
 *
 * @param {Object} options    配置参数
 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
 * @param {done}   options.done  结果回调函数
 * @return {Void}
 *
 * @callback
 * @param {Object} error
 *
 * @example
 * nim.unSubscribeEventsByType({
 *     type: 100000,
 *     done: unSubscribeEventDone
 * });
 * function unSubscribeEventDone(error, obj) {
 *     console.log('取消订阅事件' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.unSubscribeEventsByType = function (options) {
  var self = this;
  var msgEventSubscribe = new MsgEventSubscribe(options);
  msgEventSubscribe = msgEventSubscribe.assembleEvent();
  self.processCallback(options);
  this.sendCmdWithResp('unSubscribeEventsByType', { msgEventSubscribe: msgEventSubscribe }, function onUnSubscribeEventsByType(err, obj) {
    options.callback(err);
  });
};
/**
 * 按账号获取指定事件的订阅关系
 *
 * @method querySubscribeEventsByAccounts
 * @memberOf NIM#
 *
 * @param {Object} options    配置参数
 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
 * @param {Array} options.accounts 查询订阅好友的账号列表。当accounts元素数量大于100时，SDK会以每100个帐号做为一组事务进行处理，按组并行执行操作(每组操作为一个事务)，任意一组失败都会抛出异常，但之前成功的组不会因后续失败的组而异常回滚；若用户有较强烈的事务处理要求，可多次调用此接口，且每次accounts元素数量小于100，进行上层实现
 * @param {done}   options.done  结果回调函数
 * @return {Void}
 *
 * @callback
 * @param {Object} error
 * @param {Object} result  回调函数返回事件对象
 * @param {ObjectArray} result.msgEventSubscribes 订阅的对象数组
 * @param {String} result.msgEventSubscribes.subscribeTime 订阅关系有效时间
 * @param {String} result.msgEventSubscribes.time 订阅时间
 * @param {String} result.msgEventSubscribes.to 订阅人
 * @param {String} result.msgEventSubscribes.type 订阅类型
 *
 * @example
 * nim.querySubscribeEventsByAccounts({
 *     type: 100000,
 *     accounts: ['cs3'],
 *     done: querySubscribeEventDone
 * });
 * function querySubscribeEventDone(error, obj) {
 *     console.log('获取订阅列表' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.querySubscribeEventsByAccounts = function (options) {
  var self = this;
  util.verifyOptions(options, 'accounts', 'event::querySubscribeEventsByAccounts');
  util.verifyParamType('accounts', options.accounts, 'array', 'event::querySubscribeEventsByAccounts');
  var msgEventSubscribe = new MsgEventSubscribe(options);
  msgEventSubscribe = msgEventSubscribe.assembleEvent();
  self.processCallback(options);
  // this.sendCmd('querySubscribeEventsByAccounts', {msgEventSubscribe, accounts: options.accounts}, options.callback)
  this.batchSendEventsCmds('querySubscribeEventsByAccounts', { msgEventSubscribe: msgEventSubscribe, accounts: options.accounts }, function (err, obj) {
    if (!err && obj) {
      obj = { msgEventSubscribes: obj };
    }
    options.callback(err, obj);
  });
};
/**
 * 查询指定事件的全部订阅关系
 *
 * @method querySubscribeEventsByType
 * @memberOf NIM#
 *
 * @param {Object} options    配置参数
 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
 * @param {done}   options.done  结果回调函数
 * @return {Void}
 *
 * @callback
 * @param {Object} error
 * @param {Object} result  回调函数返回事件对象
 * @param {ObjectArray} result.msgEventSubscribes 订阅的对象数组
 * @param {String} result.msgEventSubscribes.subscribeTime 订阅关系有效时间
 * @param {String} result.msgEventSubscribes.time 订阅时间
 * @param {String} result.msgEventSubscribes.to 订阅人
 * @param {String} result.msgEventSubscribes.type 订阅类型
 *
 * @example
 * nim.querySubscribeEventsByType({
 *     type: 100000,
 *     done: querySubscribeEventDone
 * });
 * function querySubscribeEventDone(error, obj) {
 *     console.log('获取订阅列表' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.querySubscribeEventsByType = function (options) {
  var self = this;
  var msgEventSubscribe = new MsgEventSubscribe(options);
  msgEventSubscribe = msgEventSubscribe.assembleEvent();
  self.processCallback(options);
  this.sendCmdWithResp('querySubscribeEventsByType', { msgEventSubscribe: msgEventSubscribe }, function onQuerySubscribeEventsByType(err, obj) {
    if (!err) {
      obj = { msgEventSubscribes: formatReturnEventObj(obj) };
    }
    options.callback(err, obj);
  });
};

/***/ }),

/***/ "./src/im/api/nim/friend.js":
/*!**********************************!*\
  !*** ./src/im/api/nim/friend.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var Friend = __webpack_require__(/*! im/model/friend */ "./src/im/model/friend.js");

/**
 * 好友请求
 *
 * - 此接口可以完成以下四个功能, 通过参数`type`来决定实际的功能, `type`可取的值有以下几种
 *     - `'addFriend'` (直接加为好友)
 *         - {@link NIM#addFriend|直接加某个用户为好友}后, 对方不需要确认, 直接成为当前登录用户的好友。
 *         - 对方会收到一条类型为`'addFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号。
 *     - `'applyFriend'` (申请加为好友)
 *         - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
 *     - `'passFriendApply'` (通过好友申请)
 *         - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
 *     - `'rejectFriendApply'` (拒绝好友申请)
 *         - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
 * - 每个功能SDK也提供了相应的独立接口
 *
 * @private
 * @method friendRequest
 * @memberOf NIM#
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.type    {@link Friend.requestType|好友请求类型}
 * @param  {String} options.account 账号
 * @param  {String} [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param  {done}   options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#rejectFriendApply|直接加为好友}
 * @see {@link NIM#applyFriend|申请加为好友}
 * @see {@link NIM#passFriendApply|通过好友申请}
 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
 * @see {@link NIM#deleteFriend|删除好友}
 * @see {@link NIM#updateFriend|更新好友}
 * @see {@link NIM#getFriends|获取好友列表}
 */
NIMFn.friendRequest = function (options) {
  util.verifyOptions(options, 'type account', 'friend::friendRequest');
  util.verifyParamValid('type', options.type, Friend.validTypes(), 'friend::friendRequest');
  this.processPs(options);
  this.processCallback(options);
  var content = {
    account: options.account,
    type: Friend.getByteFromType(options.type),
    ps: options.ps
  };
  if (notundef(options.idServer)) {
    content.idServer = options.idServer;
  }
  this.sendCmd('friendRequest', content, options.callback);
};
/**
 * 直接加为好友
 *
 * - {@link NIM#addFriend|直接加某个用户为好友}后, 对方不需要确认, 直接成为当前登录用户的好友。
 * - 对方会收到一条类型为`'addFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号。
 *
 * @method addFriend
 * @memberOf NIM#
 *
 * @param {Object}  options         配置参数
 * @param {String}  options.account 要直接加为好友的账号
 * @param {String}  [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param {done}    options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#applyFriend|申请加为好友}
 * @see {@link NIM#passFriendApply|通过好友申请}
 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
 * @see {@link NIM#deleteFriend|删除好友}
 * @see {@link NIM#updateFriend|更新好友}
 * @see {@link NIM#getFriends|获取好友列表}
 *
 * @example
 * nim.addFriend({
 *     account: 'account',
 *     ps: 'ps',
 *     done: addFriendDone
 * });
 * function addFriendDone(error, obj) {
 *     console.log('直接加为好友' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onAddFriend(obj.friend);
 *     }
 * }
 */
NIMFn.addFriend = function (options) {
  options.type = 'addFriend';
  this.friendRequest(options);
};
/**
 * 申请加为好友
 *
 * - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
 *     - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
 *     - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
 *
 * @method applyFriend
 * @memberOf NIM#
 *
 * @param {Object}  options         配置参数
 * @param {String}  options.account 要申请加为好友的账号
 * @param {String}  [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param {done}    options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#applyFriend|直接加为好友}
 * @see {@link NIM#passFriendApply|通过好友申请}
 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
 * @see {@link NIM#deleteFriend|删除好友}
 * @see {@link NIM#updateFriend|更新好友}
 * @see {@link NIM#getFriends|获取好友列表}
 *
 * @example
 * nim.applyFriend({
 *     account: 'account',
 *     ps: 'ps',
 *     done: applyFriendDone
 * });
 * function applyFriendDone(error, obj) {
 *     console.log('申请加为好友' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.applyFriend = function (options) {
  options.type = 'applyFriend';
  this.friendRequest(options);
};
/**
 * 通过好友申请
 *
 * - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
 *     - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
 *     - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
 *
 * @method passFriendApply
 * @memberOf NIM#
 *
 * @param {Object}  options             配置参数
 * @param {String}  options.idServer    对应的系统通知的 `idServer`
 * @param {String}  options.account     要通过好友申请的账号
 * @param {String}  [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param {done}    options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#passFriendApply|直接加为好友}
 * @see {@link NIM#applyFriend|申请加为好友}
 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
 * @see {@link NIM#deleteFriend|删除好友}
 * @see {@link NIM#updateFriend|更新好友}
 * @see {@link NIM#getFriends|获取好友列表}
 *
 * @example
 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
 * nim.passFriendApply({
 *     idServer: sysMsg.idServer,
 *     account: 'account',
 *     ps: 'ps',
 *     done: passFriendApplyDone
 * });
 * function passFriendApplyDone(error, obj) {
 *     console.log('通过好友申请' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onAddFriend(obj.friend);
 *     }
 * }
 */
NIMFn.passFriendApply = function (options) {
  util.verifyOptions(options, 'idServer', 'friend::passFriendApply');
  options.type = 'passFriendApply';
  this.friendRequest(options);
};
/**
 * 拒绝好友申请
 *
 * - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
 *     - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
 *     - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
 *
 * @method rejectFriendApply
 * @memberOf NIM#
 *
 * @param {Object}  options             配置参数
 * @param {String}  options.idServer    对应的系统通知的 `idServer`
 * @param {String}  options.account     要拒绝好友申请的账号
 * @param {String}  [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param {done}    options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#rejectFriendApply|直接加为好友}
 * @see {@link NIM#applyFriend|申请加为好友}
 * @see {@link NIM#passFriendApply|通过好友申请}
 * @see {@link NIM#deleteFriend|删除好友}
 * @see {@link NIM#updateFriend|更新好友}
 * @see {@link NIM#getFriends|获取好友列表}
 *
 * @example
 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
 * nim.rejectFriendApply({
 *     idServer: sysMsg.idServer,
 *     account: 'account',
 *     ps: 'ps',
 *     done: rejectFriendApplyDone
 * });
 * function rejectFriendApplyDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('拒绝好友申请' + (!error?'成功':'失败'));
 * }
 */
NIMFn.rejectFriendApply = function (options) {
  util.verifyOptions(options, 'idServer', 'friend::rejectFriendApply');
  options.type = 'rejectFriendApply';
  this.friendRequest(options);
};
/**
 * 删除好友
 *
 * - {@link NIM#deleteFriend|删除好友}后, 被删除的人会收到一条类型为`'deleteFriend'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为删除方的帐号, `to`字段的值为被删除方的账号。
 *
 * @method deleteFriend
 * @memberOf NIM#
 *
 * @param {Object}  options          配置参数
 * @param {String}  options.account  要删除好友的账号
 * @param {Boolean} options.delAlias 是否要删除好友的备注，默认`false`不删除
 * @param {done}    options.done     结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#deleteFriend|直接加为好友}
 * @see {@link NIM#applyFriend|申请加为好友}
 * @see {@link NIM#passFriendApply|通过好友申请}
 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
 * @see {@link NIM#updateFriend|更新好友}
 * @see {@link NIM#getFriends|获取好友列表}
 *
 * @example
 * nim.deleteFriend({
 *     account: 'account',
 *     delAlias: true,
 *     done: deleteFriendDone
 * });
 * function deleteFriendDone(error, obj) {
 *     console.log('删除好友' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onDeleteFriend(obj.account);
 *     }
 * }
 */
NIMFn.deleteFriend = function (options) {
  util.verifyOptions(options, 'account', 'friend::deleteFriend');
  var delAlias = options.delAlias === true;
  this.processCallback(options);
  this.sendCmd('deleteFriend', {
    account: options.account,
    delFriendParams: {
      delAlias: delAlias ? 1 : 0
    }
  }, options.callback);
};
/**
 * 更新好友
 *
 * - 开发者可以用此接口来更新好友的备注
 * - 开发者也可以使用JSON格式的扩展字段来进行扩展
 *
 * @method updateFriend
 * @memberOf NIM#
 *
 * @param {Object}  options             配置参数
 * @param {String}  options.account     要更新的好友的account
 * @param {String}  [options.alias]     备注
 * @param {String}  [options.custom]    扩展字段, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param {done}    options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#updateFriend|直接加为好友}
 * @see {@link NIM#applyFriend|申请加为好友}
 * @see {@link NIM#passFriendApply|通过好友申请}
 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
 * @see {@link NIM#deleteFriend|删除好友}
 * @see {@link NIM#getFriends|获取好友列表}
 *
 * @example
 * nim.updateFriend({
 *     account: 'account',
 *     alias: 'alias',
 *     custom: 'custom',
 *     done: updateFriendDone
 * });
 * function updateFriendDone(error, obj) {
 *     console.log('更新好友' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onUpdateFriend(obj);
 *     }
 * }
 */
NIMFn.updateFriend = function (options) {
  this.processCallback(options);
  var friend = new Friend(options);
  this.sendCmd('updateFriend', { friend: friend, single: true }, options.callback);
};
/**
 * 获取好友列表
 *
 * - 如果开发者在{@link NIM|初始化SDK}的时候设置了`syncFriends`为`false`, 那么就收不到`onfriends`回调, 可以调用此接口来获取好友列表。
 *
 * @method getFriends
 * @memberOf NIM#
 *
 * @param {Object}  options         配置参数
 * @param {done}    options.done    结果回调函数, 成功的时候会收到{@link Friend|好友}列表
 * @return {Void}
 *
 * @see {@link NIM#addFriend|直接加为好友}
 * @see {@link NIM#applyFriend|申请加为好友}
 * @see {@link NIM#passFriendApply|通过好友申请}
 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
 * @see {@link NIM#deleteFriend|删除好友}
 * @see {@link NIM#updateFriend|更新好友}
 *
 * @example
 * nim.getFriends({
 *     done: getFriendsDone
 * });
 * function getFriendsDone(error, friends) {
 *     console.log('获取好友列表' + (!error?'成功':'失败'), error, friends);
 *     if (!error) {
 *         onFriends(friends);
 *     }
 * }
 */
NIMFn.getFriends = function (options) {
  var self = this;
  var db = self.db;
  var timetag = 0;
  util.verifyOptions(options);
  self.processCallback(options);
  if (db.enable) {
    db.getFriendsTimetag().then(function (t) {
      timetag = t;
      getFriendsFromServer();
    }, getFriendsFromServer);
  } else {
    getFriendsFromServer();
  }
  function getFriendsFromServer() {
    self.sendCmd('getFriends', { timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
  }
};

/***/ }),

/***/ "./src/im/api/nim/index.js":
/*!*********************************!*\
  !*** ./src/im/api/nim/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ApiBase = __webpack_require__(/*! im/api/base */ "./src/im/api/base/index.js");
var Protocol = __webpack_require__(/*! im/protocol/im */ "./src/im/protocol/im/index.js");
var config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var IMMessage = __webpack_require__(/*! im/model/message/im */ "./src/im/model/message/im/index.js");
var parser = __webpack_require__(/*! im/protocol/parser */ "./src/im/protocol/parser/index.js").IM;

/**
 * 请使用 {@link NIM.getInstance} 来初始化 SDK.
 * 此接口为单例模式, 对于同一个账号, 永远返回同一份实例, 即只有第一次调用会初始化一个实例, 后续调用此接口会直接返回初始化过的实例.
 * @class
 */
function NIM(options) {
  var self = this;
  self.subType = 'im';
  self.nosScene = options.nosScene || 'im';
  self.nosSurvivalTime = options.nosSurvivalTime;
  // init
  options.Protocol = Protocol;
  options.Message = IMMessage;
  options.constructor = NIM;
  return self.init(options);
}

NIM.Protocol = Protocol;
NIM.parser = parser;
NIM.use = ApiBase.use;

/**
 * - 此接口为单例模式, 对于同一个账号, 永远返回同一份实例, 即只有第一次调用会初始化一个实例
 * - 后续调用此接口会直接返回初始化过的实例, 同时也会调用接口{@link NIM#setOptions|setOptions}更新传入的配置
 * - 后续调用此接口时, 如果连接已断开, 会自动建立连接
 * - 当发生掉线时，SDK会自动进行重连
 *
 * @method getInstance
 * @memberOf NIM
 *
 * @param {Object}              options                                 配置参数
 * @param {Boolean|Object}      [options.debug=false]                   是否开启调试, 如果开启调试, 将会在控制台输出一些log。默认`false`不输出日志, 可以传`true`来开启日志。
 * @param {Function|Object}      [options.logFunc=null]                 是否对日志做额外的处理，诸如日志存储、日志上报等等，该函数会截获console日志的参数，供开发者使用
 * @param {Boolean|Object}      [options.secure=true]                   secure 模式下会通过 https 协议跟服务器建立连接, 非 secure 模式下会通过 http 协议跟服务器建立连接, 默认 true

 * @param {String}              options.appKey                          在云信管理后台查看应用的 appKey
 * @param {String}              options.account                         帐号, 应用内唯一
 * @param {String}              options.token                           帐号的 token, 用于建立连接
 * @param {String}              [options.nosScenes='im']                nos文件存储全局配置，存储场景，实例有效，默认im
 * @param {Number}              [options.nosSurvivalTime=Infinity]      nos文件存储全局配置，存储有效时间，实例有效，默认Infinity 不得小于一天，单位秒
 * @param {Function}            [options.onconnect]                     连接建立后的回调, 会传入一个对象, 包含登录的信息, 有以下字段
 * - `lastLoginDeviceId`: 上次登录的设备的设备号
 * - `customTag`: 客户端自定义tag,登录时多端同步改字段，最大32个字符
 * - `connectionId`: 本次登录的连接号
 * - `ip`: 客户端IP
 * - `port`: 客户端端口
 * - `country`: 本次登录的国家
 * @param {Function}            [options.onwillreconnect]                 即将重连的回调
 * - 此时说明 SDK 已经断开连接, 请开发者在界面上提示用户连接已断开, 而且正在重新建立连接
 * - 此回调会收到一个对象, 包含额外的信息, 有以下字段
 *     - `duration`: 距离下次重连的时间
 *     - `retryCount`: 重连尝试的次数
 * @param {Function}            [options.ondisconnect]                  断开连接后的回调
 * - 此时说明 SDK 处于断开状态, 开发者此时应该根据错误码提示相应的错误信息, 并且跳转到登录页面
 * - 此回调会收到一个对象, 包含错误的信息, 有以下字段
 *     - `code`: 出错时的错误码, 可能为空
 *         - `302`: 账号或者密码错误, 请跳转到登录页面并提示错误
 *         - `417`: 重复登录, 已经在其它端登录了, 请跳转到登录页面并提示错误
 *         - `'kicked'`: 被踢
 * - 当`code`为`'kicked'`的时候, 此对象会有以下字段
 *     - `reason`: 被踢的原因
 *         - `samePlatformKick`: 不允许同一个帐号在多个地方同时登录
 *         - `serverKick`: 被服务器踢了
 *         - `otherPlatformKick`: 被其它端踢了
 *     - `message`: 文字描述的被踢的原因
 * @param {Function}            [options.onerror]                       发生错误的回调, 会传入{@link NIMError|错误}对象

 * @param {Function}            [options.onloginportschange]            多端登录状态变化的回调, 会收到{@link LoginPort|登录端}列表, 以下情况会收到此回调
 * - 登录时其它端在线
 * - 登录后其它端上线或者下线
 *
 * @param {Boolean}             [options.syncRelations=true]            是否同步黑名单和静音列表, 默认`true`. 如果传`false`就收不到黑名单和静音列表, 即不会收到`onblacklist`回调和`onmutelist`回调, 开发者后续可以调用{@link NIM#getRelations|获取黑名单和静音列表}来获取黑名单和静音列表。
 * @param {Function}            [options.onblacklist]                   同步黑名单的回调, 会传入黑名单列表`blacklist`
 * - `blacklist`的属性`invalid`包含被删除的黑名单列表
 * - 此回调是增量回调, 可以调用{@link NIM#mergeRelations|nim.mergeRelations}和{@link NIM#cutRelations|nim.cutRelations}来合并数据
 * @param {Function}            [options.onsyncmarkinblacklist]         当前登录用户在其它端{@link NIM#markInBlacklist|加入黑名单/从黑名单移除}后的回调, 会传入一个参数, 包含两个字段
 * - `account`: 要加入黑名单/从黑名单移除的账号
 * - `isAdd`: `true`表示加入黑名单, `false`表示从黑名单移除
 * @param {Function}            [options.onmutelist]                    同步静音列表的回调, 会传入静音列表`mutelist`
 * - `mutelist`的属性`invalid`包含被删除的静音列表
 * - 此回调是增量回调, 可以调用{@link NIM#mergeRelations|nim.mergeRelations}和{@link NIM#cutRelations|nim.cutRelations}来合并数据
 * @param {Function}            [options.onsyncmarkinmutelist]          当前登录用户在其它端{@link NIM#markInMutelist|加入静音列表/从静音列表移除}后的回调, 会传入一个参数, 包含两个字段
 * - `account`: 要加入黑名单/从黑名单移除的账号
 * - `isAdd`: `true`表示加入静音列表, `false`表示从静音列表移除
 *
 * @param {Boolean}             [options.syncFriends]                   是否同步好友列表, 默认`true`. 如果传`false`就收不到`onfriends`回调, 开发者后续可以调用{@link NIM#getFriends|获取好友列表}来获取好友列表。
 * @param {Function}            [options.onfriends]                     同步好友列表的回调, 会传入好友列表。没有好友时，使用数据库会调用回调传空数组，否则不回调。
 * @param {Function}            [options.onsyncfriendaction]           当前登录用户在其它端进行好友相关的操作后的回调
 * - 操作包括
 *     - {@link NIM#addFriend|直接加为好友}
 *     - {@link NIM#applyFriend|申请加为好友}
 *     - {@link NIM#passFriendApply|通过好友申请}
 *     - {@link NIM#rejectFriendApply|拒绝好友申请}
 *     - {@link NIM#deleteFriend|删除好友}
 *     - {@link NIM#updateFriend|更新好友}
 * - 此回调会收到一个参数`obj`, 它有一个字段`type`的值为操作的类型, 具体类型如下：
 *     - `'addFriend'` (直接加为好友), 此时`obj`的字段如下:
 *         - `account`的值为被直接加为好友的账号
 *         - `friend`为被直接加为好友的{@link Friend|好友对象}
 *         - `ps`为附言
 *     - `'applyFriend'` (申请加为好友), 此时`obj`的字段如下:
 *         - `account`的值为被申请加为好友的账号
 *         - `ps`为附言
 *     - `'passFriendApply'` (通过好友申请), 此时`obj`的字段如下:
 *         - `account`的值为被通过好友申请的账号
 *         - `friend`为被通过好友申请的{@link Friend|好友对象}
 *         - `ps`为附言
 *     - `'rejectFriendApply'` (拒绝好友申请), 此时`obj`的字段如下:
 *         - `account`的值为被拒绝好友申请的账号
 *         - `ps`为附言
 *     - `'deleteFriend'` (删除好友), 此时`obj`的字段如下:
 *         - `account`的值为被删除好友的账号
 *     - `'updateFriend'` (更新好友), 此时`obj`的字段如下:
 *         - `friend`的值为被更新的{@link Friend|好友对象}
 *
 * @param {Function}            [options.onmyinfo]                      同步登录用户名片的回调, 会传入{@link User|用户名片}
 * @param {Function}            [options.onupdatemyinfo]                当前登录用户在其它端修改自己的个人名片之后的回调, 会传入{@link User|用户名片}
 * @param {Boolean} [options.syncFriendUsers] 是否同步好友对应的用户名片列表, 默认`true`, 如果传`false`就收不到`onusers`回调.
 * @param {Function}            [options.onusers]                       同步好友用户名片的回调, 会传入{@link User|用户名片}数组
 * @param {Function}            [options.onupdateuser]                  用户名片更新后的回调, 会传入{@link User|用户名片}
 *
 * @param {Boolean}             [options.syncSuperTeams=true]           是否同步超大群列表, 默认`true`. 如果传`false`就收不到群列表, 即不会收到`onSuperTeams`回调, 开发者后续可以调用{@link NIM#getSuperTeams|获取超大群列表}来获取群列表.
 * @param {Function}            [options.onSuperTeams]                  同步超大群列表的回调, 会传入{@link SuperTeam|超大群}数组
 * @param {Function}            [options.onSyncCreateSuperTeam]              当前登录者创建超大群后的回调, 会传入{@link SuperTeam|超大群}
 * @param {Function}            [options.onUpdateSuperTeam]                  更新超大群的回调, 此方法接收一个参数, 更新后的群信息
 * @param {Function}            [options.onUpdateSuperTeamMember]            群成员信息更新后的回调, 会传入{@link SuperTeamMember|超大群群成员}对象, 不过此时的信息是不完整的, 只会包括被更新的字段。当前登录帐号在其它端修改自己在群里面的昵称时也会收到此回调
 * @param {Function}            [options.onAddSuperTeamMembers]              新成员入超大群的回调, 此方法接收一个参数, 包含群信息和群成员信息
 * @param {Function}            [options.onRemoveSuperTeamMembers]           有人出超大群的回调, 此方法接收一个参数, 包含群信息和被移除的群成员账号
 * @param {Function}            [options.onDismissSuperTeam]            超大群解散的回调, 所有群成员均会收到该回调。此方法接收一个参数, 包含被解散的群id
 * 
 * @param {Boolean}             [options.syncTeams=true]                是否同步群列表, 默认`true`. 如果传`false`就收不到群列表, 即不会收到`onteams`回调, 开发者后续可以调用{@link NIM#getTeams|获取群列表}来获取群列表.
 * @param {Boolean} [options.syncExtraTeamInfo] 是否同步额外的群信息, 默认`true`会同步额外的群信息, 目前包括
 * - 当前登录用户是否开启某个群的消息提醒 (SDK 只是存储了此信息, 具体用此信息来做什么事情完全由开发者控制)
 * - 调用接口{@link NIM#updateInfoInTeam}来关闭/开启某个群的消息提醒
 * - 调用接口{@link NIM#notifyForNewTeamMsg}来查询是否需要群消息通知
 * @param {Function}            [options.onteams]                       同步群列表的回调, 会传入{@link Team|群}数组`teams`
 * - `teams`的属性`invalid`包含退出的群
 * @param {Function}            [options.onsynccreateteam]              当前登录用户在其它端{@link NIM#createTeam|创建群}后的回调, 会传入{@link Team|群对象}
 * @param {Boolean}             [options.syncTeamMembers=true]          是否同步群成员, 默认`true`. 只有在`syncTeams`=`true`的时候才起作用, 如果传`false`就不会同步群成员, 即不会收到`onteammembers`和`onsyncteammembersdone`回调, 开发者后续可以调用{@link NIM#getTeamMembers|获取群成员}来获取群成员.
 * @param {Function}            [options.onteammembers]                 同步群成员的回调, 一个群对应一个回调, 会传入{@link TeamMember|群成员}数组
 * @param {Function}            [options.onsyncteammembersdone]         当`syncTeams`和`syncTeamMembers`同时为true时, 会同步所有群的群成员, 当所有群的群成员同步结束时, 会调用此回调
 * @param {Function}            [options.onupdateteammember]            群成员信息更新后的回调, 会传入{@link TeamMember|群成员}对象, 不过此时的信息是不完整的, 只会包括被更新的字段。当前登录帐号在其它端修改自己在群里面的昵称时也会收到此回调。
 * @param {Function} [options.onCreateTeam] 创建群的回调, 此方法接收一个参数, 包含群信息和群主信息
 * @param {Function} [options.onUpdateTeam] 更新群的回调, 此方法接收一个参数, 更新后的群信息
 * @param {Function} [options.onAddTeamMembers] 新成员入群的回调, 此方法接收一个参数, 包含群信息和群成员信息
 * @param {Function} [options.onRemoveTeamMembers] 有人出群的回调, 此方法接收一个参数, 包含群信息和群成员账号
 * @param {Function} [options.onUpdateTeamManagers] 更新群管理员的回调, 此方法接收一个参数, 包含群信息和管理员信息
 * @param {Function} [options.onDismissTeam] 解散群的回调, 此方法接收一个参数, 包含被解散的群id
 * @param {Function} [options.onTransferTeam] 移交群的回调, 此方法接收一个参数, 包含群信息和新老群主信息
 * @param {Function} [options.onUpdateTeamMembersMute] 更新群成员禁言状态的回调, 此方法接收一个参数, 包含群信息和禁言状态信息
 *
 * @param {Boolean}  [options.syncSessionUnread=false] 是否同步会话的未读数, 默认不同步
 * - 如果选择同步
 *   - 那么在一个端读过的会话在其它端也会被标记为已读
 *   - 在调用{@link NIM#setCurrSession}的时候 SDK 会自动同步一次未读数, 此后如果收到当前会话的消息, 需要手动调用{@link NIM#resetSessionUnread}来同步未读数
 * @param {Function}            [options.onsessions]                    同步最近会话列表回调, 会传入{@link Session|会话}列表, 按时间正序排列, 即最近聊过天的放在列表的最后面。
 * @param {Function}            [options.onupdatesession]               更新会话的回调, 会传入{@link Session|会话}, 以下情况会收到此回调
 * - 收到消息
 * - 发送消息
 * - 设置当前会话
 * - 重置会话未读数
 *
 * @param {Function} [options.shouldIgnoreNotification] 是否要忽略某条通知类消息, 该方法会接收一个消息对象, 如果该方法返回 true, 那么 SDK 将忽略此条通知类消息
 * @param {Function} [options.shouldCountTeamNotifyUnread] 是否群通知消息记未读
 * @param {Boolean}             [options.syncRoamingMsgs=true]          是否同步漫游消息, 默认`true`. 如果传`false`就收不到漫游消息, 即不会收到`onroamingmsgs`回调.
 * @param {Boolean}             [options.syncSuperTeamRoamingMsgs=true] 是否额外同步大群漫游消息, 默认`true`. 如果传`false`就不会收到超大群的 `onroamingmsgs` 回调.
 * @param {Function}            [options.onroamingmsgs]                 同步漫游消息(包括超大群漫游消息和其他漫游消息)的回调, 每个会话对应一个回调, 会传入{@link IMMessage|消息}数组
 * @param {Function}            [options.onofflinemsgs]                 同步离线消息的回调, 每个会话对应一个回调, 会传入{@link IMMessage|消息}数组
 * @param {Function}            [options.onmsg]                         收到消息的回调, 会传入{@link IMMessage|消息}对象
 * - 当前登录帐号在其它端发送消息之后也会收到此回调, 注意此时消息对象的`from`字段就是当前登录的帐号
 * @param {Boolean} [options.syncMsgReceipts] 是否同步已读回执时间戳, 默认`true`. 如果传`false`就收不到已读回执时间戳.
 *
 * @param {Function}            [options.onofflinesysmsgs]              同步离线系统通知的回调, 会传入{@link SystemMessage|系统通知}数组
 * @param {Function}            [options.onroamingsysmsgs]              同步漫游系统通知的回调, 会传入{@link SystemMessage|系统通知}数组
 * @param {Function}            [options.onsysmsg]                      收到系统通知的回调, 会传入{@link SystemMessage|系统通知}
 * @param {Function}            [options.onupdatesysmsg]                更新系统通知后的回调, 会传入{@link SystemMessage|系统通知}
 * - 以下情况会收到此回调
 *     - {@link NIM#passFriendApply|通过好友申请}
 *     - {@link NIM#rejectFriendApply|拒绝好友申请}
 *     - {@link NIM#acceptTeamInvite|接受入群邀请}
 *     - {@link NIM#rejectTeamInvite|拒绝入群邀请}
 *     - {@link NIM#passTeamApply|通过入群申请}
 *     - {@link NIM#rejectTeamApply|拒绝入群申请}
 * - 这些操作的发起方会收到此回调, 接收被更新的系统通知, 根据操作的类型系统通知会被更新为下面两种状态
 *     - `'passed'`: 已通过
 *     - `'rejected'`: 已拒绝
 * @param {Function}            [options.onsysmsgunread]                收到系统通知未读数的回调
 * - SDK 会管理内建系统通知的未读数, 此回调接收的对象包括以下字段
 *     - `total`: 总共的未读数
 *     - `friend`: 所有跟好友相关的系统通知的未读数
 *     - `addFriend`: 直接加为好友的未读数
 *     - `applyFriend`: 申请加为好友的未读数
 *     - `passFriendApply`: 通过好友申请的未读数
 *     - `rejectFriendApply`: 拒绝好友申请的未读数
 *     - `deleteFriend`: 删除好友的未读数
 *     - `team`: 所有跟群相关的系统通知的未读数
 *     - `teamInvite`: 入群邀请的未读数
 *     - `rejectTeamInvite`: 接受入群邀请的未读数
 *     - `applyTeam`: 入群申请的未读数
 *     - `rejectTeamApply`: 拒绝入群申请的未读数
 * @param {Function}            [options.onupdatesysmsgunread]          更新系统通知未读数的回调
 * @param {Function}            [options.onofflinecustomsysmsgs]        同步离线自定义系统通知的回调, 会传入{@link SystemMessage|系统通知}数组
 * @param {Function}            [options.oncustomsysmsg]                收到自定义系统通知的回调, 会传入{@link SystemMessage|系统通知}
 *
 * @param {Function}            [options.onsyncdone]                    当上面各个同步（不包括下面的同步群成员）完成后, 会调用此回调；注意, SDK保证在`onsyncdone`调用的时候上面的同步肯定完成了, 但是不保证各个同步回调的顺序。
 *
 * @param {Boolean} [options.autoMarkRead=true] 是否自动标记消息为已收到
 * - 默认情况下SDK在收到服务器推送过来的消息后, 会在将消息推给开发者时将消息标记为已读状态, 下次登录后就不会收到标记为已读的消息。
 *     - SDK通过`onofflinemsgs`、`onofflinesysmsgs`、`onofflinecustomsysmsgs`等回调将离线消息推送给开发者
 *     - SDK通过`onmsg`、`onsysmsg`、`oncustomsysmsg`等回调将在线消息推送给开发者
 * - 如果开发者想控制标记消息为已收到的时机, 那么可以传`false`, 这样SDK就不会自动标记消息已读, 此时需要开发者在适当的时机调用相关的方法来标记消息为已读, 否则下次登录后还会收到未标记为已读的消息。
 *     - 调用{@link NIM#markSysMsgRead|标记系统通知已读}来标记{@link SystemMessage|系统通知}和{@link SystemMessage.type|自定义系统通知}为已读状态
 *
 * @param {Boolean} [options.db=true] 是否使用数据库
 * - 在支持数据库的浏览器上 SDK 会将数据缓存到数据库中, 后续同步都是增量更新, 加快初始化速度
 * - 如果开发者不想使用数据库, 那么可以设置`db`为`false`来禁用数据库
 *
 * @example
 * var data = {};
 * var nim = new NIM({
 *     // 初始化SDK
 *     // debug: true
 *     appKey: 'appKey',
 *     account: 'account',
 *     token: 'token',
 *     onconnect: onConnect,
 *     onerror: onError,
 *     onwillreconnect: onWillReconnect,
 *     ondisconnect: onDisconnect,
 *     // 多端
 *     onloginportschange: onLoginPortsChange,
 *     // 用户关系
 *     onblacklist: onBlacklist,
 *     onsyncmarkinblacklist: onMarkInBlacklist,
 *     onmutelist: onMutelist,
 *     onsyncmarkinmutelist: onMarkInMutelist,
 *     // 好友关系
 *     onfriends: onFriends,
 *     onsyncfriendaction: onSyncFriendAction,
 *     // 用户名片
 *     onmyinfo: onMyInfo,
 *     onupdatemyinfo: onUpdateMyInfo,
 *     onusers: onUsers,
 *     onupdateuser: onUpdateUser,
 *     // 超大群
 *     onSuperTeams: onSuperTeams,
 *     onSyncCreateSuperTeam: onSyncCreateSuperTeam,
 *     onDismissSuperTeam: onDismissSuperTeam, 
 *     onUpdateSuperTeamMember: onUpdateSuperTeamMember,
 *     onUpdateSuperTeam: onUpdateSuperTeam, // 更新超大群的回调
 *     onAddSuperTeamMembers: onAddSuperTeamMembers, // 新成员入超大群的回调
 *     onRemoveSuperTeamMembers: onRemoveSuperTeamMembers
 *     // 群组
 *     onteams: onTeams,
 *     onsynccreateteam: onCreateTeam,
 *     onteammembers: onTeamMembers,
 *     onsyncteammembersdone: onSyncTeamMembersDone,
 *     onupdateteammember: onUpdateTeamMember,
 *     // 会话
 *     onsessions: onSessions,
 *     onupdatesession: onUpdateSession,
 *     // 消息
 *     onroamingmsgs: onRoamingMsgs,
 *     onofflinemsgs: onOfflineMsgs,
 *     onmsg: onMsg,
 *     // 系统通知
 *     onofflinesysmsgs: onOfflineSysMsgs,
 *     onsysmsg: onSysMsg,
 *     onupdatesysmsg: onUpdateSysMsg,
 *     onsysmsgunread: onSysMsgUnread,
 *     onupdatesysmsgunread: onUpdateSysMsgUnread,
 *     onofflinecustomsysmsgs: onOfflineCustomSysMsgs,
 *     oncustomsysmsg: onCustomSysMsg,
 *     // 同步完成
 *     onsyncdone: onSyncDone
 * });
 *
 * function onConnect() {
 *     console.log('连接成功');
 * }
 * function onWillReconnect(obj) {
 *     // 此时说明 `SDK` 已经断开连接, 请开发者在界面上提示用户连接已断开, 而且正在重新建立连接
 *     console.log('即将重连', obj);
 * }
 * function onDisconnect(error) {
 *     // 此时说明 `SDK` 处于断开状态, 开发者此时应该根据错误码提示相应的错误信息, 并且跳转到登录页面
 *     console.log('连接断开', error);
 *     if (error) {
 *         switch (error.code) {
 *         // 账号或者密码错误, 请跳转到登录页面并提示错误
 *         case 302:
 *             break;
 *         // 重复登录, 已经在其它端登录了, 请跳转到登录页面并提示错误
 *         case 417:
 *             break;
 *         // 被踢, 请提示错误后跳转到登录页面
 *         case 'kicked':
 *             break;
 *         default:
 *             break;
 *         }
 *     }
 * }
 * function onError(error, obj) {
 *     console.log('发生错误', error, obj);
 * }
 *
 * function onLoginPortsChange(loginPorts) {
 *     console.log('当前登录帐号在其它端的状态发生改变了', loginPorts);
 * }
 *
 * function onBlacklist(blacklist) {
 *     console.log('收到黑名单', blacklist);
 *     data.blacklist = nim.mergeRelations(data.blacklist, blacklist);
 *     data.blacklist = nim.cutRelations(data.blacklist, blacklist.invalid);
 *     refreshBlacklistUI();
 * }
 * function onMarkInBlacklist(obj) {
 *     console.log(obj.account + '被你' + (obj.isAdd ? '加入' : '移除') + '黑名单', obj);
 *     if (obj.isAdd) {
 *         addToBlacklist(obj);
 *     } else {
 *         removeFromBlacklist(obj);
 *     }
 * }
 * function addToBlacklist(obj) {
 *     data.blacklist = nim.mergeRelations(data.blacklist, obj.record);
 *     refreshBlacklistUI();
 * }
 * function removeFromBlacklist(obj) {
 *     data.blacklist = nim.cutRelations(data.blacklist, obj.record);
 *     refreshBlacklistUI();
 * }
 * function refreshBlacklistUI() {
 *     // 刷新界面
 * }
 * function onMutelist(mutelist) {
 *     console.log('收到静音列表', mutelist);
 *     data.mutelist = nim.mergeRelations(data.mutelist, mutelist);
 *     data.mutelist = nim.cutRelations(data.mutelist, mutelist.invalid);
 *     refreshMutelistUI();
 * }
 * function onMarkInMutelist(obj) {
 *     console.log(obj.account + '被你' + (obj.isAdd ? '加入' : '移除') + '静音列表', obj);
 *     if (obj.isAdd) {
 *         addToMutelist(obj);
 *     } else {
 *         removeFromMutelist(obj);
 *     }
 * }
 * function addToMutelist(obj) {
 *     data.mutelist = nim.mergeRelations(data.mutelist, obj.record);
 *     refreshMutelistUI();
 * }
 * function removeFromMutelist(obj) {
 *     data.mutelist = nim.cutRelations(data.mutelist, obj.record);
 *     refreshMutelistUI();
 * }
 * function refreshMutelistUI() {
 *     // 刷新界面
 * }
 *
 * function onFriends(friends) {
 *     console.log('收到好友列表', friends);
 *     data.friends = nim.mergeFriends(data.friends, friends);
 *     data.friends = nim.cutFriends(data.friends, friends.invalid);
 *     refreshFriendsUI();
 * }
 * function onSyncFriendAction(obj) {
 *     console.log('收到好友操作', obj);
 *     switch (obj.type) {
 *     case 'addFriend':
 *         console.log('你在其它端直接加了一个好友' + obj);
 *         onAddFriend(obj.friend);
 *         break;
 *     case 'applyFriend':
 *         console.log('你在其它端申请加了一个好友' + obj);
 *         break;
 *     case 'passFriendApply':
 *         console.log('你在其它端通过了一个好友申请' + obj);
 *         onAddFriend(obj.friend);
 *         break;
 *     case 'rejectFriendApply':
 *         console.log('你在其它端拒绝了一个好友申请' + obj);
 *         break;
 *     case 'deleteFriend':
 *         console.log('你在其它端删了一个好友' + obj);
 *         onDeleteFriend(obj.account);
 *         break;
 *     case 'updateFriend':
 *         console.log('你在其它端更新了一个好友', obj);
 *         onUpdateFriend(obj.friend);
 *         break;
 *     }
 * }
 * function onAddFriend(friend) {
 *     data.friends = nim.mergeFriends(data.friends, friend);
 *     refreshFriendsUI();
 * }
 * function onDeleteFriend(account) {
 *     data.friends = nim.cutFriendsByAccounts(data.friends, account);
 *     refreshFriendsUI();
 * }
 * function onUpdateFriend(friend) {
 *     data.friends = nim.mergeFriends(data.friends, friend);
 *     refreshFriendsUI();
 * }
 * function refreshFriendsUI() {
 *     // 刷新界面
 * }
 *
 * function onMyInfo(user) {
 *     console.log('收到我的名片', user);
 *     data.myInfo = user;
 *     updateMyInfoUI();
 * }
 * function onUpdateMyInfo(user) {
 *     console.log('我的名片更新了', user);
 *     data.myInfo = NIM.util.merge(data.myInfo, user);
 *     updateMyInfoUI();
 * }
 * function updateMyInfoUI() {
 *     // 刷新界面
 * }
 * function onUsers(users) {
 *     console.log('收到用户名片列表', users);
 *     data.users = nim.mergeUsers(data.users, users);
 * }
 * function onUpdateUser(user) {
 *     console.log('用户名片更新了', user);
 *     data.users = nim.mergeUsers(data.users, user);
 * }
 *
 * function onSuperTeams (superTeams) {
 *   console.log('收到超大群列表', superTeams)
 *   data.superTeams = nim.mergeTeams(data.superTeams, superTeams)
 *   onInvalidSuperTeams(superTeams.invalid)
 * }
 * function onInvalidSuperTeams (teams) {
 *   data.superTeams = nim.cutTeams(data.superTeams, teams)
 *   data.invalidSuperTeams = nim.mergeTeams(data.invalidSuperTeams, teams)
 *   refreshSuperTeamsUI()
 * }
 * 
 * function onSyncCreateSuperTeam (team, owner) {
 *   console.log('创建了一个超大群 onSyncCreateSuperTeam ', team, owner)
 *   data.superTeams = nim.mergeTeams(data.superTeams, team)
 *   refreshSuperTeamsUI()
 *   onSuperTeamMembers({
 *     teamId: team.teamId,
 *     members: owner
 *   })
 * }

 * function onAddSuperTeamMembers (team, accounts, members) {
 *   console.log('添加群成员 onAddSuperTeamMembers ', team, accounts, members)
 *   if (!accounts && !members) {
 *     accounts = team.accounts || []
 *     members = team.members || []
 *     team = team.team || {}
 *   }
 *   var teamId = team.teamId
 *   
 *    // 如果是别人被拉进来了，那么拼接群成员列表
 *    // 如果是自己被拉进来了，那么同步一次群成员列表
 *   
 *   if (accounts.indexOf(data.account) === -1) {
 *     onSuperTeamMembers({
 *       teamId: teamId,
 *       members: members
 *     })
 *   } else {
 *     // ...
 *   }
 *   onSuperTeams(team)
 * }
 * function onDismissSuperTeam(obj) {
 *  console.log('解散超大群 onDismissSuperTeam', obj);
 *   var teamId = obj.teamId
 *   removeAllSuperTeamMembers(teamId)
 *   data.superTeams = nim.cutTeams(data.superTeams, obj)
 *   refreshSuperTeamsUI()
 *   refreshSuperTeamMembersUI()
 * }
 * function onRemoveSuperTeamMembers (obj) {
 *   console.log('移除了群成员 onRemoveSuperTeamMembers ', obj.accounts, obj)
 *   var teamId = obj.team.teamId
 *   var accounts = obj.accounts
 *   var team
 *   if (!teamId && !accounts) {
 *     accounts = obj.accounts || []
 *   }
 *   // 如果是别人被踢了，那么移除群成员
 *   // 如果是自己被踢了，那么离开该群
 *   if (accounts.indexOf(data.account) === -1) {
 *      if (team) {
 *       onSuperTeams(team)
 *     }
 *     if (!data.superTeamMembers) {
 *       data.superTeamMembers = {}
 *     }
 *     data.superTeamMembers[teamId] = nim.cutTeamMembersByAccounts(
 *       data.superTeamMembers[teamId],
 *       teamId,
 *       accounts
 *     )
 *      refreshSuperTeamMembersUI()
 *   } else {
 *     leaveSuperTeam(teamId)
 *   }
 * }
 * function onUpdateSuperTeam(err, msg) {
 *   console.log('更新了超大群 teamId', err, msg)
 * }
 * function onUpdateSuperTeamMember (member) {
 *   console.log('群成员信息更新了', member) 
 * }
 * function leaveSuperTeam (teamId) {
 *   onInvalidSuperTeams({
 *     teamId: teamId
 *   })
 *   removeAllSuperTeamMembers(teamId)
 * }
 * function refreshSuperTeamsUI () {
 * }
 * function refreshSuperTeamMembersUI () {
 * }
 * function removeAllSuperTeamMembers () {
 * }
 * function onTeams(teams) {
 *     console.log('群列表', teams);
 *     data.teams = nim.mergeTeams(data.teams, teams);
 *     onInvalidTeams(teams.invalid);
 * }
 * function onInvalidTeams(teams) {
 *     data.teams = nim.cutTeams(data.teams, teams);
 *     data.invalidTeams = nim.mergeTeams(data.invalidTeams, teams);
 *     refreshTeamsUI();
 * }
 * function onCreateTeam(team) {
 *     console.log('你创建了一个群', team);
 *     data.teams = nim.mergeTeams(data.teams, team);
 *     refreshTeamsUI();
 *     onTeamMembers({
 *         teamId: team.teamId,
 *         members: owner
 *     });
 * }
 * function refreshTeamsUI() {
 *     // 刷新界面
 * }
 * function onTeamMembers(obj) {
 *     console.log('收到群成员', obj);
 *     var teamId = obj.teamId;
 *     var members = obj.members;
 *     data.teamMembers = data.teamMembers || {};
 *     data.teamMembers[teamId] = nim.mergeTeamMembers(data.teamMembers[teamId], members);
 *     data.teamMembers[teamId] = nim.cutTeamMembers(data.teamMembers[teamId], members.invalid);
 *     refreshTeamMembersUI();
 * }
 * function onSyncTeamMembersDone() {
 *     console.log('同步群列表完成');
 * }
 * function onUpdateTeamMember(teamMember) {
 *     console.log('群成员信息更新了', teamMember);
 *     onTeamMembers({
 *         teamId: teamMember.teamId,
 *         members: teamMember
 *     });
 * }
 * function refreshTeamMembersUI() {
 *     // 刷新界面
 * }
 *
 * function onSessions(sessions) {
 *     console.log('收到会话列表', sessions);
 *     data.sessions = nim.mergeSessions(data.sessions, sessions);
 *     updateSessionsUI();
 * }
 * function onUpdateSession(session) {
 *     console.log('会话更新了', session);
 *     data.sessions = nim.mergeSessions(data.sessions, session);
 *     updateSessionsUI();
 * }
 * function updateSessionsUI() {
 *     // 刷新界面
 * }
 *
 * function onRoamingMsgs(obj) {
 *     console.log('漫游消息', obj);
 *     pushMsg(obj.msgs);
 * }
 * function onOfflineMsgs(obj) {
 *     console.log('离线消息', obj);
 *     pushMsg(obj.msgs);
 * }
 * function onMsg(msg) {
 *     console.log('收到消息', msg.scene, msg.type, msg);
 *     pushMsg(msg);
 * }
 * function pushMsg(msgs) {
 *     if (!Array.isArray(msgs)) { msgs = [msgs]; }
 *     var sessionId = msgs[0].sessionId;
 *     data.msgs = data.msgs || {};
 *     data.msgs[sessionId] = nim.mergeMsgs(data.msgs[sessionId], msgs);
 * }
 *
 * function onOfflineSysMsgs(sysMsgs) {
 *     console.log('收到离线系统通知', sysMsgs);
 *     pushSysMsgs(sysMsgs);
 * }
 * function onSysMsg(sysMsg) {
 *     console.log('收到系统通知', sysMsg)
 *     pushSysMsgs(sysMsg);
 * }
 * function onUpdateSysMsg(sysMsg) {
 *     pushSysMsgs(sysMsg);
 * }
 * function pushSysMsgs(sysMsgs) {
 *     data.sysMsgs = nim.mergeSysMsgs(data.sysMsgs, sysMsgs);
 *     refreshSysMsgsUI();
 * }
 * function onSysMsgUnread(obj) {
 *     console.log('收到系统通知未读数', obj);
 *     data.sysMsgUnread = obj;
 *     refreshSysMsgsUI();
 * }
 * function onUpdateSysMsgUnread(obj) {
 *     console.log('系统通知未读数更新了', obj);
 *     data.sysMsgUnread = obj;
 *     refreshSysMsgsUI();
 * }
 * function refreshSysMsgsUI() {
 *     // 刷新界面
 * }
 * function onOfflineCustomSysMsgs(sysMsgs) {
 *     console.log('收到离线自定义系统通知', sysMsgs);
 * }
 * function onCustomSysMsg(sysMsg) {
 *     console.log('收到自定义系统通知', sysMsg);
 * }
 *
 * function onSyncDone() {
 *     console.log('同步完成');
 * }
 */
NIM.getInstance = ApiBase.getInstance;
NIM.rmAllInstances = ApiBase.rmAllInstances;

/**
 * 更新配置, 参数格式跟 {@link NIM.getInstance} 保持一致
 *
 * @memberOf NIM#
 * @method setOptions
 *
 * @param {Object}              options                                 配置参数
 * @param {String}              options.token                           帐号的 token, 用于建立连接
 *
 * @example
 * // 更新 token 的例子
 * nim.setOptions({
 *     token: 'newToken'
 * });
 */

NIM.genInstanceName = function (options) {
  return 'NIM-account-' + options.account;
};

var NIMFn = NIM.fn = NIM.prototype = Object.create(ApiBase.prototype);

NIM.info = NIMFn.info = config.info;

module.exports = NIM;

__webpack_require__(/*! ./model */ "./src/im/api/nim/model.js");
__webpack_require__(/*! ./connect */ "./src/im/api/nim/connect.js");
__webpack_require__(/*! ./relation */ "./src/im/api/nim/relation.js");
__webpack_require__(/*! ./user */ "./src/im/api/nim/user.js");
__webpack_require__(/*! ./friend */ "./src/im/api/nim/friend.js");
__webpack_require__(/*! ./robot */ "./src/im/api/nim/robot.js");
__webpack_require__(/*! ./team */ "./src/im/api/nim/team.js");
__webpack_require__(/*! ./superTeam */ "./src/im/api/nim/superTeam.js");
__webpack_require__(/*! ./session */ "./src/im/api/nim/session.js");
__webpack_require__(/*! ./msg */ "./src/im/api/nim/msg.js");
__webpack_require__(/*! ./sysMsg */ "./src/im/api/nim/sysMsg.js");
__webpack_require__(/*! ./chatroom */ "./src/im/api/nim/chatroom.js");
__webpack_require__(/*! ./nos */ "./src/im/api/nim/nos.js");
__webpack_require__(/*! ./nosViewImage */ "./src/im/api/nim/nosViewImage.js");
__webpack_require__(/*! ./audio */ "./src/im/api/nim/audio.js");
__webpack_require__(/*! ./db */ "./src/im/api/nim/db.js");
__webpack_require__(/*! ./notification */ "./src/im/api/nim/notification.js");
__webpack_require__(/*! ./eventService */ "./src/im/api/nim/eventService.js");

/***/ }),

/***/ "./src/im/api/nim/model.js":
/*!*********************************!*\
  !*** ./src/im/api/nim/model.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var isArray = util.isArray;
var TeamMember = __webpack_require__(/*! im/model/teamMember */ "./src/im/model/teamMember.js");

// util util.isArray util.mergeObjArray util.cutObjArray 和 [] 只应该出现一次
NIMFn.mergeObjArray = function (olds, news, options) {
  if (!olds) {
    olds = [];
  }
  if (!news) {
    return olds;
  }
  if (!isArray(news)) {
    news = [news];
  }
  if (!news.length) {
    return olds;
  }
  options = options || {};
  return util.mergeObjArray(olds, news, options);
};

NIMFn.cutObjArray = function (olds, invalids, options) {
  if (!olds) {
    return olds;
  }
  if (!invalids) {
    return olds;
  }
  if (!isArray(invalids)) {
    invalids = [invalids];
  }
  if (!invalids.length) {
    return olds;
  }
  options = options || {};
  return util.cutObjArray(olds, invalids, options);
};

/**
 * 合并登录端
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的登录端列表
 * - 合并时按照 `deviceId` 的值去重，按照 `deviceId` 的值正序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     keyPath: 'deviceId'
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并登录端
 *
 * @method mergeLoginPorts
 * @memberOf NIM#
 *
 * @param  {LoginPort[]}             olds    原始登录端数组
 * @param  {LoginPort|LoginPort[]}    news    待合并的登录端或登录端数组
 * @return {LoginPort[]}                     合并后的登录端数组
 */
NIMFn.mergeLoginPorts = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    keyPath: 'deviceId'
  });
};

/**
 * 去除登录端
 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的登录端列表
 * - 去除时按照 `account` 的值去除
 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
 * ```
 * if (!olds) {return olds;}
 * if (!invalids) {return olds;}
 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
 * if (!invalids.length) {return olds;}
 * var options = {
 *     keyPath: 'account'
 * };
 * NIM.util.cutObjArray(olds, invalids, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除登录端
 *
 * @method cutLoginPorts
 * @memberOf NIM#
 *
 * @param  {LoginPort[]}             olds        原始登录端数组
 * @param  {LoginPort|LoginPort[]}    invalids    待去除的登录端或登录端数组
 * @return {LoginPort[]}                         去除后的登录端数组
 */
NIMFn.cutLoginPorts = function (olds, invalids) {
  return this.cutObjArray(olds, invalids, {
    keyPath: 'deviceId',
    sortPath: 'type'
  });
};

/**
 * 合并关系
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的关系列表
 * - 合并时按照 `account` 的值去重，按照 `account` 的值正序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     keyPath: 'account'
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并关系
 *
 * @method mergeRelations
 * @memberOf NIM#
 *
 * @param  {Relation[]}             olds    原始关系数组
 * @param  {Relation|Relation[]}    news    待合并的关系或关系数组
 * @return {Relation[]}                     合并后的关系数组
 */
NIMFn.mergeRelations = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    keyPath: 'account'
  });
};

/**
 * 去除关系
 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的关系列表
 * - 去除时按照 `account` 的值去除
 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
 * ```
 * if (!olds) {return olds;}
 * if (!invalids) {return olds;}
 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
 * if (!invalids.length) {return olds;}
 * var options = {
 *     keyPath: 'account'
 * };
 * NIM.util.cutObjArray(olds, invalids, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除关系
 *
 * @method cutRelations
 * @memberOf NIM#
 *
 * @param  {Relation[]}             olds        原始关系数组
 * @param  {Relation|Relation[]}    invalids    待去除的关系或关系数组
 * @return {Relation[]}                         去除后的关系数组
 */
NIMFn.cutRelations = function (olds, invalids) {
  return this.cutObjArray(olds, invalids, {
    keyPath: 'account'
  });
};

/**
 * 在关系数组里面根据 `account` 找到对应的关系
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(relations, {
 *     keyPath: 'account',
 *     value: account
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个关系
 *
 * @method findRelation
 * @memberOf NIM#
 * @param  {Relation[]}     relations    关系数组
 * @param  {String}         account     待查找的关系的 `account`
 * @return {Relation|null}              对应的关系或者 null
 */
NIMFn.findRelation = function (relations, account) {
  return util.findObjInArray(relations, {
    keyPath: 'account',
    value: account
  });
};

/**
 * 合并好友
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的好友列表
 * - 合并时按照 `account` 的值去重，按照 `account` 的值正序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     keyPath: 'account'
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并好友
 *
 * @method mergeFriends
 * @memberOf NIM#
 *
 * @param  {Friend[]}           olds    原始好友数组
 * @param  {Friend|Friend[]}    news    待合并的好友或好友数组
 * @return {Friend[]}                   合并后的好友数组
 */
NIMFn.mergeFriends = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    keyPath: 'account'
  });
};

/**
 * 去除好友
 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的好友列表
 * - 去除时按照 `account` 的值去除
 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
 * ```
 * if (!olds) {return olds;}
 * if (!invalids) {return olds;}
 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
 * if (!invalids.length) {return olds;}
 * var options = {
 *     keyPath: 'account'
 * };
 * NIM.util.cutObjArray(olds, invalids, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除好友
 *
 * @method cutFriends
 * @memberOf NIM#
 *
 * @param  {Friend[]}             olds        原始好友数组
 * @param  {Friend|Friend[]}    invalids    待去除的好友或好友数组
 * @return {Friend[]}                         去除后的好友数组
 */
NIMFn.cutFriends = function (olds, invalids) {
  return this.cutObjArray(olds, invalids, {
    keyPath: 'account'
  });
};

/**
 * 去除`accounts`对应的好友
 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的好友列表
 * - 去除时按照 `account` 的值去除
 * - 此方法内部调用 {@link NIM#cutFriends|nim.cutFriends} 来完成实际工作
 * ```
 * if (!NIM.util.isArray(accounts)) { accounts = [accounts]; }
 * var invalids = accounts.map(function(account) {
 *     return {
 *         account: account
 *     };
 * });
 * return nim.cutFriends(olds, invalids);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除好友
 *
 * @method cutFriendsByAccounts
 * @memberOf NIM#
 *
 * @param  {Friend[]}           olds        原始好友数组
 * @param  {Friend|Friend[]}    invalids    待去除的好友或好友数组
 * @return {Friend[]}                       去除后的好友数组
 */
NIMFn.cutFriendsByAccounts = function (olds, accounts) {
  if (!isArray(accounts)) {
    accounts = [accounts];
  }
  var invalids = accounts.map(function (account) {
    return {
      account: account
    };
  });
  return this.cutFriends(olds, invalids);
};

/**
 * 在好友数组里面根据 `account` 找到对应的好友
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(friends, {
 *     keyPath: 'account',
 *     value: account
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个好友
 *
 * @method findFriend
 * @memberOf NIM#
 * @param  {Friend[]}       friends     好友数组
 * @param  {String}         account     待查找的好友的 `account`
 * @return {Friend|null}                对应的好友或者 null
 */
NIMFn.findFriend = function (friends, account) {
  return util.findObjInArray(friends, {
    keyPath: 'account',
    value: account
  });
};

/**
 * 合并名片
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的名片列表
 * - 合并时按照 `account` 的值去重，按照 `account` 的值正序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     keyPath: 'account'
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并名片
 *
 * @method mergeUsers
 * @memberOf NIM#
 *
 * @param  {User[]}         olds    原始名片数组
 * @param  {User|User[]}    news    待合并的名片或名片数组
 * @return {User[]}                 合并后的名片数组
 */
NIMFn.mergeUsers = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    keyPath: 'account'
  });
};

/**
 * 在名片数组里面根据 `account` 找到对应的名片
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(users, {
 *     keyPath: 'account',
 *     value: account
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个名片
 *
 * @method findUser
 * @memberOf NIM#
 * @param  {User[]}     users    名片数组
 * @param  {String}     account  待查找的名片的 `account`
 * @return {User|null}           对应的名片或者 null
 */
NIMFn.findUser = function (users, account) {
  return util.findObjInArray(users, {
    keyPath: 'account',
    value: account
  });
};

/**
 * 合并群
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的群列表
 * - 合并时按照 `teamId` 的值去重，按照 `teamId` 的值正序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     keyPath: 'teamId'
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并群
 *
 * @method mergeTeams
 * @memberOf NIM#
 *
 * @param  {Team[]}         olds    原始群数组
 * @param  {Team|Team[]}    news    待合并的群或群数组
 * @return {Team[]}                 合并后的群数组
 */
NIMFn.mergeTeams = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    keyPath: 'teamId'
  });
};

/**
 * 去除群
 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的群列表
 * - 去除时按照 `teamId` 的值去除
 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
 * ```
 * if (!olds) {return olds;}
 * if (!invalids) {return olds;}
 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
 * if (!invalids.length) {return olds;}
 * var options = {
 *     keyPath: 'teamId'
 * };
 * NIM.util.cutObjArray(olds, invalids, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除群
 *
 * @method cutTeams
 * @memberOf NIM#
 *
 * @param  {Team[]}         olds        原始群数组
 * @param  {Team|Team[]}    invalids    待去除的群或群数组
 * @return {Team[]}                     去除后的群数组
 */
NIMFn.cutTeams = function (olds, invalids) {
  return this.cutObjArray(olds, invalids, {
    keyPath: 'teamId'
  });
};

/**
 * 在群数组里面根据 `teamId` 找到对应的群
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(teams, {
 *     keyPath: 'teamId',
 *     value: teamId
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个群
 *
 * @method findTeam
 * @memberOf NIM#
 * @param  {Team[]}      teams    群数组
 * @param  {String}      teamId   待查找的群的 `teamId`
 * @return {Team|null}            对应的群或者 null
 */
NIMFn.findTeam = function (teams, teamId) {
  return util.findObjInArray(teams, {
    keyPath: 'teamId',
    value: teamId
  });
};

NIMFn.assembleTeamOwner = TeamMember.assembleOwner;
NIMFn.assembleTeamMembers = TeamMember.assembleMembers;
NIMFn.genTeamMemberId = TeamMember.genId;

/**
 * 合并群成员
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的群成员列表
 * - 合并时按照 `id` 的值去重，按照 `id` 的值正序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并群成员
 *
 * @method mergeTeamMembers
 * @memberOf NIM#
 *
 * @param  {TeamMember[]}               olds    原始群成员数组
 * @param  {TeamMember|TeamMember[]}    news    待合并的群成员或群成员数组
 * @return {TeamMember[]}                       合并后的群成员数组
 */
NIMFn.mergeTeamMembers = function (olds, news) {
  // keyPath 默认为 id
  return this.mergeObjArray(olds, news);
};

/**
 * 去除群成员
 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的群成员列表
 * - 去除时按照 `id` 的值去除
 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
 * ```
 * if (!olds) {return olds;}
 * if (!invalids) {return olds;}
 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
 * if (!invalids.length) {return olds;}
 * var options = {
 * };
 * NIM.util.cutObjArray(olds, invalids, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除群成员
 *
 * @method cutTeamMembers
 * @memberOf NIM#
 *
 * @param  {TeamMember[]}               olds        原始群成员数组
 * @param  {TeamMember|TeamMember[]}    invalids    待去除的群成员或群成员数组
 * @return {TeamMember[]}                           去除后的群成员数组
 */
NIMFn.cutTeamMembers = function (olds, invalids) {
  // keyPath 默认为 id
  return this.cutObjArray(olds, invalids);
};

/**
 * 去除`accounts`对应的群成员
 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的群成员列表
 * - 去除时按照 `account` 的值去除
 * - 此方法内部调用 {@link NIM#cutTeamMembers|nim.cutTeamMembers} 来完成实际工作
 * ```
 * if (!NIM.util.isArray(accounts)) { accounts = [accounts]; }
 * var invalids = TeamMember.assembleMembers({
 *     teamId: teamId
 * }, accounts);
 * return nim.cutTeamMembers(olds, invalids);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除群成员
 *
 * @method cutTeamMembersByAccounts
 * @memberOf NIM#
 *
 * @param  {TeamMember[]}               olds        原始群成员数组
 * @param  {TeamMember|TeamMember[]}    invalids    待去除的群成员或群成员数组
 * @return {TeamMember[]}                           去除后的群成员数组
 */
NIMFn.cutTeamMembersByAccounts = function (olds, teamId, accounts) {
  if (!isArray(accounts)) {
    accounts = [accounts];
  }
  var invalids = TeamMember.assembleMembers({
    teamId: teamId
  }, accounts);
  return this.cutTeamMembers(olds, invalids);
};

/**
 * 在群成员数组里面根据 `id` 找到对应的群成员
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(members, {
 *     keyPath: 'id',
 *     value: id
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个群成员
 *
 * @method findTeamMember
 * @memberOf NIM#
 * @param  {TeamMember[]}       members     群成员数组
 * @param  {String}             id          待查找的群成员的 `id`
 * @return {TeamMember|null}                对应的群成员或者 null
 */
NIMFn.findTeamMember = function (members, id) {
  return util.findObjInArray(members, {
    keyPath: 'id',
    value: id
  });
};

/**
 * 合并会话
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的会话列表
 * - 合并时按照 `id` 的值去重，按照 `updateTime` 的值倒序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     sortPath: 'updateTime',
 *     desc: true
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并会话
 *
 * @method mergeSessions
 * @memberOf NIM#
 *
 * @param  {Session[]}          olds    原始会话数组
 * @param  {Session|Session[]}  news    待合并的会话或会话数组
 * @return {Session[]}                  合并后的会话数组
 */
NIMFn.mergeSessions = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    sortPath: 'updateTime',
    desc: true
  });
};

NIMFn.cutSessions = function (olds, invalids) {
  return this.cutObjArray(olds, invalids);
};

NIMFn.cutSessionsByIds = function (olds, ids) {
  if (!isArray(ids)) {
    ids = [ids];
  }
  var invalids = ids.map(function (id) {
    return { id: id };
  });
  return this.cutSessions(olds, invalids);
};

/**
 * 在会话数组里面根据 `id` 找到对应的会话
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(sessions, {
 *     keyPath: 'id',
 *     value: sessionId
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个会话
 *
 * @method findSession
 * @memberOf NIM#
 * @param  {Session[]}      sessions    会话数组
 * @param  {String}         sessionId   待查找的会话的 `id`
 * @return {Session|null}               对应的会话或者 null
 */
NIMFn.findSession = function (sessions, sessionId) {
  return util.findObjInArray(sessions, {
    keyPath: 'id',
    value: sessionId
  });
};

/**
 * 合并消息
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的消息列表
 * - 合并时按照 `idClient` 的值去重，按照 `time` 的值排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     keyPath: 'idClient',
 *     sortPath: 'time'
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并消息
 *
 * @method mergeMsgs
 * @memberOf NIM#
 *
 * @param  {Message[]}          olds    原始消息数组
 * @param  {Message|Message[]}  news    待合并的消息或消息数组
 * @return {Message[]}                  合并后的消息数组
 */
NIMFn.mergeMsgs = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    keyPath: 'idClient',
    sortPath: 'time'
  });
};

NIMFn.cutMsgs = function (olds, invalids) {
  return this.cutObjArray(olds, invalids, {
    keyPath: 'idClient'
  });
};

NIMFn.cutMsgsByIdClients = function (olds, idClients) {
  if (!isArray(idClients)) {
    idClients = [idClients];
  }
  var invalids = idClients.map(function (idClient) {
    return { idClient: idClient };
  });
  return this.cutMsgs(olds, invalids);
};

/**
 * 在消息数组里面根据 `idClient` 找到对应的消息
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(msgs, {
 *     keyPath: 'idClient',
 *     value: idClient
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个消息
 *
 * @method findMsg
 * @memberOf NIM#
 * @param  {Message[]}      msgs        消息数组
 * @param  {String}         idClient    待查找的消息的 `idClient`
 * @return {Message|null}               对应的消息或者 null
 */
NIMFn.findMsg = function (msgs, idClient) {
  return util.findObjInArray(msgs, {
    keyPath: 'idClient',
    value: idClient
  });
};

/**
 * 合并系统通知
 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的系统通知列表
 * - 合并时按照 `idServer` 的值去重，按照 `idServer` 的值倒序排序
 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
 * ```
 * if (!olds) {olds = [];}
 * if (!news) {return olds;}
 * if (!NIM.util.isArray(news)) { news = [news]; }
 * if (!news.length) {return olds;}
 * var options = {
 *     keyPath: 'idServer',
 *     desc: true
 * };
 * NIM.util.mergeObjArray([], olds, news, options);
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并系统通知
 *
 * @method mergeSysMsgs
 * @memberOf NIM#
 *
 * @param  {SystemMessage[]}                olds    原始系统通知数组
 * @param  {SystemMessage|SystemMessage[]}  news    待合并的系统通知或系统通知数组
 * @return {SystemMessage[]}                        合并后的系统通知数组
 */
NIMFn.mergeSysMsgs = function (olds, news) {
  return this.mergeObjArray(olds, news, {
    keyPath: 'idServer',
    desc: true
  });
};

NIMFn.cutSysMsgs = function (olds, invalids) {
  return this.cutObjArray(olds, invalids, {
    keyPath: 'idServer'
  });
};

NIMFn.cutSysMsgsByIdServers = function (olds, idServers) {
  if (!isArray(idServers)) {
    idServers = [idServers];
  }
  var invalids = idServers.map(function (idServer) {
    return { idServer: idServer };
  });
  return this.cutSysMsgs(olds, invalids);
};

/**
 * 在系统通知数组里面根据 `idServer` 找到对应的系统通知
 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
 * ```
 * NIM.util.findObjInArray(sysMsgs, {
 *     keyPath: 'idServer',
 *     value: idServer
 * });
 * ```
 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个系统通知
 *
 * @method findSysMsg
 * @memberOf NIM#
 * @param  {SystemMessage[]}    sysMsgs     系统通知数组
 * @param  {String}             idServer    待查找的系统通知的 `idServer`
 * @return {SystemMessage|null}             对应的系统通知或者 null
 */
NIMFn.findSysMsg = function (sysMsgs, idServer) {
  return util.findObjInArray(sysMsgs, {
    keyPath: 'idServer',
    value: idServer
  });
};

/***/ }),

/***/ "./src/im/api/nim/msg.js":
/*!*******************************!*\
  !*** ./src/im/api/nim/msg.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var notundef = util.notundef;
var device = __webpack_require__(/*! utiljs/device */ "./src/util/device.js");
var Session = __webpack_require__(/*! im/model/session */ "./src/im/model/session.js");
var SystemMessage = __webpack_require__(/*! im/model/systemMessage */ "./src/im/model/systemMessage.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");

/**
 * 发送文本消息
 *
 * - 文本消息是消息的一种, 请参考{@link IMMessage|消息}
 *
 * @memberOf NIM#
 * @method sendText
 *
 * @param  {Object}             options                         配置参数
 * @param  {String}             options.scene                   {@link IMMessage.scene|场景}
 * @param  {String}             options.to                      接收方, 对方帐号或者群id
 * @param  {String}             options.text                    文本消息内容
 * @param  {Boolean}            [options.resend]                是否是重发
 * @param  {String}             [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
 * @param  {String}             [options.custom]                扩展字段
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param  {String}             [options.pushContent]           自定义推送文案
 * @param  {String}             [options.pushPayload]           自定义的推送属性
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param  {Boolean}            [options.needPushNick=true]     是否需要推送昵称
 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
 * @param  {Boolean}            [options.isHistoryable=true]    是否存储云端历史
 * @param  {Boolean}            [options.isRoamingable=true]    是否支持漫游
 * @param  {Boolean}            [options.isSyncable=true]       是否支持发送者多端同步
 * @param  {Boolean}            [options.cc]                    是否支持抄送
 * @param  {Boolean}            [options.isInBlackList=true]    发送此条消息时，发送方`'from'`是否在接收方`'to'`的黑名单列表中
 * @param  {Boolean}            [options.isPushable=true]       是否需要推送
 * @param  {Boolean}            [options.isOfflinable=true]     是否要存离线
 * @param  {Boolean}            [options.isUnreadable=true]     是否计入消息未读数
 * @param {Boolean}             [options.isLocal=false] 是否是本地消息
 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
 * @param {Boolean}             [options.needMsgReceipt=false] 是否需要业务已读（包含该字段且为true即表示需要）
 * @param  {Boolean}            [options.clientAntiSpam = false]   是否需要过客户端反垃圾
 * @param  {Boolean}            [options.yidunEnable = false]   是否需要过易盾反垃圾
 * @param  {String}             [options.antiSpamContent] 在开启yidunEnable后, 开发者自定义的反垃圾字段（json格式)，格式如下：{"type": 1, "data": "custom content"} 字段说明：type:1.文本，2.图片，3视频，data内容:文本内容or图片地址or视频地址
 * @param  {String}             [options.antiSpamBusinessId] 用户配置的对某条单条消息另外反垃圾的业务ID
 * @param  {Boolean}            [options.antiSpamUsingYidun = false]   单条消息是否需要易盾反垃圾
 * @param  {done}               options.done                    结果回调函数
 * @return {Message}                                            {@link IMMessage|消息}
 *
 * @example
 * var msg = nim.sendText({
 *     scene: 'p2p',
 *     to: 'account',
 *     text: 'hello',
 *     done: sendMsgDone
 * });
 * console.log('正在发送p2p text消息, id=' + msg.idClient);
 * pushMsg(msg);
 * function sendMsgDone(error, msg) {
 *     console.log('发送' + msg.scene + ' ' + msg.type + '消息' + (!error?'成功':'失败') + ', id=' + msg.idClient, error, msg);
 * }
 */

/**
 * 文件上传进度回调
 * @private
 * @callback uploadprogress
 * @param {Object} obj                  进度信息
 * @param {Number} obj.total            文件总大小
 * @param {Number} obj.loaded           已经上传的大小
 * @param {Number} obj.percentage       上传百分比
 * @param {String} obj.percentageText   上传百分比的文字表示
 * @see {@link NIM#previewFile|预览文件}
 * @see {@link NIM#sendFile|发送文件消息}
 */

/**
 * 预览文件
 *
 * - 开发者可以预览文件, 支持以下几种场景
 *     - 通过参数`fileInput`传入文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
 *     - 通过参数`blob`传入 Blob 对象
 *     - 通过参数`dataURL`传入包含 MIME type 和 base64 数据的 data URL, 此用法需要浏览器支持 Blob
 * - SDK会将文件上传到文件服务器, 然后将拿到的文件对象在`done`回调中传给开发者, 文件对象有以下几种
 *     - {@link Image|图片对象}
 *     - {@link Audio|音频对象}
 *     - {@link Video|视频对象}
 *     - {@link File|文件对象}
 * - 开发者在拿到文件对象之后, 可以调用{@link NIM#sendFile|发送文件消息}来发送文件消息。
 * - 文件大小限制为最大 100M
 *     - 高级浏览器会在上传前就检测文件大小
 *     - IE8/IE9 会在上传完成后检测文件大小
 *
 * @memberOf NIM#
 * @method previewFile
 *
 * @param  {Object}         options                     配置参数
 * @param  {String}         [options.type]              文件过滤器
 * - image会过滤掉非图片的文件, audio过滤掉非音频, video会过滤掉非视频的文件
 * - IE8/IE9 不支持文件过滤
 * @param  {String|Node}    [options.fileInput]         文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
 * @param  {Number}    [options.maxSize]  限制文件的大小
 * @param  {Boolean}   [options.commonUpload]  使用普通上传（最大100M文件）
 * @param  {Blob}           [options.blob]              Blob 对象
 * @param  {String}         [options.dataURL]           包含 MIME type 和 base64 数据的 data URL
 * @param  {uploadprogress} [options.uploadprogress]    上传进度, ie9以下不支持上传进度
 * @param {String}           [options.nosScenes]            存储场景，不传默认实例化配置，默认为"im"
 * @param {Number}           [options.nosSurvivalTime]      存储有效时间，不传默认实例化配置 不得小于一天，单位秒
 * @param  {done}           options.done                结果回调函数, 成功时会收到文件对象, 请参考
 * - {@link Image|图片对象}
 * - {@link Audio|音频对象}
 * - {@link Video|视频对象}
 * - {@link File|文件对象}
 * @return {Void}
 *
 * @example
 * nim.previewFile({
 *     type: 'image',
 *     fileInput: fileInput,
 *     uploadprogress: function(obj) {
 *         console.log('文件总大小: ' + obj.total + 'bytes');
 *         console.log('已经上传的大小: ' + obj.loaded + 'bytes');
 *         console.log('上传进度: ' + obj.percentage);
 *         console.log('上传进度文本: ' + obj.percentageText);
 *     },
 *     done: function(error, file) {
 *         console.log('上传image' + (!error?'成功':'失败'));
 *         // show file to the user
 *         if (!error) {
 *             var msg = nim.sendFile({
 *                 scene: 'p2p',
 *                 to: 'account',
 *                 file: file,
 *                 done: sendMsgDone
 *             });
 *             console.log('正在发送p2p image消息, id=' + msg.idClient);
 *             pushMsg(msg);
 *         }
 *     }
 * });
 */

/**
 * 上传完成回调
 * @private
 * @callback uploaddone
 * @param {NIMError}    error   是否出错
 * @param {Object}      file    上传成功时会包含文件对象, 请参考
 *                              {@link Image|图片对象}
 *                              {@link Audio|音频对象}
 *                              {@link Video|视频对象}
 *                              {@link File|文件对象}
 * @see {@link NIM#sendFile|发送文件消息}
 */

/**
 * 发送文件消息之前的回调函数
 * @private
 * @callback beforesend
 * @param {String} idClient SDK生成的ID
 * @see {@link NIM#sendFile|发送文件消息}
 */

/**
 * 发送文件消息
 *
 * - 文件消息是{@link IMMessage.type|消息类型}的一种
 * - 开发者可以直接发送文件消息
 *     - 支持以下几种场景
 *         - 通过参数`fileInput`传入文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
 *         - 通过参数`blob`传入 Blob 对象
 *         - 通过参数`dataURL`传入包含 MIME type 和 base64 数据的 data URL, 此用法需要浏览器支持 Blob
 *     - SDK会先将文件上传到文件服务器, 然后把拿到的文件对象在`uploaddone`回调中传给用户, 然后将其拼装成文件消息发送出去。
 * - 开发者也可以先{@link NIM#previewFile|预览文件}来获取文件对象, 然后调用此接口发送文件消息。
 *     - 通过参数`file`传入文件
 * - 直接发送文件消息的话会在`beforesend`回调里面传入SDK生成的`idClient`, 如果先预览文件再发送, 那么此接口会直接返回`idClient`
 * - 参数`type`指定了要发送的文件类型, 包括图片、音频、视频和普通文件, 对应的值分别为`'image'`、`'audio'`、`'video'`和`'file'`, 不传默认为`'file'`。
 * - 图片、音频、视频和普通文件的区别在于具体的文件信息不一样, 具体字段请参考
 *     - {@link Image|图片对象}
 *     - {@link Audio|音频对象}
 *     - {@link Video|视频对象}
 *     - {@link File|文件对象}
 *     - {@link Robot|机器人对象}
 * - 文件大小限制为最大100M
 *     - 高级浏览器会在上传前就检测文件大小
 *     - IE8和IE9会在上传完成后检测文件大小
 *
 * @memberOf NIM#
 * @method sendFile
 *
 * @param  {Object}         options                         配置参数
 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
 * @param  {String}         [options.type]                  文件过滤器,
 *                                                          `'image'`会过滤掉非图片的文件, `'audio'`过滤掉非音频, `'video'`会过滤掉非视频的文件,
 *                                                          IE8/IE9 不支持文件过滤
 * @param  {String|Node}    [options.fileInput]             文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
 * @param  {Number}    [options.maxSize]      限制文件的大小
 * @param  {Boolean}   [options.commonUpload]  使用普通上传（最大100M文件）
 * @param  {Blob}           [options.blob]                  Blob 对象
 * @param  {String}         [options.dataURL]               MIME type 和 base64 数据的 data URL
 * @param  {Array}          [options.file]                  文件对象, 开发者可以通过{@link NIM#previewFile|预览文件}拿到文件对象
 * @param {String} [options.wxFilePath] 仅供微信小程序使用, 通过 wx.chooseImage 或者 wx.startRecord 拿到的临时文件路径
 * @param  {Boolean}        [options.resend=false]          是否是重发
 * @param  {Function}       [options.beginupload]           开始上传图片的回调
 * - 如果开发者传入 fileInput, 在此回调之前不能修改 fileInput
 * - 在此回调之后可以取消图片上传, 此回调会接收一个参数 `upload`, 调用 `upload.abort();` 来取消文件上传
 * @param  {uploadprogress} [options.uploadprogress]        上传进度, IE9以下不支持上传进度
 * @param  {uploaddone}     [options.uploaddone]            上传完成回调
 * - 此回调接收两个参数, error 和 obj
 * - 如果出错, error 包含详细的错误信息
 * - 如果上传成功, obj 包含详细的文件信息
 * @param  {beforesend}     [options.beforesend]            发送文件消息之前的回调函数
 * @param  {Boolean}        [options.resend]                是否是重发
 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
 * @param  {String}         [options.custom]                扩展字段
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param  {String}         [options.pushContent]           自定义推送文案
 * @param  {String}         [options.pushPayload]           自定义的推送属性
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
 * @param  {Boolean}        [options.cc]                    是否支持抄送
 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
 * @param {Boolean} [options.isLocal=false] 是否是本地消息
 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
 * @param {String}           [options.nosScenes]            存储场景，不传默认实例化配置
 * @param {Number}           [options.nosSurvivalTime]      存储有效时间，不传默认实例化配置 不得小于一天，单位秒
 * @param  {done}           options.done                结果回调函数
 * @return {Void|Message}
 * - 如果提供了参数fileInput, 那么先上传文件到服务器再发送, 不会返回{@link IMMessage|消息}, 会在beforesend里面返回{@link IMMessage|消息}.
 * - 如果提供了参数file, 那么直接发送文件消息, 返回{@link IMMessage|消息}
 *
 * @example
 * nim.sendFile({
 *     scene: 'p2p',
 *     to: 'account',
 *     type: 'image',
 *     fileInput: fileInput,
 *     uploadprogress: function(obj) {
 *         console.log('文件总大小: ' + obj.total + 'bytes');
 *         console.log('已经上传的大小: ' + obj.loaded + 'bytes');
 *         console.log('上传进度: ' + obj.percentage);
 *         console.log('上传进度文本: ' + obj.percentageText);
 *     },
 *     uploaddone: function(error, file) {
 *         console.log('上传' + (!error?'成功':'失败'), error, file);
 *     },
 *     beforesend: function(msg) {
 *         console.log('正在发送p2p image消息, id=' + msg.idClient);
 *         pushMsg(msg);
 *     },
 *     done: sendMsgDone
 * });
 */

/**
 * 发送自定义消息
 *
 * - 自定义消息是{@link IMMessage.type|消息类型}的一种
 * - 下面的代码用自定义消息实现了`石头剪刀布`游戏
 *
 * @memberOf NIM#
 * @method sendCustomMsg
 *
 * @param  {Object}         options                         配置参数
 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
 * @param  {String}         options.content                 自定义消息的消息内容, 推荐使用JSON格式构建
 * @param  {Boolean}        [options.resend]                是否是重发
 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
 * @param  {String}         [options.custom]                扩展字段
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param  {String}         [options.pushContent]           自定义推送文案
 * @param  {String}         [options.pushPayload]           自定义的推送属性
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
 * @param  {Boolean}        [options.cc]                    是否支持抄送
 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
 * @param {Boolean} [options.isLocal=false] 是否是本地消息
 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
 * @return {Message}                            {@link IMMessage|消息}
 *
 * @example
 * var value = Math.ceil(Math.random()*3);
 * var content = {
 *     type: 1,
 *     data: {
 *         value: value
 *     }
 * };
 * var msg = nim.sendCustomMsg({
 *     scene: 'p2p',
 *     to: 'account',
 *     content: JSON.stringify(content),
 *     done: sendMsgDone
 * });
 * console.log('正在发送p2p自定义消息, id=' + msg.idClient);
 * pushMsg(msg);
 */

/**
 * 发送地理位置消息
 *
 * - 地理位置消息是{@link IMMessage.type|消息类型}的一种, `geo`参数请参考{@link Geo|地理位置对象}
 *
 * @method sendGeo
 * @memberOf NIM#
 *
 * @param  {Object}         options                         配置参数
 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
 * @param  {Object}         options.geo                     地理位置对象
 * @param  {Number}         options.geo.lng                 经度
 * @param  {Number}         options.geo.lat                 纬度
 * @param  {String}         options.geo.title               地址描述
 * @param  {Boolean}        [options.resend]                是否是重发
 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
 * @param  {String}         [options.custom]                扩展字段
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param  {String}         [options.pushContent]           自定义推送文案
 * @param  {String}         [options.pushPayload]           自定义的推送属性
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的用户屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
 * @param  {Boolean}        [options.cc]                    是否支持抄送
 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
 * @param {Boolean} [options.isLocal=false] 是否是本地消息
 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
 * @return {Message}                            {@link IMMessage|消息}
 *
 * @example
 * var msg = nim.sendGeo({
 *     scene: 'p2p',
 *     to: 'account',
 *     geo: {
 *         lng: '116.3833',
 *         lat: '39.9167',
 *         title: 'Beijing'
 *     },
 *     done: sendMsgDone
 * });
 * console.log('正在发送p2p geo消息, id=' + msg.idClient);
 * pushMsg(msg);
 */

/**
 * 发送提醒消息
 *
 * - 提醒消息是{@link IMMessage.type|消息类型}的一种
 * - 提醒消息用于会话内的状态提醒，如进入会话时出现的欢迎消息，或者会话命中敏感词后的提示消息等等.
 *
 * @method sendTipMsg
 * @memberOf NIM#
 *
 * @param  {Object}         options                         配置参数
 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
 * @param  {String}         options.tip                     提醒内容
 * @param  {Boolean}        [options.resend]                是否是重发
 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
 * @param  {String}         [options.custom]                扩展字段
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param  {String}         [options.pushContent]           自定义推送文案
 * @param  {String}         [options.pushPayload]           自定义的推送属性
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
 * @param  {Boolean}        [options.cc]                    是否支持抄送
 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
 * @param {Boolean} [options.isLocal=false] 是否是本地消息
 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
 * @return {Message}        {@link IMMessage|消息}
 *
 * @example
 * var msg = nim.sendTipMsg({
 *     scene: 'p2p',
 *     to: 'account',
 *     tip: 'tip content',
 *     done: sendMsgDone
 * });
 * console.log('正在发送p2p提醒消息, id=' + msg.idClient);
 * pushMsg(msg);
 */

/**
 * 给机器人发送消息
 *
 * - 机器人消息是{@link IMMessage.type|消息类型}的一种
 * - 机器人消息类型分为type为robot
 *
 * @memberOf NIM#
 * @method sendRobotMsg
 *
 * @param  {Object}         options                         配置参数
 * @param  {String}         [options.scene]                   {@link IMMessage.scene|场景}
 * @param  {String|Number}  [options.to]                      接收方, 对方帐号或者群id，如果id为机器人，则点对点与机器人聊天，如果id为普通用户或者群，则相当于聊天界面@机器人
 * @param  {Object}         [options.content]                 发送给机器人的消息内容
 * @param {String}          [options.content.type]           welcome:欢迎消息，text:文本，link:模块跳转
 * @param {String}          [options.content.content]           机器人消息内容
 * @param {String}          [options.content.target]           返回消息类型为BOT时出现的link元素类型block中的target
 * @param {String}          [options.content.params]           返回消息类型为BOT时出现的link元素类型block中的params
 * @param {String}          [options.content.userid]           区分谁和机器人说话的ID
 * @param {String}          [options.content.channel]          渠道
 * @param  {Boolean}        [options.resend]                是否是重发
 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
 * @param  {Boolean}        [options.cc]                    是否支持抄送
 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
 * @param {Boolean} [options.isLocal=false] 是否是本地消息
 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
 * @return {Message}                            {@link IMMessage|消息}
 *
 * @example
 * var msg = nim.sendRobotMsg({
 *   scene: 'p2p',
 *   to: 'nim-assistant',
 *   content: {
 *     type: 'text',
 *     content: 'hello'
 *   },
 *   body: '欢迎',
 *   robotAccid: 'nim-assistant',
 *   done: function sendMsgDone (err) {
 *     console.log(11111111, err)
 *   }
 * })
 * console.log('正在发送p2p自定义消息, id=' + msg.idClient);
 * pushMsg(msg);
 */

NIMFn.beforeSendMsg = function (options) {
  var self = this;
  var protocol = self.protocol;
  var msg = options.msg;
  // 如果是发送给自己, 需要带上设备号
  if (msg.to === self.account) {
    msg.fromDeviceId = device.deviceId;
  }
  // 在消息中带上当前用户的信息更新时间
  msg.userUpdateTime = protocol.myInfo && protocol.myInfo.updateTime;
  // 生成命令
  var cmd;
  // 区分点对点消息和群消息
  switch (msg.getScene()) {
    case 'p2p':
      cmd = 'sendMsg';
      break;
    case 'team':
      cmd = 'sendTeamMsg';
      break;
    case 'superTeam':
      cmd = 'sendSuperTeamMsg';
      break;
    default:
      break;
  }
  // 是否是过滤消息
  if (options.filter) {
    cmd = 'sendFilterMsg';
    msg.filter = true;
  }
  options.cmd = cmd;
};

NIMFn.afterSendMsg = function (options) {
  var msg = options.rtnMsg;
  var session = Session.genSessionByMsg(msg);
  this.protocol.onUpdateSession(session);
};

/**
 * 重发消息
 * - 如果消息发送失败, 那么可以重发消息
 *
 * @memberOf NIM#
 * @method resendMsg
 *
 * @param  {Object} options  配置参数
 * @param {IMMessage} options.msg 待重发的消息
 * @param {Function} options.done 结果回调函数
 * @return {Void}
 *
 * @example
 * nim.resendMsg({
 *   msg: someMsg,
 *   done: sendMsgDone
 * })
 * console.log('正在重发消息', someMsg)
 */

/**
 * 转发消息
 *
 * @memberOf NIM#
 * @method forwardMsg
 *
 * @param  {Object} options  配置参数
 * @param {IMMessage} options.msg 待转发的消息
 * @param {String}  options.scene 新的{@link IMMessage.scene|场景}
 * @param {String}  options.to 新的接收方, 对方帐号或者群id
 * @param {Function} options.done 结果回调函数
 * @return {Void}
 *
 * @example
 * nim.forwardMsg({
 *   msg: someMsg,
 *   scene: 'p2p',
 *   to: 'account',
 *   done: sendMsgDone
 * })
 * console.log('正在转发消息', someMsg)
 */
NIMFn.beforeForwardMsg = function (options) {
  util.verifyOptions(options, 'msg scene to', 'msg::beforeForwardMsg');
  options.msg.scene = options.scene;
  options.msg.to = options.to;
};

/**
 * 标记消息为已收到
 *
 * - 如果没有消息、或者支持数据库、或者设置了自动标记, 那么直接返回
 *
 * @memberOf NIM#
 * @method markMsgRead
 *
 * @param  {IMMessage[]}  msgs    待标记的消息或者消息数组
 * @return {Void}
 *
 * @example
 * nim.markMsgRead(someMsg);
 * // or
 * nim.markMsgRead([someMsg]);
 */
NIMFn.markMsgRead = function (msgs) {
  var self = this;
  var protocol = self.protocol;
  if (!msgs || self.db.enable || protocol.options.autoMarkRead) {
    self.logger.warn('api::markMsgRead: 不需要标记消息为已收到 (没有消息, 或者启用了数据库, 或者启用了自动标记已收到)');
    return;
  }
  protocol.markMsgRead(msgs, true);
};

/**
 * 发送消息已读回执
 *
 * - 目前只支持{@link IMMessage.scene|'p2p'}会话
 * - 如果没有传入消息, 则直接返回成功
 * - 如果已经发送过比传入的消息的时间戳大的已读回执, 那么直接返回成功
 *
 * @memberOf NIM#
 * @method sendMsgReceipt
 *
 * @param {Object} options 参数
 * @param {IMMessage} options.msg 要发送已读回执的会话的最后一条消息, 可以直接通过{@link Session|`session.lastMsg`}来获取此消息
 * @param {Function} options.done 结果回调函数
 * @return {Void}
 *
 * @example
 * nim.sendMsgReceipt({
 *     msg: session.lastMsg,
 *     done: sendMsgReceiptDone
 * });
 * function sendMsgReceiptDone(error, obj) {
 *     console.log('发送消息已读回执' + (!error?'成功':'失败'), error, obj);
 * }
 */
/*
// 测试代码
nim.sendMsgReceipt({
    msg: {
        idClient: 'aaa',
        sessionId: 'p2p-zyy1',
        target: 'zyy1',
        scene: 'p2p',
        status: 'success',
        time: +new Date(),
    },
    done: function() {}
});
 */
NIMFn.sendMsgReceipt = function (options) {
  var self = this;
  util.verifyOptions(options);
  self.processCallback(options);
  if (!options.msg) {
    // 没有消息返回
    options.done();
    return;
  }
  var properties = 'target idClient time';
  util.verifyOptions(options, 'msg', 'msg::sendMsgReceipt');
  var msg = options.msg;
  util.verifyOptions(msg, properties, true, 'msg.', 'msg::sendMsgReceipt');
  if (self.protocol.shouldSendMsgReceipt(msg)) {
    self.sendCmd('sendMsgReceipt', {
      msgReceipt: {
        to: msg.target,
        idClient: msg.idClient,
        time: msg.time
      }
    }, options.callback);
  } else {
    // 返回
    options.done();
  }
};

/**
 * 查询消息是否被对方读过了
 *
 * - 目前只支持{@link IMMessage.scene|'p2p'}会话
 *
 * @memberOf NIM#
 * @method isMsgRemoteRead
 *
 * @param  {IMMessage}  msg 消息
 * @return {Boolean}     是否被对方读过
 *
 * @example
 * var isRemoteRead = nim.isMsgRemoteRead(msg);
 */
NIMFn.isMsgRemoteRead = function (msg) {
  return this.protocol.isMsgRemoteRead(msg);
};

/**
 * 撤回消息
 *
 * - {@link NIM#deleteMsg|撤回消息}后, 消息接收方会收到一条类型为`'deleteMsg'`的{@link SystemMessage|系统通知}, 此类系统通知的 `msg` 为被删除的消息的部分字段。如果是群消息, 那么群里的所有人都会收到这条系统通知. 如果同时在多个端登录了同一个账号, 那么其它端也会收到这条系统通知.
 *
 * @memberOf NIM#
 * @method deleteMsg
 *
 * @param  {Object} options  配置参数
 * @param {IMMessage} options.msg 待撤回的消息
 * @param {Function} options.done 结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteMsg({
 *   msg: someMsg,
 *   done: deleteMsgDone
 * })
 * console.log('正在撤回消息', someMsg)
 * function deleteMsgDone (error) {
 *   console.log('撤回消息' + (!error?'成功':'失败'), error);
 * }
 */
NIMFn.deleteMsg = function (options) {
  var self = this;
  util.verifyOptions(options, 'msg', 'msg::deleteMsg');
  var msg = options.msg;
  // 过滤
  if (msg.scene !== 'team' && msg.flow !== 'out' || msg.status !== 'success' || msg.from === msg.to || msg.isLocal) {
    return options.done(NIMError.newParamError('只能删除自己发送给别人的, 并且发送成功的非本地消息', { callFunc: 'msg::deleteMsg' }), options);
  }
  util.verifyOptions(msg, ['scene', 'to', 'from', 'time', 'idClient', 'idServer'], true, 'msg.', 'msg::deleteMsg');
  util.verifyParamValid('msg.scene', msg.scene, self.message.validScenes, 'msg::deleteMsg');
  var sysMsg = util.simpleClone(msg);
  this.processPs(sysMsg);
  this.processCallback(options);
  if (notundef(options.opeAccount)) {
    sysMsg.opeAccount = options.opeAccount;
  } else if (undef(sysMsg.opeAccount)) {
    sysMsg.opeAccount = sysMsg.from;
  }
  if (sysMsg.scene === 'p2p') {
    sysMsg.type = 'deleteMsgP2p';
  } else {
    sysMsg.type = 'deleteMsgTeam';
  }
  sysMsg.deletedIdClient = sysMsg.idClient;
  sysMsg.deletedIdServer = sysMsg.idServer;
  sysMsg = new SystemMessage(sysMsg);
  self.sendCmd('deleteMsg', { sysMsg: sysMsg, msg: msg }, options.callback);
};

/**
 * 获取云端历史记录
 *
 * - 该接口用于获取一段时间内的历史消息, 由参数`beginTime`和`endTime`来控制时间范围。
 *     - 当`reverse`为`false`时, 后续查询的`endTime`对应上次查询的最后一条消息的`time`字段
 *     - 当`reverse`为`true`时, 后续查询的`beginTime`对应上次查询的最后一条消息的`time`字段
 * - 如果要搜索历史消息, 请参考{@link NIM#searchHistoryMsgs|获取包含关键词的历史消息}
 *
 * @method getHistoryMsgs
 * @memberOf NIM#
 *
 * @param  {Object}     options                 配置参数
 * @param  {String}     options.scene           请参考{@link IMMessage.scene|消息场景}
 * @param  {String}     options.to              聊天对象, 账号或者群id
 * @param  {Number}     [options.beginTime]     时间戳, 开始时间, 精确到ms, 默认为0
 * @param  {Number}     [options.endTime]       时间戳, 结束时间, 精确到ms, 默认为服务器的当前时间
 * @param  {String}     [options.lastMsgId]     上次查询的最后一条消息的`idServer`, 第一次不填
 * @param  {Number}     [options.limit]         本次查询的消息数量限制, 最多100条, 默认100条
 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从`endTime`开始往前查找历史消息;
 *                                              `true`表示从`beginTime`开始往后查找历史消息
 * @param  {Boolean}    [options.asc=false]     默认`false`表示返回的消息按时间逆序排序;
 *                                              `true`表示按时间正序排序
 * @param  {StringArray} [options.msgTypes=['text', 'image', ...]] 消息类型列表，默认全部消息类型
 * @param  {done}       options.done            结果回调函数, 成功时会额外附上{@link IMMessage|消息}列表
 * @return {Void}
 *
 * @example
 * nim.getHistoryMsgs({
 *     scene: 'p2p',
 *     to: 'account',
 *     done: getHistoryMsgsDone
 * });
 * function getHistoryMsgsDone(error, obj) {
 *     console.log('获取云端历史记录' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         console.log(obj.msgs);
 *     }
 * }
 */
var msgTypes = {
  text: 0,
  image: 1,
  audio: 2,
  video: 3,
  geo: 4,
  notification: 5,
  file: 6,
  tip: 10,
  robot: 11,
  custom: 100
};

NIMFn.getHistoryMsgs = function (options) {
  var self = this;
  util.verifyOptions(options, 'scene to', 'msg::getHistoryMsgs');
  util.verifyParamValid('scene', options.scene, self.message.validScenes, 'msg::getHistoryMsgs');
  if (typeof options.beginTime === 'undefined') {
    options.beginTime = 0;
  }
  util.verifyParamType('beginTime', options.beginTime, 'number', 'msg::getHistoryMsgs');
  if (typeof options.endTime === 'undefined') {
    options.endTime = 0;
  }
  util.verifyParamType('endTime', options.endTime, 'number', 'msg::getHistoryMsgs');

  if (typeof options.lastMsgId === 'undefined' || options.lastMsgId === null) {
    options.lastMsgId = '0';
  }

  if (typeof options.limit === 'undefined') {
    options.limit = 100;
  }
  util.verifyParamType('limit', options.limit, 'number', 'msg::getHistoryMsgs');
  util.verifyParamMax('limit', options.limit, 100, 'msg::getHistoryMsgs');
  if (notundef(options.reverse)) {
    util.verifyParamType('reverse', options.reverse, 'boolean', 'msg::getHistoryMsgs');
  } else {
    options.reverse = false;
  }
  if (notundef(options.asc)) {
    util.verifyParamType('asc', options.asc, 'boolean', 'msg::getHistoryMsgs');
  } else {
    options.asc = false;
  }
  if (undef(options.msgTypes)) {
    options.msgTypes = [];
  } else if (Array.isArray(options.msgTypes)) {
    options.msgTypes = options.msgTypes.map(function (item) {
      return msgTypes[item];
    });
    options.msgTypes = options.msgTypes.filter(function (item) {
      return typeof item === 'number';
    });
  } else {
    if (typeof msgTypes[options.msgTypes] === 'number') {
      options.msgTypes = [msgTypes[options.msgTypes]];
    } else {
      options.msgTypes = [];
    }
  }
  self.processCallback(options);

  if (options.asc) {
    options.cbaop = function (error, obj) {
      if (!error) {
        obj.msgs = obj.msgs.reverse();
      }
    };
  }

  var cmd;
  switch (options.scene) {
    case 'p2p':
      cmd = 'getHistoryMsgs';
      break;
    case 'team':
      cmd = 'getTeamHistoryMsgs';
      break;
    case 'superTeam':
      cmd = 'getSuperTeamHistoryMsgs';
      break;
    default:
      break;
  }
  var content = {
    scene: options.scene,
    to: options.to,
    beginTime: options.beginTime,
    endTime: options.endTime,
    lastMsgId: options.lastMsgId,
    limit: options.limit,
    reverse: options.reverse,
    msgTypes: options.msgTypes
  };
  self.sendCmd(cmd, content, options.callback);
};

/**
 * 获取云端包含关键词的历史记录
 *
 * - 跟{@link NIM#getHistoryMsgs|获取历史消息}接口类似, 只是去掉了参数`lastMsgId`, 增加了参数`keyword(要搜索的关键词)`
 *
 * @method searchHistoryMsgs
 * @memberOf NIM#
 * @private
 *
 * @param  {Object}     options 配置参数
 * @param  {String}     options.scene           {@link IMMessage.scene|场景}
 * @param  {String}     options.to              聊天对象, 账号或者群id
 * @param  {String}     options.keyword         待搜索的关键词
 * @param  {Number}     [options.beginTime]     时间戳, 开始时间, 精确到ms, 默认为0
 * @param  {Number}     [options.endTime]       时间戳, 结束时间, 精确到ms, 默认为服务器的当前时间
 * @param  {Number}     [options.limit]         本次查询的消息数量限制, 最多100条, 默认100条
 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从`endTime`开始往前查找历史消息;
 *                                              `true`表示从`beginTime`开始往后查找历史消息
 * @param  {Boolean}    [options.asc=false]     默认`false`表示返回的消息按时间逆序排序;
 *                                              `true`表示按时间正序排序
 * @param  {done}       options.done            结果回调函数, 成功时会额外附上{@link IMMessage|消息}列表
 * @return {Void}
 *
 * @example
 * nim.searchHistoryMsgs({
 *     scene: 'p2p',
 *     to: 'account',
 *     keyword: 'keyword',
 *     done: searchHistoryMsgsDone
 * });
 * function searchHistoryMsgsDone(error, obj) {
 *     console.log('获取云端包含关键词的历史记录' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         console.log(obj.msgs);
 *     }
 * }
 */
NIMFn.searchHistoryMsgs = function (options) {
  var self = this;
  util.verifyOptions(options, 'scene to keyword', 'msg::searchHistoryMsgs');
  util.verifyParamValid('scene', options.scene, self.message.validScenes, 'msg::searchHistoryMsgs');
  if (typeof options.beginTime === 'undefined') {
    options.beginTime = 0;
  }
  util.verifyParamType('beginTime', options.beginTime, 'number', 'msg::searchHistoryMsgs');
  if (typeof options.endTime === 'undefined') {
    options.endTime = 0;
  }
  util.verifyParamType('endTime', options.endTime, 'number', 'msg::searchHistoryMsgs');
  if (typeof options.limit === 'undefined') {
    options.limit = 100;
  }
  util.verifyParamType('limit', options.limit, 'number', 'msg::searchHistoryMsgs');
  util.verifyParamMax('limit', options.limit, 100, 'msg::searchHistoryMsgs');
  if (notundef(options.reverse)) {
    util.verifyParamType('reverse', options.reverse, 'boolean', 'msg::searchHistoryMsgs');
  } else {
    options.reverse = false;
  }
  if (notundef(options.asc)) {
    util.verifyParamType('asc', options.asc, 'boolean', 'msg::searchHistoryMsgs');
  } else {
    options.asc = false;
  }
  self.processCallback(options);

  if (options.asc) {
    options.cbaop = function (error, obj) {
      if (!error) {
        obj.msgs = obj.msgs.reverse();
      }
    };
  }

  var cmd;
  switch (options.scene) {
    case 'p2p':
      cmd = 'searchHistoryMsgs';
      break;
    case 'team':
      cmd = 'searchTeamHistoryMsgs';
      break;
    default:
      break;
  }
  var content = util.filterObj(options, 'scene to beginTime endTime keyword limit reverse');
  self.sendCmd(cmd, content, options.callback);
};

/**
 * 获取本地历史记录
 * - 如果不{@link support.db|支持数据库}, 算成功, 返回空数组
 *
 * @method getLocalMsgs
 * @memberOf NIM#
 *
 * @param  {Object}     options                     配置参数
 *  @param {String} [options.sessionId] 如果提供该参数, 那么查询该会话的消息
 *  @param {Number} [options.start=0] 开始时间
 *  @param {Number} [options.end=Infinity] 结束时间
 *  @param {Boolean} [options.desc=true] true 表示从 end 开始查, false 表示从 begin 开始查
 *  @param {Number} [options.limit=100] limit 数量限制
 *  @param {String} [options.type] {@link IMMessage.type|消息类型}, [indexedDB专用]如果提供该参数, 那么查询该类型的消息
 *  @param {String[]} [options.types] [indexedDB专用]如果提供该参数, 那么查询这几种类型的消息
 *  @param {String} [options.keyword] [indexedDB专用]如果提供参数, 那么查询匹配该关键词的消息
 *  @param {Function} [options.filterFunc] [indexedDB专用]可选参数, 过滤函数, 接收消息对象, 返回 true 表示结果保留该消息
 * @param  {done} options.done 结果回调函数, 成功时会附上{@link IMMessage|消息}列表
 * @return {Void}
 *
 * @example
 * nim.getLocalMsgs({
 *   sessionId: 'p2p-account'
 *   limit: 100,
 *   done: getLocalMsgsDone
 * })
 * function getLocalMsgsDone(error, obj) {
 *   console.log('获取本地消息' + (!error?'成功':'失败'), error, obj)
 * }
 */
NIMFn.getLocalMsgs = function (options) {
  var self = this;
  var db = self.db;
  var error = null;
  var msgs = [];

  util.verifyOptions(options);
  // start & end
  var hasStart = false;
  if (notundef(options.start)) {
    hasStart = true;
    util.verifyParamType('start', options.start, 'number', 'msg::getLocalMsgs');
  }
  var hasEnd = false;
  if (notundef(options.end)) {
    hasEnd = true;
    util.verifyParamType('end', options.end, 'number', 'msg::getLocalMsgs');
  }
  if (hasStart && hasEnd && options.end <= options.start) {
    util.onParamError('参数 end 必须晚于 start');
  }
  // limit
  if (undef(options.limit)) {
    options.limit = 100;
  }
  util.verifyParamType('limit', options.limit, 'number', 'msg::getLocalMsgs');
  util.verifyParamMin('limit', options.limit, 1, 'msg::getLocalMsgs');
  // 不指定最大数量限制, 由调用方负责, 数量大的话时间久
  // util.verifyParamMax('limit', options.limit, 100, 'msg::getLocalMsgs')
  self.processCallback(options);

  if (db.enable) {
    db.getMsgs(options).then(function (records) {
      msgs = records;
      bingo();
    }, function (error) {
      error = error || {};
      error.message = error.message || 'msg::getLocalMsgs:db error';
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    var obj = util.simpleClone(options);
    obj.msgs = msgs;
    delete obj.callback;
    delete obj.done;
    options.done(error, obj);
  }
};

/**
 * 获取 idClient 对应的本地消息
 * - 如果不{@link support.db|支持数据库}, 算成功, 返回 null
 *
 * @method getLocalMsgByIdClient
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String}     options.idClient    idClient
 * @param  {Function}   options.done        结果回调函数, 成功时会额外附上{@link IMMessage|消息}
 * @return {Void}
 *
 * @example
 * nim.getLocalMsgByIdClient({
 *     idClient: 'd7a1b2c63066e1038e9aa01321652370',
 *     done: getLocalMsgByIdClientDone
 * });
 * function getLocalMsgByIdClientDone(error, obj) {
 *     console.log('获取本地消息' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         console.log(obj.msg);
 *     }
 * }
 */
NIMFn.getLocalMsgByIdClient = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var msg = null;
  util.verifyOptions(options, 'idClient', 'msg::getLocalMsgByIdClient');
  self.processCallback(options);
  if (db.enable) {
    db.getMsgByIdClient(options.idClient).then(function (record) {
      if (record) {
        msg = record;
      }
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.msg = msg;
    options.done(error, options);
  }
};

/**
 * 获取 idClients 对应的本地消息
 * - 如果不{@link support.db|支持数据库}, 算成功, 返回空数组
 *
 * @method getLocalMsgsByIdClients
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String[]}   options.idClients   idClients
 * @param  {Function}   options.done        结果回调函数, 成功时会额外附上{@link IMMessage|消息}列表
 * @return {Void}
 *
 * @example
 * nim.getLocalMsgsByIdClients({
 *     idClients: [
 *         'd7a1b2c63066e1038e9aa01321652370',
 *         '22e604c7811c23586355f63f24658525'
 *     ],
 *     done: getLocalMsgsByIdClientsDone
 * });
 * function getLocalMsgsByIdClientsDone(error, obj) {
 *     console.log('获取本地消息' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         console.log(obj.msgs);
 *     }
 * }
 */
NIMFn.getLocalMsgsByIdClients = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var msgs = [];
  util.verifyOptions(options, 'idClients', 'msg::getLocalMsgByIdClient');
  util.verifyParamType('idClients', options.idClients, 'array', 'msg::getLocalMsgByIdClient');
  self.processCallback(options);
  if (db.enable) {
    db.getMsgsByIdClients(options.idClients).then(function (records) {
      msgs = records.filter(function (record) {
        return !!record;
      });
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.msgs = msgs;
    options.done(error, options);
  }
};

/**
 * 更新本地消息
 * - 更新 `idClient` 对应的本地消息
 * - 如果不{@link support.db|支持数据库}, 算成功
 * - 如果对应的消息不存在, 算成功, 返回 null
 * - 这些字段只会被更新到本地数据库, 不会被更新到服务器上
 *
 * @method updateLocalMsg
 * @memberOf NIM#
 *
 * @param  {Object}     options                 配置参数
 * @param  {String}     options.idClient        idClient
 * @param {String}      [options.localCustom]   自定义字段
 * @param  {Function}   options.done            结果回调函数, 成功时会额外附上{@link IMMessage|消息}
 * @return {Void}
 *
 * @example
 * nim.updateLocalMsg({
 *     idClient: 'p2p-account',
 *     localCustom: '{"key","value"}',
 *     done: updateLocalMsgDone
 * });
 * function updateLocalMsgDone(error, obj) {
 *     console.log('更新本地消息' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.updateLocalMsg = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var msg = null;
  util.verifyOptions(options, 'idClient', 'msg::updateLocalMsg');
  self.processCallback(options);
  if (db.enable) {
    var obj = util.filterObj(options, 'idClient localCustom');
    db.updateMsg(obj).then(function (record) {
      msg = record;
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.msg = msg;
    options.done(error, options);
  }
};

/**
 * 删除本地消息
 * - 在{@link support.db|支持数据库}时
 *     - 如果删除的是对应会话的最后一条消息, 那么对应会话的 `lastMsg` 属性会自动变为变为上一条消息, 同时触发 `onupdatesession` 回调
 *     - 如果对应的消息不存在, 算成功
 * - 如果不{@link support.db|支持数据库}, 算成功
 *
 * @method deleteLocalMsg
 * @memberOf NIM#
 *
 * @param  {Object}             options             配置参数
 * @param  {IMMessage}          options.msg         待删除的消息
 * @param  {Function}           options.done        结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteLocalMsg({
 *     msg: msg,
 *     done: deleteLocalMsgDone
 * });
 * function deleteLocalMsgDone(error, obj) {
 *     console.log('删除本地消息' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.deleteLocalMsg = function (options) {
  var self = this;
  var error;
  util.verifyOptions(options, 'msg', 'msg::deleteLocalMsg');
  var msg = options.msg;
  util.verifyOptions(msg, 'idClient sessionId', true, 'msg.', 'msg::deleteLocalMsg');
  self.processCallback(options);
  self.protocol.deleteLocalMsg(msg).then(bingo, function (event) {
    error = event;
    bingo();
  });
  function bingo() {
    options.done(error, options);
  }
};

/**
 * 删除某个会话的本地消息
 *
 * - 如果不{@link support.db|支持数据库}, 算成功
 *
 * @method deleteLocalMsgsBySession
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.scene   {@link IMMessage.scene|场景}
 * @param  {String}     options.to      聊天对象, 账号或者群id
 * @param  {Boolean}    options.delLastMsg   是否同时删除本地会话对象中的的lastMsg
 * @param  {Function}   options.done    结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteLocalMsgsBySession({
 *     scene: 'p2p',
 *     to: 'account',
 *     delLastMsg: true,
 *     done: deleteLocalMsgsBySessionDone
 * });
 * function deleteLocalMsgsBySession(error, obj) {
 *     console.log('删除会话本地消息' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.deleteLocalMsgsBySession = function (options) {
  var self = this;
  var db = self.db;
  var error;
  util.verifyOptions(options, 'scene to', 'msg::deleteLocalMsgsBySession');
  util.verifyParamValid('scene', options.scene, self.message.validScenes, 'msg::deleteLocalMsgsBySession');
  options.sessionId = options.scene + '-' + options.to;
  options.delLastMsg = options.delLastMsg === true;
  self.processCallback(options);
  function dealError(event) {
    error = event;
    bingo();
  }
  function bingo() {
    options.done(error, options);
  }
  if (db.enable) {
    db.deleteMsgsBySessionId(options).then(function () {
      if (options.delLastMsg) {
        db.updateSession({
          id: options.sessionId,
          lastMsg: null
        }).then(function (session) {
          self.protocol.onUpdateSession(session);
          options.session = session;
          bingo();
        }, dealError);
      } else {
        bingo();
      }
    }, dealError);
  } else {
    if (options.delLastMsg) {
      // 无数据库时也需要删除会话的lastMsg
      self.protocol.onUpdateSession({
        id: options.sessionId,
        lastMsg: null
      });
    }
    bingo();
  }
};

/**
 * 删除所有本地消息
 * - 如果不{@link support.db|支持数据库}, 算成功
 * - 此方法同时会清空所有的会话, 请开发者自己清空内存里面的会话列表
 *
 * @method deleteAllLocalMsgs
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @return {Void}
 *
 * @example
 * nim.deleteAllLocalMsgs({
 *     done: deleteAllLocalMsgsDone
 * });
 * function deleteAllLocalMsgsDone(error, obj) {
 *     console.log('删除所有本地消息' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.deleteAllLocalMsgs = function (options) {
  var self = this;
  var db = self.db;
  var error;
  self.processCallback(options);
  if (db.enable) {
    db.deleteAllMsgs().then(function () {
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  }
  function bingo() {
    options.done(error, options);
  }
};

/**
 * 删除单人会话服务器聊天记录
 *
 * @method clearServerHistoryMsgs
 * @memberOf NIM#
 *
 * @param  {Object}     options 配置参数
 * @param  {String}     options.account   对方账号
 * @param  {Boolean}    options.delRoam     是否同时删除漫游，默认`true`
 * @param  {Function}   options.done    结果回调函数
 * @return {Void}
 *
 * @example
 * nim.clearServerHistoryMsgs({
 *     account: 'xxx',
 *     delRoam: false,
 *     done: clearServerHistoryMsgsDone
 * });
 * function clearServerHistoryMsgsDone(error, obj) {
 *     console.log('删除服务器消息' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.clearServerHistoryMsgs = function (options) {
  var self = this;
  util.verifyOptions(options, 'account', 'msg::clearServerHistoryMsgs');
  var delRoam = !(options.delRoam === false);
  self.processCallback(options);
  self.sendCmd('clearServerHistoryMsgs', {
    clearMsgsParams: {
      account: options.account,
      delRoam: delRoam ? 1 : 0
    }
  }, options.callback);
};

/***/ }),

/***/ "./src/im/api/nim/nos.js":
/*!*******************************!*\
  !*** ./src/im/api/nim/nos.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * 修改图片下载的名字
 *
 * @memberOf NIM#
 * @method packFileDownloadName
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {String} options.name    下载的名字
 * @return {String}                 修改图片下载名字后的图片 url
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var nameUrl = nim.packFileDownloadName({
 *     url: url,
 *     name: '测试.jpg'
 * });
 * console.log(nameUrl);
 */

/**
 * 将音频 url 转为 mp3
 * - 此方法会返回一个新的 url
 * @memberOf NIM#
 * @method audioToMp3
 *
 * @param {Object} options 配置参数
 * @param {String} options.url url
 * @return {String} 转为 mp3 后的 url
 *
 * @example
 * var url = 'http://b12026.nos.netease.com/MTAxMTAxMA==/bmltYV8xMTQwMzFfMTQ1MTg4ODk5MjMxMV9mNmI1Y2QyZC03N2UzLTQxNmUtYWY5NC1iODlhZGY4ZTYzYWQ=';
 * var mp3Url = nim.audioToMp3({
 *     url: url
 * });
 * console.log(mp3Url);
 */

/**
 * 去除图片元信息
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 去除元信息后的图片将不包含 [EXIF](https://en.wikipedia.org/wiki/Exchangeable_image_file_format) 信息
 *
 * @memberOf NIM#
 * @method stripImageMeta
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {done}   options.done    结果回调函数, 成功时附上 interlace 后的图片 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var interlaceUrl = nim.stripImageMeta({
 *     url: url,
 *     strip: true,
 *     done: stripImageMetaDone
 * });
 * function stripImageMetaDone(error, obj) {
 *     console.log('去除图片元信息' + (!error?'成功':'失败'), error, obj);
 * }
 */

/**
 * 修改图片质量
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 默认图片质量为100, 开发者可以降低图片质量来省流量
 *
 * @memberOf NIM#
 * @method qualityImage
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Int}    options.quality 图片质量, 必须为整数, 取值范围为 0-100, 此方法内部使用 Math.round 来格式化 quality
 * @param  {done}   options.done    结果回调函数, 成功时附上修改质量后的图片 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var qualityUrl = nim.qualityImage({
 *     url: url,
 *     quality: 20,
 *     done: qualityImageDone
 * });
 * function qualityImageDone(error, obj) {
 *     console.log('修改图片质量' + (!error?'成功':'失败'), error, obj);
 * }
 */

/**
 * interlace 图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 在网络环境较差时, interlace 后的图片会以从模糊到清晰的方式呈现给用户
 *
 * @memberOf NIM#
 * @method interlaceImage
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {done}   options.done    结果回调函数, 成功时附上 interlace 后的图片 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var interlaceUrl = nim.interlaceImage({
 *     url: url,
 *     done: interlaceImageDone
 * });
 * function interlaceImageDone(error, obj) {
 *     console.log('interlace 图片' + (!error?'成功':'失败'), error, obj);
 * }
 */

/**
 * 旋转图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 *
 * @memberOf NIM#
 * @method rotateImage
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Int}    options.angle   旋转的角度, 正整数表示顺时针, 负整数表示逆时针, 必须为整数, 此方法内部会先将 angle 格式化为 [0, 360] 范围内的数字, 然后使用 Math.round 来格式化 angle
 * @param  {done}   options.done    结果回调函数, 成功时附上旋转后的图片的 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var rotateUrl = nim.rotateImage({
 *     url: url,
 *     angle: 90,
 *     done: rotateImageDone
 * });
 * function rotateImageDone(error, obj) {
 *     console.log('旋转图片' + (!error?'成功':'失败'), error, obj);
 * }
 */

/**
 * 高斯模糊图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 *
 * @memberOf NIM#
 * @method blurImage
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Number} radius          高斯模糊半径, 不包含中心点的像素, 取值范围 [1,50]
 * @param  {Number} sigma           高斯模糊标准差, 不能小于 0
 * @param  {done}   options.done    结果回调函数, 成功时附上高斯模糊后的图片 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var blurUrl = nim.blurImage({
 *     url: url,
 *     radius: 5,
 *     sigma: 3,
 *     done: blurImageDone
 * });
 * function blurImageDone(error, obj) {
 *     console.log('高斯模糊图片' + (!error?'成功':'失败'), error, obj);
 * }
 */

/**
 * 裁剪图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 从坐标 (x, y) 处截取尺寸为 width*height 的图片, (0, 0) 代表左上角
 * - width/height 不能小于0, 如果 width/height 大于图片的原始宽度/高度, 那么将被替换为图片的原始宽度/高度
 *
 * @memberOf NIM#
 * @method cropImage
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Int}    options.x       起点坐标 x, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @param  {Int}    options.y       起点坐标 y, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @param  {Int}    options.width   宽度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @param  {Int}    options.height  高度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @param  {done}   options.done    结果回调函数, 成功时附上裁剪后的图片的 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var cropUrl = nim.cropImage({
 *     url: url,
 *     x: 100,
 *     y: 0,
 *     width: 250,
 *     height: 250,
 *     done: function cropImageDone
 * });
 * function cropImageDone(error, obj) {
 *     console.log('裁剪图片' + (!error?'成功':'失败'), error, obj);
 * }
 */

/**
 * 生成缩略图
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - width/height 限制了缩略图的尺寸
 *     - width/height 必须大于等于 0, 不能同时为 0, 必须小于 4096
 * - 不同模式下生成的缩略图是不一样的, 目前支持以下三种模式
 *     - `'cover'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边大于请求的尺寸, 即缩略图刚好能覆盖住尺寸为 width*height 的矩形
 *     - `'contain'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边小于请求的尺寸, 即尺寸为 width*height 的矩形刚好能覆盖住缩略图
 *     - `'crop'`: 先等比缩略原图片, 使得一边等于请求的尺寸, 另一边大于请求的尺寸, 然后对大于请求尺寸的那条边进行裁剪, 使得最终的图片大小刚好等于请求的尺寸
 * - 如果缩略图尺寸大于图片尺寸, 默认情况下图片不会被放大, 可以传入参数`enlarge=true`来放大图片
 * - `'crop'` 模式下可以传入参数 axis.x 或 axis.y 来控制最后一步裁剪的位置
 *     - x/y 必须为整数, 取值范围为 0-10, 此方法内部使用 Math.round 来格式化 x/y
 *     - x 为 0 时表示裁取最左端, x 为 10 时表示裁取最右端
 *     - y 为 0 时表示裁取最上端, y 为 10 时表示裁取最下端
 *     - x/y 默认值均为 5, 即裁取正中间
 *
 * @memberOf NIM#
 * @method thumbnailImage
 *
 * @param  {Object}     options                 配置参数
 * @param  {String}     options.url             原图 url
 * @param  {Int}        [options.width]         缩略图的最大宽度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
 * @param  {Int}        [options.height]        缩略图的最大高度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
 * @param  {String}     options.mode            缩略模式, 目前支持以下三种模式, 请参考上面的描述
 * - `'cover'`
 * - `'contain'`
 * - `'crop'`
 * @param  {Int}        [options.axis.x]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
 * @param  {Int}        [options.axis.y]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
 * @param  {Boolean}    [options.enlarge=false] 当图片尺寸小于要缩略的尺寸时, 是否放大图片, 默认`false`不放大
 * @param  {done}       options.done            结果回调函数, 成功时附上缩略后的图片 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var thumbnailUrl = nim.thumbnailImage({
 *     url: url,
 *     mode: 'cover',
 *     width: 80,
 *     height: 100,
 *     done: thumbnailImageDone
 * });
 * function thumbnailImageDone(error, obj) {
 *     console.log('生成缩略图' + (!error?'成功':'失败'), error, obj);
 * }
 */

/**
 * 处理图片
 *
 * 此方法接收一组图片操作, 按操作顺序依次处理图片, 可选的操作包括：
 * - {@link NIM#qualityImage|修改图片质量}
 * - {@link NIM#interlaceImage|interlace 图片}
 * - {@link NIM#rotateImage|旋转图片}
 * - {@link NIM#blurImage|高斯模糊图片}
 * - {@link NIM#cropImage|裁剪图片}
 * - {@link NIM#thumbnailImage|生成缩略图}
 * - {@link NIM#previewFile|预览文件}
 * - {@link NIM#sendFile|发送文件消息}
 *
 * 每个操作所需的参数请参考上面的各个方法, 除了上面方法列出来的参数之外, 每个操作需要提供操作类型, 分别是
 * - `'quality'`
 * - `'interlace'`
 * - `'rotate'`
 * - `'blur'`
 * - `'crop'`
 * - `'thumbnail'`
 *
 * 请参考下面的示例代码
 *
 * @memberOf NIM#
 * @method processImage
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Array}  options.ops     操作序列
 * @param  {done}   options.done    结果回调函数, 成功时附上处理后的图片 url
 * @return {Void}
 *
 * @example
 * // 裁剪后旋转
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * nim.processImage({
 *     url: url,
 *     ops: [
 *         {
 *             type: 'crop',
 *             x: 100,
 *             y: 0,
 *             width: 250,
 *             height: 250,
 *         },
 *         {
 *             type: 'thumbnail',
 *             mode: 'cover',
 *             width: 80,
 *             height: 80
 *         }
 *     ],
 *     done: processImageDone
 * });
 * function processImageDone(error, obj) {
 *     console.log('处理图片' + (!error?'成功':'失败'), error, obj);
 * }
 */


/***/ }),

/***/ "./src/im/api/nim/nosViewImage.js":
/*!****************************************!*\
  !*** ./src/im/api/nim/nosViewImage.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * 预览去除图片元信息
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 去除元信息后的图片将不包含 [EXIF](https://en.wikipedia.org/wiki/Exchangeable_image_file_format) 信息
 *
 * @memberOf NIM#
 * @method viewImageStripMeta
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {done}   options.done    结果回调函数, 成功时附上 interlace 后的图片 url
 * @return {Void}
 *
 * @example
 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var stripMetaUrl = nim.viewImageStripMeta({
 *     url: url,
 *     strip: true
 * });
 */

/**
 * 预览图片质量
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 默认图片质量为100，开发者可以降低图片质量来省流量
 *
 * @memberOf NIM#
 * @method viewImageQuality
 * @private
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Int}    options.quality 图片质量, 必须为整数, 取值范围为 0-100, 此方法内部使用 Math.round 来格式化 quality
 * @return {String}                 修改图片质量后的图片 url
 *
 * @example
 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var qualityUrl = nim.viewImageQuality({
 *     url: url,
 *     quality: 20
 * });
 * // 修改图片质量后的图片 url 如下
 * // qualityUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&quality=20'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的修改图片质量的结果
 */

/**
 * 预览interlace图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 在网络环境较差时, interlace 后的图片会以从模糊到清晰的方式呈现给用户
 *
 * @memberOf NIM#
 * @method viewImageInterlace
 * @private
 *
 * @param  {Object} options     配置参数
 * @param  {String} options.url 原图 url
 * @return {String}             interlace 后的图片 url
 *
 * @example
 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var interlaceUrl = nim.viewImageInterlace({
 *     url: url
 * });
 * // interlace 后的图片 url 如下
 * // interlaceUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&interlace=1'
 */

/**
 * 预览旋转图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 *
 * @memberOf NIM#
 * @method viewImageRotate
 * @private
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Int}    options.angle   旋转的角度, 正整数表示顺时针, 负整数表示逆时针, 必须为整数, 此方法内部会先将 angle 格式化为 [0, 360] 范围内的数字, 然后使用 Math.round 来格式化 angle
 * @return {String}                 旋转后的图片的 url
 *
 * @example
 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var rotateUrl = nim.viewImageRotate({
 *     url: url,
 *     angle: 90
 * });
 * // 旋转后的图片的 url 如下
 * // rotateUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&rotate=90'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的旋转结果
 */

/**
 * 预览高斯模糊图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 *
 * @memberOf NIM#
 * @method viewImageBlur
 * @private
 *
 * @param  {Object} options     配置参数
 * @param  {String} options.url 原图 url
 * @param  {Number} radius      高斯模糊半径, 不包含中心点的像素, 取值范围 [1,50]
 * @param  {Number} sigma       高斯模糊标准差, 不能小于 0
 * @return {String}             高斯模糊后的图片 url
 *
 * @example
 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var blurUrl = nim.viewImageBlur({
 *     url: url,
 *     radius: 5,
 *     sigma: 3
 * });
 * // 高斯模糊后的图片 url 如下
 * // blurUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&blur=5x3'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的高斯模糊后的结果
 */

/**
 * 预览裁剪图片
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - 从坐标 (x, y) 处截取尺寸为 width*height 的图片，(0, 0) 代表左上角
 * - width/height 不能小于0, 如果 width/height 大于图片的原始宽度/高度, 那么将被替换为图片的原始宽度/高度
 * - 举个栗子, 假如说之前通过{@link NIM#previewFile|预览文件}拿到的 url 为
 *     {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=}
 * - 传入 x/y/width/height 为 100/0/250/250 得到的裁剪图片的 url 为
 *     {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&crop=100_0_250_250|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&crop=100_0_250_250}
 * - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
 *
 * @memberOf NIM#
 * @method viewImageCrop
 * @private
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.url     原图 url
 * @param  {Int}    options.x       起点坐标 x, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @param  {Int}    options.y       起点坐标 y, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @param  {Int}    options.width   宽度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @param  {Int}    options.height  高度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
 * @return {String}                 裁剪后的图片的 url
 *
 * @example
 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var cropUrl = nim.viewImageCrop({
 *     url: url,
 *     x: 100,
 *     y: 0,
 *     width: 250,
 *     height: 250
 * });
 * // 裁剪后的图片的 url 如下
 * // cropUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&crop=100_0_250_250'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
 */

/**
 * 预览生成缩略图
 *
 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
 * - width/height 限制了缩略图的尺寸
 *     - width/height 必须大于等于 0, 不能同时为 0, 必须小于 4096
 * - 不同模式下生成的缩略图是不一样的, 目前支持以下三种模式
 *     - `'cover'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边大于请求的尺寸, 即缩略图刚好能覆盖住尺寸为 width*height 的矩形
 *         - 举个栗子, 假如说之前通过{@link NIM#previewFile|预览文件}拿到的 url 为
 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=}
 *         - 此模式下传入 80*100 的尺寸得到的缩略图 url 为
 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80z100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80z100}
 *         - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同尺寸得到的缩略图
 *     - `'contain'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边大于请求的尺寸, 即尺寸为 width*height 的矩形刚好能覆盖住缩略图
 *         - 还是拿上面的 url 为例, 传入 80*100 的尺寸得到的缩略图 RUL 为
 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80x100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80x100}
 *         - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同尺寸得到的缩略图
 *     - `'crop'`: 先等比缩略原图片, 使得一边等于请求的尺寸, 另一边大于请求的尺寸, 然后对大于请求尺寸的那条边进行裁剪, 使得最终的图片大小刚好等于请求的尺寸
 *         - 还是拿上面的 url 为例, 传入 80*100 的尺寸得到的缩略图 url 为
 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100}
 *         - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同尺寸得到的缩略图
 * - 如果缩略图尺寸大于图片尺寸，默认情况下图片不会被放大，可以传入参数`enlarge=true`来放大图片
 *     - 举个栗子, 假如说之前通过{@link NIM#previewFile|预览文件}拿到的 url 为
 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=}
 *     - 此 url 对应的图片尺寸为 512-256, 如果使用 `'cover'` 模式来裁剪, 传入尺寸 1024-512, 得到的缩略图 url 为
 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512}
 *     - 会发现图片尺寸并没有放大, 如果再传入参数 `enlarge=true`, 得到的缩略图 url 为
 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512&enlarge=1|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512&enlarge=1}
 *     - 会发现图片被放大了
 * - `'crop'` 模式下可以传入参数 axis.x 或 axis.y 来控制最后一步裁剪的位置
 *     - x/y 必须为整数, 取值范围为 0-10, 此方法内部使用 Math.round 来格式化 x/y
 *     - x 为 0 时表示裁取最左端, x 为 10 时表示裁取最右端
 *     - y 为 0 时表示裁取最上端, y 为 10 时表示裁取最下端
 *     - x/y 默认值均为 5, 即裁取正中间
 *     - 拿上面的 url 为例, 传入 80*100 的尺寸得到的缩略图 url 为
 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100}
 *         - 依次传入 x=0,1,2,3,4,5,6,7,8,9,10 得到的缩略图 url 为
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=0_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=0_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=1_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=1_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=2_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=2_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=3_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=3_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=4_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=4_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=5_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=5_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=6_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=6_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=7_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=7_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=8_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=8_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=9_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=9_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=10_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=10_5}
 *     - 拿上面的 url 为例, 传入 200*50 的尺寸得到的缩略图 RUL 为
 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50}
 *         - 依次传入 y=0,1,2,3,4,5,6,7,8,9,10 得到的缩略图 url 为
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_0|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_0}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_1|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_1}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_2|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_2}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_3|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_3}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_4|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_4}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_5}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_6|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_6}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_7|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_7}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_8|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_8}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_9|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_9}
 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_10|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_10}
 *
 * @memberOf NIM#
 * @method viewImageThumbnail
 * @private
 *
 * @param  {Object} options                 配置参数
 * @param  {String} options.url             原图 url
 * @param  {Int}    [options.width]         缩略图的最大宽度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
 * @param  {Int}    [options.height]        缩略图的最大高度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
 * @param  {String} options.mode            缩略模式, 目前支持以下三种模式, 请参考上面的描述
 * - `'cover'`
 * - `'contain'`
 * - `'crop'`
 * @param  {Int}    [options.axis.x]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
 * @param  {Int}    [options.axis.y]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
 * @param {Boolean} [options.enlarge=false] 当图片尺寸小于要缩略的尺寸时，是否放大图片，默认`false`不放大
 * @return {String}                         缩略图的url
 *
 * @example
 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
 * var thumbnailUrl = nim.viewImageThumbnail({
 *     url: url,
 *     mode: 'cover',
 *     width: 80,
 *     height: 100
 * });
 * // 缩略后的图片的 url 如下
 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80z100'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
 *
 * thumbnailUrl = nim.viewImageThumbnail({
 *     url: url,
 *     mode: 'contain',
 *     width: 80,
 *     height: 100
 * });
 * // 缩略后的图片的 url 如下
 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80x100'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
 *
 * thumbnailUrl = nim.viewImageThumbnail({
 *     url: url,
 *     mode: 'contain',
 *     width: 80,
 *     height: 100
 * });
 * // 缩略后的图片的 url 如下
 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
 *
 * thumbnailUrl = nim.viewImageThumbnail({
 *     url: url,
 *     mode: 'contain',
 *     width: 80,
 *     height: 100,
 *     axis: {
 *         // x 可取的值请参考上文描述
 *         x: 0
 *     }
 * });
 * // 缩略后的图片的 url 如下
 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=0_5'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
 *
 * thumbnailUrl = nim.viewImageThumbnail({
 *     url: url,
 *     mode: 'contain',
 *     width: 80,
 *     height: 100,
 *     axis: {
 *         // y 可取的值请参考上文描述
 *         y: 0
 *     }
 * });
 * // 缩略后的图片的 url 如下
 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=5_0'
 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
 */


/***/ }),

/***/ "./src/im/api/nim/notification.js":
/*!****************************************!*\
  !*** ./src/im/api/nim/notification.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var PushNotificationMultiportConfig = __webpack_require__(/*! im/model/pushNotificationMultiportConfig */ "./src/im/model/pushNotificationMultiportConfig.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;

/**
 * 获取当前多端推送配置选项
 *
 * @method getPushNotificationMultiportConfig
 * @memberOf NIM#
 *
 * @return {PushNotificationMultiportConfig}  多端推送配置选项
 */
NIMFn.getPushNotificationMultiportConfig = function () {
  return this.protocol.getPushNotificationMultiportConfig();
};

/**
 * 更新多端推送配置选项
 * @param  {Object} options 配置参数
 * @param {Boolean} [options.shouldPushNotificationWhenPCOnline] 桌面端在线时是否需要发送推送给手机端
 * @return {Void}
 */
NIMFn.updatePushNotificationMultiportConfig = function (options) {
  util.verifyOptions(options);
  if (undef(options.shouldPushNotificationWhenPCOnline)) {
    options.shouldPushNotificationWhenPCOnline = true;
  }
  options.donnop = new PushNotificationMultiportConfig(options);
  this.processCallback(options);
  this.sendCmd('updateDonnop', options);
};

/***/ }),

/***/ "./src/im/api/nim/relation.js":
/*!************************************!*\
  !*** ./src/im/api/nim/relation.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * 加入黑名单/从黑名单移除
 *
 * - 此接口可以完成以下两个功能, 通过参数`isAdd`来决定实际的功能
 *     - `isAdd`为`true`时, 会将`account`{@link NIM#addToBlacklist|加入黑名单}
 *         - 如果一个用户被加入了黑名单, 那么就不再会收到此用户发送的消息
 *     - `isAdd`为`false`时, 会将`account`{@link NIM#removeFromBlacklist|从黑名单移除}
 *         - 如果一个用户被从黑名单移除, 那么会重新收到此用户发送的消息
 * - 每个功能SDK都提供了相应的独立接口
 *
 * @method markInBlacklist
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.account 要加入黑名单/从黑名单移除的账号
 * @param  {Boolean}    options.isAdd   `true`表示加入黑名单, `false`表示从黑名单移除
 * @param  {done}       options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#addToBlacklist|nim.addToBlacklist}
 * @see {@link NIM#removeFromBlacklist|nim.removeFromBlacklist}
 * @see {@link NIM#getRelations|nim.getRelations}
 *
 * @example
 * nim.markInBlacklist({
 *     account: 'account',
 *     // `true`表示加入黑名单, `false`表示从黑名单移除
 *     isAdd: true,
 *     done: markInBlacklistDone
 * });
 * function markInBlacklistDone(error, obj) {
 *     console.log('将' + obj.account + (isAdd ? '加入黑名单' : '从黑名单移除') + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onMarkInBlacklist(obj);
 *     }
 * }
 */
NIMFn.markInBlacklist = function (options) {
  util.verifyOptions(options, 'account isAdd', 'relation::markInBlacklist');
  util.verifyParamType('isAdd', options.isAdd, 'boolean', 'relation::markInBlacklist');
  this.processCallback(options);
  this.sendCmd('markInBlacklist', { account: options.account, isAdd: options.isAdd }, options.callback);
};
/**
 * 加入黑名单
 *
 * - 如果一个用户被加入了黑名单, 那么就不再会收到此用户发送的消息
 * - SDK内部调用{@link NIM#markInBlacklist|nim.markInBlacklist}来完成实际工作
 *
 * @method addToBlacklist
 * @memberOf NIM#
 *
 * @param {Object}  options         配置参数
 * @param {String}  options.account 要加入黑名单的账号
 * @param {done}    options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#markInBlacklist|nim.markInBlacklist}
 * @see {@link NIM#removeFromBlacklist|nim.removeFromBlacklist}
 * @see {@link NIM#getRelations|nim.getRelations}
 *
 * @example
 * nim.addToBlacklist({
 *     account: 'account',
 *     done: addToBlacklistDone
 * });
 * function addToBlacklistDone(error, obj) {
 *     console.log('加入黑名单' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         addToBlacklist(obj);
 *     }
 * }
 */
NIMFn.addToBlacklist = function (options) {
  options.isAdd = true;
  return this.markInBlacklist(options);
};
/**
 * 从黑名单移除
 *
 * - 如果一个用户被从黑名单移除, 那么会重新收到此用户发送的消息
 * - SDK内部调用{@link NIM#markInBlacklist|nim.markInBlacklist}来完成实际工作
 *
 * @method removeFromBlacklist
 * @memberOf NIM#
 *
 * @param {Object} options         配置参数
 * @param {String} options.account 要从黑名单移除的账号
 * @param {done}   options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#markInBlacklist|nim.markInBlacklist}
 * @see {@link NIM#addToBlacklist|nim.addToBlacklist}
 * @see {@link NIM#getRelations|nim.getRelations}
 *
 * @example
 * nim.removeFromBlacklist({
 *     account: 'account',
 *     done: removeFromBlacklistDone
 * });
 * function removeFromBlacklistDone(error, obj) {
 *     console.log('从黑名单移除' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         removeFromBlacklist(obj);
 *     }
 * }
 */
NIMFn.removeFromBlacklist = function (options) {
  options.isAdd = false;
  return this.markInBlacklist(options);
};
/**
 * 加入静音列表/从静音列表移除
 *
 * - 此接口可以完成以下两个功能, 通过参数`isAdd`来决定实际的功能
 *     - `isAdd`为`true`时, 会将`account`{@link NIM#addToMutelist|加入静音列表}
 *     - `isAdd`为`false`时, 会将`account`{@link NIM#removeFromMutelist|从静音列表移除}
 * - 每个功能SDK都提供了相应的独立接口
 *
 * @method markInMutelist
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.account 要加入静音列表/从静音列表移除的账号
 * @param  {Boolean}    options.isAdd   `true`表示加入静音列表, `false`表示从静音列表移除
 * @param  {done}       options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#addToMutelist|nim.addToMutelist}
 * @see {@link NIM#removeFromMutelist|nim.removeFromMutelist}
 * @see {@link NIM#getRelations|nim.getRelations}
 *
 * @example
 * nim.markInMutelist({
 *     account: 'account',
 *     // `true`表示加入静音列表, `false`表示从静音列表移除
 *     isAdd: 'true',
 *     done: markInMutelistDone
 * });
 * function markInMutelistDone(error, obj) {
 *     console.log('将' + obj.account + (isAdd ? '加入静音列表' : '从静音列表移除') + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onMarkInMutelist(obj);
 *     }
 * }
 */
NIMFn.markInMutelist = function (options) {
  util.verifyOptions(options, 'account', 'relation::markInMutelist');
  util.verifyParamType('isAdd', options.isAdd, 'boolean', 'relation::markInMutelist');
  this.processCallback(options);
  this.sendCmd('markInMutelist', { account: options.account, isAdd: options.isAdd }, options.callback);
};
/**
 * 加入静音列表
 *
 * - SDK只负责维护静音列表, 具体要根据静音列表进行的操作由开发者决定
 * - SDK内部调用{@link NIM#markInMutelist|nim.markInMutelist}来完成实际工作
 *
 * @method addToMutelist
 * @memberOf NIM#
 *
 * @param {Object}  options         配置参数
 * @param {String}  options.account 要加入静音列表的账号
 * @param {done}    options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#markInMutelist|nim.markInMutelist}
 * @see {@link NIM#removeFromMutelist|nim.removeFromMutelist}
 * @see {@link NIM#getRelations|nim.getRelations}
 *
 * @example
 * nim.addToMutelist({
 *     account: 'account',
 *     done: addToMutelistDone
 * });
 * function addToMutelistDone(error, obj) {
 *     console.log('加入静音列表' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         addToMutelist(obj);
 *     }
 * }
 */
NIMFn.addToMutelist = function (options) {
  options.isAdd = true;
  return this.markInMutelist(options);
};
/**
 * 从静音列表移除
 *
 * - SDK只负责维护静音列表, 具体要根据静音列表进行的操作由开发者决定
 * - SDK内部调用{@link NIM#markInMutelist|nim.markInMutelist}来完成实际工作
 *
 * @method removeFromMutelist
 * @memberOf NIM#
 *
 * @param {Object} options         配置参数
 * @param {String} options.account 要从静音列表移除的账号
 * @param {done}   options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#markInMutelist|nim.markInMutelist}
 * @see {@link NIM#addToMutelist|nim.addToMutelist}
 * @see {@link NIM#getRelations|nim.getRelations}
 *
 * @example
 * nim.removeFromMutelist({
 *     account: 'account',
 *     done: removeFromMutelistDone
 * });
 * function removeFromMutelistDone(error, obj) {
 *     console.log('从静音列表移除' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         removeFromMutelist(obj);
 *     }
 * }
 */
NIMFn.removeFromMutelist = function (options) {
  options.isAdd = false;
  return this.markInMutelist(options);
};
/**
 * 获取黑名单和静音列表
 *
 * - 如果开发者在{@link NIM|初始化SDK}的时候设置了`syncRelations`为`false`, 那么就收不到`onblacklist`和`onmutelist`回调, 可以调用此接口来获取黑名单和静音列表。
 *
 * @method getRelations
 * @memberOf NIM#
 *
 * @param {Object} options         配置参数
 * @param {done}   options.done    结果回调函数, 成功时会返回黑名单和静音列表
 * @return {Void}
 *
 * @see {@link NIM#addToBlacklist|nim.addToBlacklist}
 * @see {@link NIM#removeFromBlacklist|nim.removeFromBlacklist}
 * @see {@link NIM#markInBlacklist|nim.markInBlacklist}
 * @see {@link NIM#addToMutelist|nim.addToMutelist}
 * @see {@link NIM#removeFromMutelist|nim.removeFromMutelist}
 * @see {@link NIM#markInMutelist|nim.markInMutelist}
 *
 * @example
 * nim.getRelations({
 *     done: getRelationsDone
 * });
 * function getRelationsDone(error, obj) {
 *     console.log('获取静音列表' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onBlacklist(obj.blacklist);
 *         onMutelist(obj.mutelist);
 *     }
 * }
 */
NIMFn.getRelations = function (options) {
  var self = this;
  var db = self.db;
  var timetag = 0;
  options = util.verifyOptions(options);
  self.processCallback(options);
  if (db.enable) {
    db.getRelationsTimetag().then(function (t) {
      timetag = t;
      getRelationsFromServer();
    }, getRelationsFromServer);
  } else {
    getRelationsFromServer();
  }
  function getRelationsFromServer() {
    self.sendCmd('getRelations', { timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
  }
};

/***/ }),

/***/ "./src/im/api/nim/robot.js":
/*!*********************************!*\
  !*** ./src/im/api/nim/robot.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;

/**
  * 直接获取机器人列表
  * nim.getRobots({
  *     done: getRobotsDone
  * });
  * function getRobotsDone(error, obj) {
  *     console.log('获取机器人列表' + (!error?'成功':'失败'), error, obj);
  * }
  */

NIMFn.getRobots = function (options) {
  options = options || {};
  options.type = 'getRobots';
  this.processCallback(options);
  this.sendCmd('sync', {
    sync: {
      robots: 0
    }
  }, options.callback);
};

/***/ }),

/***/ "./src/im/api/nim/session.js":
/*!***********************************!*\
  !*** ./src/im/api/nim/session.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var notundef = util.notundef;

/**
 * 设置当前会话
 * - 设置后, 当前会话未读数会被置为 `0`, 同时开发者会收到 `onupdatesession` 回调
 * - 之后此会话在收到消息之后不会更新未读数
 * - 传空字符串的话, 重置当前会话为空
 *
 * @method setCurrSession
 * @memberOf NIM#
 *
 * @param {String} sessionId 会话ID
 * @return {Void}
 *
 * @example
 * nim.setCurrSession('sessionId');
 */
NIMFn.setCurrSession = function (sessionId) {
  var self = this;
  self.resetSessionUnread(sessionId);
  self.protocol.setCurrSession(sessionId);
};

NIMFn.resetAllSessionUnread = function () {
  var self = this;
  for (var sessionId in self.protocol.sessionSet) {
    if (self.protocol.sessionSet[sessionId].unread > 0) {
      self.resetSessionUnread(sessionId);
    }
  }
};

/**
 * 重置某个会话的未读数
 * - 如果是已经存在的会话记录, 会将此会话未读数置为 0, 那么会收到`onupdatesession`回调
 * - 之后此会话在收到消息之后依然会更新未读数
 *
 * @method resetSessionUnread
 * @memberOf NIM#
 *
 * @param {String} sessionId 会话ID
 * @return {Void}
 *
 * @example
 * nim.resetSessionUnread('sessionId');
 */
NIMFn.resetSessionUnread = function (sessionId) {
  var self = this;
  // 直接重置会话未读数, 这样不用等数据库操作, 否则 UI 上会有延时
  self.protocol.resetSessionUnread(sessionId);
  // 如果没有开启同步未读数, 那么直接返回
  if (!self.options.syncSessionUnread) {
    return;
  }
  var session = self.protocol.findSession(sessionId);
  if (!session) {
    self.logger.warn('api::resetSessionUnread: session undefined ' + sessionId);
    return;
  }
  // 会话没有最后一条消息
  if (!session.lastMsg) {
    self.logger.warn('api::resetSessionUnread: session.lastMsg undefined ' + sessionId);
    return;
  }
  // 没有 scene 或者 to
  if (!session.scene || !session.to) {
    self.logger.warn('api::resetSessionUnread: session.scene|to undefined ' + sessionId);
    return;
  }
  // 如果被 ack 的 session 已经 ack 过了, 那么直接返回
  var ack = session.lastMsg.time;
  if (session && session.ack && session.ack >= ack) {
    self.logger.warn('api::resetSessionUnread: session ack not needs ' + sessionId);
    return;
  }
  var content = {
    scene: session.scene === 'p2p' ? 0 : 1,
    to: session.to,
    timetag: ack
  };
  self.sendCmd('markSessionAck', content);
};

/**
 * 重置当前会话
 * - 重置当前会话后, 所有会话在收到消息之后会更新未读数
 *
 * @method resetCurrSession
 * @memberOf NIM#
 *
 * @example
 * nim.resetCurrSession();
 */
NIMFn.resetCurrSession = function () {
  this.protocol.setCurrSession('');
};

/**
 * 插入一条本地会话记录
 *
 * - 如果会话已存在, 那么会返回错误
 * - 如果不{@link support.db|支持数据库}, 那么算成功
 * - 如果有对应会话的本地历史消息, 那么会更新会话的 `lastMsg` 为最后一条消息
 * - 插入成功后, 会触发`onupdatesession`回调
 *
 * @method insertLocalSession
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @param {String} options.scene {@link Session|会话}{@link IMMessage.scene|场景}
 * @param {String} option.to {@link Session|会话}对象, 账号或群ID
 * @param {Number} [options.updateTime] 可选, 会话更新的时间, 如果不填, SDK 会设置一个比当前所有会话更新时间大的一个时间
 * @param {Function} options.done 结果回调函数, 如果成功会额外附上生成的会话对象
 * @return {Void}
 * @example
 * nim.insertLocalSession({
 *     scene: 'p2p',
 *     to: 'account',
 *     done: insertLocalSessionDone
 * });
 * function insertLocalSessionDone(error, obj) {
 *     console.log('插入本地会话记录' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onSessions(obj.session);
 *     }
 * }
 */
NIMFn.insertLocalSession = function (options) {
  var self = this;
  var error;
  var session;
  util.verifyOptions(options, 'scene to', 'scene::insertLocalSession');
  util.verifyParamValid('scene', options.scene, self.message.validScenes, 'scene::insertLocalSession');
  self.processCallback(options);
  self.protocol.insertLocalSession(options).then(function (obj) {
    session = obj;
    bingo();
  }, function (err) {
    error = err;
    bingo();
  });
  function bingo() {
    options.session = session;
    options.done(error, options);
  }
};

/**
 * 获取本地会话列表
 * - 如果不{@link support.db|支持数据库}, 返回空数组
 * - 会话列表按时间逆序排列, 即最近聊过天的放在列表的最前面
 *
 * @method getLocalSessions
 * @memberOf NIM#
 *
 * @param  {Object}     options                 配置参数
 * @param  {Number}     [options.lastSessionId] 上次查询的最后一条会话的`id`, 第一次不填
 * @param  {Number}     [options.limit]         本次查询的会话数量限制, 最多 100 条, 默认 100 条
 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从最近的会话开始往前查找本地会话；
 *                                              `true`表示从第一条会话开始往后查找本地会话
 * @param  {done}       options.done            结果回调函数
 * @return {Void}
 *
 * @example
 * nim.getLocalSessions({
 *     lastSessionId: lastSessionId,
 *     limit: 100,
 *     done: getLocalSessionsDone
 * });
 * function getLocalSessionsDone(error, obj) {
 *     console.log('获取本地会话列表' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onSessions(obj.sessions);
 *     }
 * }
 */
NIMFn.getLocalSessions = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var sessions = [];
  util.verifyOptions(options);
  if (undef(options.limit)) {
    options.limit = 100;
  }
  util.verifyParamType('limit', options.limit, 'number', 'scene::getLocalSessions');
  util.verifyParamMax('limit', options.limit, 100, 'scene::getLocalSessions');
  if (notundef(options.reverse)) {
    util.verifyParamType('reverse', options.reverse, 'boolean', 'scene::getLocalSessions');
  } else {
    options.reverse = false;
  }
  self.processCallback(options);

  if (db.enable) {
    db.getSessions(options).then(function (records) {
      sessions = records;
      self.protocol.mergeSessions(sessions);
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.sessions = sessions;
    options.done(error, options);
  }
};

/**
 * 通过sessionId获取本地会话
 * - 如果{@link support.db|支持数据库}, 则查找数据库中的对应会话，有则返回会话对象，无则返回 null
 * - 如果不{@link support.db|支持数据库}, 则查找之前同步到的会话列表，有则返回会话对象，无则返回 null
 *
 * @method getLocalSession
 * @memberOf NIM#
 *
 * @param  {Object}     options                 配置参数
 * @param  {String}     [options.sessionId]     需要查询的会话的`sessionId`
 * @param  {done}       options.done            结果回调函数
 * @return {Void}
 *
 * @example
 * nim.getLocalSession({
 *     sessionId: sessionId,
 *     done: getLocalSessionDone
 * });
 * function getLocalSessionDone(error, obj) {
 *     console.log('获取本地会话操作' + (!error ? '完成' : '失败'), error, obj)
 *     if (!error) {
 *         onSession(obj);
 *     }
 * }
 */
NIMFn.getLocalSession = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var returnRecord = null;
  util.verifyOptions(options, 'sessionId', 'scene::getLocalSession');
  util.verifyParamType('sessionId', options.sessionId, 'string', 'scene::getLocalSession');
  if (db.enable) {
    self.processCallback(options);
    db.getSession(options.sessionId).then(function (record) {
      if (record) {
        // returnRecord = JSON.parse(JSON.stringify(record))
        returnRecord = record;
      }
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
    return;
  } else if (self.protocol.sessionSet && self.protocol.sessionSet[options.sessionId]) {
    returnRecord = self.protocol.sessionSet[options.sessionId];
  }
  bingo();
  function bingo() {
    options.done(error, returnRecord);
  }
};

/**
 * 更新本地会话
 * - 更新 `id` 对应的本地会话
 * - 如果不{@link support.db|支持数据库}, 算成功
 * - 如果对应的会话不存在, 算成功, 返回 null
 * - 这些字段只会被更新到本地数据库, 不会被更新到服务器上
 * - 目前只允许更新 `localCustom`
 *
 * @method updateLocalSession
 * @memberOf NIM#
 *
 * @param  {Object}     options                 配置参数
 * @param  {String}     options.id              id
 * @param  {String}     [options.localCustom]   自定义字段
 * @param  {Function}   options.done            结果回调函数, 成功时会额外附上{@link Session|会话}
 * @return {Void}
 *
 * @example
 * nim.updateLocalSession({
 *     id: 'p2p-account',
 *     localCustom: '{"key","value"}',
 *     done: updateLocalSessionDone
 * });
 * function updateLocalSessionDone(error, obj) {
 *     console.log('更新本地会话' + (!error?'成功':'失败'), error, obj);
 * }
 */

NIMFn.updateLocalSession = function (options) {
  var self = this;
  var db = self.db;
  var error;
  util.verifyOptions(options, 'id', 'scene::updateLocalSession');
  self.processCallback(options);
  var session = util.filterObj(options, 'id localCustom');
  if (db.enable) {
    db.updateSession(session).then(function (record) {
      session = record;
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    self.protocol.onUpdateSession(session);
    options.session = session;
    options.done(error, options);
  }
};

/**
 * 删除本地会话
 *
 * - 在{@link support.db|支持数据库}时, 删了本地会话之后, 下次同步就同步不到对应的会话
 * - 如果不{@link support.db|支持数据库}, 算成功
 * - 如果对应的会话不存在, 算成功
 *
 * @method deleteLocalSession
 * @memberOf NIM#
 *
 * @param  {Object}             options         配置参数
 * @param  {String|String[]}    options.id      会话 id 或 id 数组
 * @param  {Function}           options.done    结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteLocalSession({
 *     id: 'p2p-account',
 *     done: deleteLocalSessionDone
 * });
 * function deleteLocalSessionDone(error, obj) {
 *     console.log('删除本地会话' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.deleteLocalSession = function (options) {
  var self = this;
  var db = self.db;
  var error;
  util.verifyOptions(options, 'id', 'session::deleteLocalSession');
  self.processCallback(options);
  if (db.enable) {
    db.deleteSession(options.id).then(function () {
      self.protocol.deleteLocalSession(options.id);
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.done(error, options);
  }
};

/**
 * 删除服务器上的会话
 *
 * - 删了服务器上的会话之后, 在不{@link support.db|支持数据库}时, 下次同步就同步不到对应的会话以及会话对应的漫游消息; 此外, 在新设备上也同步不到对应的会话以及会话对应的漫游消息
 *
 * @method deleteSession
 * @memberOf NIM#
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.scene   {@link IMMessage.scene|场景}
 * @param  {String} options.to      对方账号或群ID
 * @param  {done}   options.done    结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteSession({
 *     scene: 'p2p',
 *     to: 'account',
 *     done: deleteSessionDone
 * });
 * function deleteSessionDone(error, obj) {
 *     console.log('删除会话' + (!error?'成功':'失败'), error, obj);
 * }
 * @see {@link NIM#deleteSessions|批量删除服务器上的会话}
 */
NIMFn.deleteSession = function (options) {
  util.verifyOptions(options, 'scene to', 'session::deleteSession');
  this.processCallback(options);
  options.sessions = [{
    scene: options.scene,
    to: options.to
  }];
  this.deleteSessions(options);
};

/**
 * 批量删除服务器上的会话
 *
 * - 删了服务器上的会话之后, 在不{@link support.db|支持数据库}时, 下次同步就同步不到对应的会话以及会话对应的漫游消息; 此外, 在新设备上也同步不到对应的会话以及会话对应的漫游消息
 *
 * @method deleteSessions
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {Session[]}  options.sessions    会话列表
 * @param  {done}       options.done        结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteSessions({
 *     sessions: {[
 *         scene: 'p2p',
 *         to: 'account'
 *     ], [
 *         scene: 'p2p',
 *         to: 'account1'
 *     ]},
 *     done: deleteSessionsDone
 * });
 * function deleteSessionsDone(error, obj) {
 *     console.log('批量删除会话' + (!error?'成功':'失败'), error, obj);
 * }
 * @see {@link NIM#deleteSession|删除服务器上的会话}
 */
NIMFn.deleteSessions = function (options) {
  util.verifyOptions(options, 'sessions', 'session::deleteSessions');
  util.verifyParamType('sessions', options.sessions, 'array', 'session::deleteSessions');
  options.sessions.forEach(function (session, index) {
    util.verifyOptions(session, 'scene to', true, 'sessions[' + index + '].', 'session::deleteSessions');
  });
  this.processCallback(options);
  this.sendCmd('deleteSessions', {
    sessions: options.sessions.map(function (session) {
      return session.scene + '|' + session.to;
    })
  }, options.callback);
};

/***/ }),

/***/ "./src/im/api/nim/superTeam.js":
/*!*************************************!*\
  !*** ./src/im/api/nim/superTeam.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var SuperTeam = __webpack_require__(/*! im/model/superTeam */ "./src/im/model/superTeam.js");
var SuperTeamMember = __webpack_require__(/*! im/model/superTeamMember */ "./src/im/model/superTeamMember.js");

/**
* 拉人入超大群，无需对方同意
* 
* - {@link NIM#addSuperTeamMembers|拉人入群}, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'addSuperTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为邀请者的帐号, `to`字段的值为对应的群ID；`attach`有一个字段`team`的值为对应的{@link SuperTeam|超大群对象}，有一个字段members是被邀请新入群的成员信息数组。
* 
* @method addSuperTeamMembers
* @memberOf NIM#
* 
* @param {Object}    options               配置参数 
* @param {String}    options.teamId        配置参数 
* @param {String[]}  options.accounts      配置参数 
* @param {Function}  options.done          结果回调函数 
* @return {Void}
* 
* @example
* nim.addSuperTeamMembers({
*    teamId: '123',
*    accounts: ['a1', 'a1'],
*    done: addSuperTeamMembersDone
* })
* function addSuperTeamMembersDone(error, obj) {
*     console.log('入群邀请发送' + (!error?'成功':'失败'), error, obj);
* }
* 
*/

NIMFn.addSuperTeamMembers = function (options) {
  util.verifyOptions(options, 'teamId accounts', 'superTeam::addSuperTeamMembers');
  util.verifyParamType('accounts', options.accounts, 'array', 'superTeam::addSuperTeamMembers');
  // 去重后的accounts
  var accounts = util.deduplicate(options.accounts);
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    accounts: accounts
  };
  this.sendCmd('addSuperTeamMembers', content, options.callback);
};

/**
* 踢人出群
* 
* - {@link NIM#removeSuperTeamMembers|踢人出群}, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'removeSuperTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为退群的人的帐号, `to`字段的值为对应的群ID；`attach`有一个字段`team`的值为对应的{@link SuperTeam|超大群对象}，有一个字段accounts的是被踢人的账号数组。
* 
* @method removeSuperTeamMembers
* @memberOf NIM#
*
* @param  {Object}     options             配置参数
* @param  {String}     options.teamId      群id
* @param  {String[]}   options.accounts    要移除的成员帐号列表
* @param  {done}       options.done        结果回调函数
* @return {Void}
*
* @see {@link NIM#addSuperTeamMembers|拉人入超大群}
*
* @example
* nim.removeSuperTeamMembers({
*     teamId: '123',
*     accounts: ['a3', 'a4'],
*     done: removeSuperTeamMembersDone
* });
* function removeSuperTeamMembersDone(error, obj) {
*     console.log('踢人出群' + (!error?'成功':'失败'), error, obj);
* }
*/

NIMFn.removeSuperTeamMembers = function (options) {
  util.verifyOptions(options, 'teamId accounts', 'team::removeSuperTeamMembers');
  util.verifyParamType('accounts', options.accounts, 'array', 'team::removeSuperTeamMembers');
  // 去重后的accounts
  var accounts = util.deduplicate(options.accounts);
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    accounts: accounts
  };
  this.sendCmd('removeSuperTeamMembers', content, options.callback);
};

/**
 * 主动退群
 *
 * - {@link NIM#leaveSuperTeam|主动退群}后, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'leaveSuperTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为退群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link SuperTeam|超大群对象}。
 *
 * @method leaveSuperTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options           配置参数
 * @param  {String}   options.teamId    群id
 * @param  {done}     options.done      结果回调函数
 * @return {Void}
 *
 * @example
 * nim.leaveSuperTeam({
  *     teamId: '123',
  *     done: leaveSuperTeamDone
  * });
  * function leaveSuperTeamDone(error, obj) {
  *     console.log('主动退群' + (!error?'成功':'失败'), error, obj);
  * }
  */
NIMFn.leaveSuperTeam = function (options) {
  util.verifyOptions(options, 'teamId', 'superTeam::leaveSuperTeam');
  this.processCallback(options);
  var content = {
    teamId: options.teamId
  };
  this.sendCmd('leaveSuperTeam', content, options.callback);
};

/**
 * 获取群信息
 *
 * - 开发者可以调用此接口根据群ID获取群资料
 *
 * @method getSuperTeam
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link SuperTeam|超大群资料}
 * @return {Void}
 *
 * @see {@link NIM#getSuperTeams|获取群列表}
 * @see {@link NIM#getSuperTeamMembers|获取群成员}
 *
 * @example
 * nim.getSuperTeam({
  *     teamId: '123',
  *     done: getSuperTeamDone
  * });
  * function getSuperTeamDone(error, obj) {
  *     console.log(error);
  *     console.log(obj);
  *     console.log('获取群' + (!error?'成功':'失败'));
  * }
  */
NIMFn.getSuperTeam = function (options) {
  var self = this;
  var db = self.db;
  var teamId;
  util.verifyOptions(options, 'teamId', 'team::getSuperTeam');
  self.processCallback(options);

  options.cbaop = function (error, obj) {
    if (!error) {
      self.logger.log('api::getSuperTeam: cbaop ' + teamId, obj);
    }
  };

  teamId = options.teamId;

  if (db.enable && !options.sync) {
    db.getSuperTeam(teamId).then(function (team) {
      if (team) {
        self.logger.log('api::getSuperTeam: db.getSuperTeam ' + teamId, team);
        options.done(null, team);
      } else {
        getSuperTeamFromServer();
      }
    }, getSuperTeamFromServer);
  } else {
    getSuperTeamFromServer();
  }
  function getSuperTeamFromServer() {
    self.sendCmd('getSuperTeam', { teamId: options.teamId }, options.callback);
  }
};

/**
 * 获取所在的超大群列表
 * - 如果开发者在{@link NIM|初始化SDK}的时候设置了`syncSuperTeams`为`false`, 那么就收不到`onSuperTeams`回调, 可以调用此接口来获取{@link SuperTeam|超大群}列表
 * 
 * @method getSuperTeams
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link SuperTeam|超大群}列表
 * @return {Void}
 *
 * @see {@link NIM#getSuperTeam|获取超大群资料}
 * @see {@link NIM#getSuperTeamMembers|获取超大群成员}
 *
 * @example
 * nim.getSuperTeams({
  *     done: getSuperTeamsDone
  * });
  * function getSuperTeamsDone(error, teams) {
  *     console.log(error);
  *     console.log(teams);
  *     console.log('获取超大群列表' + (!error?'成功':'失败'));
  * }
  */
NIMFn.getSuperTeams = function (options) {
  var self = this;
  var db = self.db;
  var timetag = 0;
  util.verifyOptions(options);
  self.processCallback(options);
  if (db.enable) {
    db.getSuperTeamsTimetag().then(function (t) {
      timetag = t;
      getSuperTeamsFromServer();
    }, getSuperTeamsFromServer);
  } else {
    getSuperTeamsFromServer();
  }
  function getSuperTeamsFromServer() {
    self.sendCmd('getSuperTeams', { timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
  }
};

/**
 * 更新群
 *
 * - {@link NIM#updateSuperTeam|更新超大群}后, 所有{@link SuperTeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'updateSuperTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为更新群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为被更新的{@link SuperTeam|群信息}。
 *
 * @method updateSuperTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options                   配置参数
 * @param  {String}   options.teamId            群id
 * @param  {String}   [options.name]            群名字
 * @param  {String}   [options.avatar]          群头像
 * @param  {String}   [options.intro]           群简介
 * @param  {String}   [options.announcement]    群公告
 * @param  {String}   [options.custom]          扩展字段
 * @param  {done}     options.done              结果回调函数
 * @return {Void}
 *
 * @example
 * nim.updateSuperTeam({
  *     teamId: '123',
  *     name: '群名字',
  *     avatar: 'avatar',
  *     intro: '群简介',
  *     announcement: '群公告',
  *     custom: '自定义字段',
  *     done: updateSuperTeamDone
  * });
  * function updateSuperTeamDone(error, team) {
  *     console.log('更新群' + (!error?'成功':'失败'), error, team);
  * }
  */
NIMFn.updateSuperTeam = function (options) {
  util.verifyOptions(options, 'teamId', 'superTeam::updateSuperTeam');
  options.action = 'update';
  this.processCallback(options);
  options.team = new SuperTeam(options);
  this.sendCmd('updateSuperTeam', { team: options.team, single: true }, options.callback);
};

/**
 *  修改个人群成员信息 (修改自己的群属性)
 *
 * 目前支持修改的属性有这些
 * - `nickInTeam`: 自己在群里面的群昵称
 *     - 更新昵称后, 所有其它在线的{@link SuperTeamMember|群成员}会收到{@link NIM|初始化SDK}时传入的`onUpdateSuperTeamMember`回调。
 * - `muteTeam`: 是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定
 * - `custom`: 第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
 *
 * 修改自己的群属性后，所有{@link SuperTeamMember|群成员}会收到SDK初始化时设置的`onUpdateSuperTeamMember`回调
 * 
 * @method updateInfoInSuperTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options               配置参数
 * @param  {String}   options.teamId        群id
 * @param  {String}   [options.nickInTeam]  在群里面的昵称
 * @param  {Boolean}  [options.muteTeam]    是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定
 * @param  {Boolean}  [options.custom] 第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
 * @param  {done}     options.done          结果回调函数
 * @return {Void}
 *
 * @example
 * nim.updateInfoInSuperTeam({
  *     teamId: '123',
  *     // 此参数为可选参数
  *     nickInTeam: '群昵称',
  *     // 静音群, 此参数为可选参数
  *     muteTeam: true,
  *     // 第三方扩展字段
  *     custom: '{}'
  *     done: updateInfoInSuperTeamDone
  * });
  * function updateInfoInSuperTeamDone(error, obj) {
  *     console.log('修改自己的群属性' + (!error?'成功':'失败'), error, obj);
  * }
  */
NIMFn.updateInfoInSuperTeam = function (options) {
  // 注意, 这里以后如果开放了更多的参数, 要在 SuperTeamMember 里面加上相应的验证 verifyParamAtLeastPresentOne
  util.verifyOptions(options, 'teamId', 'superTeam::updateInfoInSuperTeam');
  this.processCallback(options);
  this.sendCmd('updateInfoInSuperTeam', { superTeamMember: new SuperTeamMember(options), single: true }, options.callback);
};

/**
 * 获取超大群成员
 *
 * - 接受入群邀请之后可调用此方法来获取{@link SuperTeamMember|超大群群成员}列表，支持分页获取
 *
 * @method getSuperTeamMembers
 * @memberOf NIM#
 *
 * @param  {Object}     options                         配置参数
 * @param  {String}     options.teamId                  群id
 * @param  {Boolean}    [options.needPaging = false]    是否需要分页
 * @param  {Object}     [options.pagingParams]          分页参数，选填，但当`needPaging`为 `true` 时必填
 * @param  {Object}     [options.pagingParams.size]         每页条数
 * @param  {Object}     [options.pagingParams.current]      当前页数
 * @param  {done}       options.done                    结果回调函数, 成功时会额外附上{@link SuperTeamMember|群成员}列表和分页数据（如果有的话）
 * @return {Void}
 *
 * @see {@link NIM#getSuperTeam|获取超大群资料}
 * @see {@link NIM#getSuperTeams|获取我的超大群资料列表}
 *
 * @example
 * nim.getSuperTeamMembers({
 *     teamId: '123',
 *     needPaging: true, // 选填
 *     pagingParams: { size: 100, current: 0 }, // 选填
 *     done: getSuperTeamMembersDone
 * });
 * function getSuperTeamMembersDone(error, obj) {
 *     console.log(error);
 *     console.log('获取群成员' + (!error?'成功':'失败'));
 *     console.log('群成员::群成员总数量::每页大小::当前页数', obj.members, obj.total, obj.size, obj.current)
 * }
 */
NIMFn.getSuperTeamMembers = function (options) {
  var self = this;
  var timetag = 0;
  var str = 'teamId';
  var size, current, needPaging;
  options.needPaging = !!options.needPaging;
  needPaging = options.needPaging;
  var str = needPaging ? 'teamId pagingParams' : 'teamId';
  util.verifyOptions(options, str, 'superTeam::getSuperTeamMembers');
  if (needPaging) {
    size = +options.pagingParams.size;
    current = +options.pagingParams.current;
    util.verifyParamType('pagingParams.size', size, 'number', 'api::superTeam::getSuperTeamMembers');
    util.verifyParamType('pagingParams.current', current, 'number', 'api::superTeam::getSuperTeamMembers');
  }
  self.processCallback(options);
  var db = self.db;
  if (db.enable) {
    db.getSuperTeam(options.teamId).then(function (team) {
      if (team) {
        var serverTimetag = team.memberUpdateTime;
        db.getSuperTeamMembersTimetag(options.teamId).then(function (localTimetag) {
          // 如果服务器的时间戳比本地的小, 说明最近同步过, 那么直接从本地获取群成员
          if (!isNaN(serverTimetag) && !isNaN(localTimetag) && serverTimetag <= localTimetag) {
            db.getSuperTeamMembers(options.teamId).then(function (members) {
              var obj = {
                teamId: options.teamId
              };
              if (options.needPaging) {
                obj.members = members.slice(size * current, (current + 1) * size);
                obj.size = size;
                obj.current = current;
                obj.total = members.length;
              } else {
                obj.members = members;
              }
              options.done(null, obj);
            }, getSuperTeamMembersFromServer);
          } else {
            timetag = localTimetag;
            getSuperTeamMembersFromServer();
          }
        }, getSuperTeamMembersFromServer);
      } else {
        getSuperTeamMembersFromServer();
      }
    }, getSuperTeamMembersFromServer);
  } else {
    getSuperTeamMembersFromServer();
  }
  function getSuperTeamMembersFromServer() {
    self.sendCmd('getSuperTeamMembers', { teamId: options.teamId, timetag: timetag, needPaging: options.needPaging, pagingParams: options.pagingParams, NOTSTORE: 'timetag' }, options.callback);
  }
};

/***/ }),

/***/ "./src/im/api/nim/sysMsg.js":
/*!**********************************!*\
  !*** ./src/im/api/nim/sysMsg.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var notundef = util.notundef;
var SystemMessage = __webpack_require__(/*! im/model/systemMessage */ "./src/im/model/systemMessage.js");

/**
 * 标记系统通知为已收到
 *
 * - SDK 在收到系统通知后会更新系统通知未读数, 开发者需要调用此接口来通知 SDK 将某条系统通知标记为已读状态, 标记后会触发`onupdatesysmsgunread`回调
 *
 * @memberOf NIM#
 * @method markSysMsgRead
 *
 * @param  {Object}     options                             配置参数
 * @param  {SystemMessage|SystemMessage[]} options.sysMsgs  通过`onofflinesysmsgs`或者`onsysmsg`接收到的系统通知或者系统通知数组
 * @param  {done}       options.done                        结果回调函数
 * @return {Void}
 *
 * @example
 * nim.markSysMsgRead({
 *     sysMsgs: someSysMsg,
 *     done: markSysMsgReadDone
 * });
 * function markSysMsgReadDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('标记系统通知为已收到' + (!error?'成功':'失败'));
 * }
 */
NIMFn.markSysMsgRead = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var promise = Promise.resolve();
  var protocol = self.protocol;
  util.verifyOptions(options, 'sysMsgs', 'sysmsg::markSysMsgRead');
  var sysMsgs = options.sysMsgs;
  if (!util.isArray(sysMsgs)) {
    sysMsgs = [sysMsgs];
  }
  // 如果支持数据库, 那么更新数据库记录;
  // 如果不支持数据库, 那么直接修改字段即可
  // - 如果不自动标记已读, 那么标记已读;
  if (db.enable) {
    promise = db.markSysMsgRead(sysMsgs).then(function (records) {
      sysMsgs = records;
      protocol.onUpdateSysMsg(records);
    });
  } else {
    // 过滤掉已经标为已读的
    sysMsgs = sysMsgs.filter(function (sysMsg) {
      return !sysMsg.read;
    });
    if (sysMsgs.length) {
      if (!protocol.options.autoMarkRead) {
        protocol.markSysMsgRead(sysMsgs, true);
      }
      sysMsgs.forEach(function (sysMsg) {
        sysMsg.read = true;
      });
      protocol.onUpdateSysMsg(sysMsgs);
    }
  }
  // 更新系统通知未读数
  promise.then(function () {
    return protocol.reduceSysMsgUnread(sysMsgs);
  }).then(bingo, function (event) {
    error = event;
    bingo();
  });
  function bingo() {
    options.done(error, options);
  }
};

/**
 * 发送自定义系统通知
 *
 * - 开发者可以向其他用户或群发送自定义通知。
 * - 自定义系统通知和自定义消息的区别如下
 *     - 自定义消息属于{@link IMMessage|消息}, 会存储在云信的消息数据库中, 需要跟其他{@link IMMessage|消息}一同展现给用户。
 *     - 自定义系统通知属于{@link SystemMessage|系统通知}, 用于第三方通知自己, 不会存储在云信的数据库中, SDK不会解析这些通知, SDK仅仅负责传递这些通知。
 *
 * @method sendCustomSysMsg
 * @memberOf NIM#
 *
 * @param  {Object}         options                                 配置参数
 * @param  {String}         options.scene                           场景跟{@link IMMessage.scene|消息场景}的一样, 分为`p2p(点对点)`和`team(群)`。
 * @param  {String|Number}  options.to                              接收方, 帐号或者群id
 * @param  {String}         options.content                         自定义系统通知的内容, 推荐使用JSON格式构建
 * @param  {String}         [options.apnsText]                      apns推送文案, 仅对接收方为iOS设备有效
 * @param  {String}         [options.pushPayload]                   自定义系统通知的推送属性
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @param  {Boolean}        [options.sendToOnlineUsersOnly=true]    是否只发送给在线用户。
 *                                                                  true时只发送给在线用户, 如果接收方不在线, 这条通知将被丢弃。
 *                                                                  适合发送即时通知, 比如正在输入。
 *                                                                  false时假如接收方在线, 那么会立即收到该通知,
 *                                                                  假如接收方不在线, 会在其上线后推送过去。
 * @param  {Boolean}        [options.cc]                            是否抄送
 * @param  {Boolean}        [options.isPushable=true]               是否需要推送
 * @param  {Boolean}        [options.needPushNick=false]            是否需要推送昵称
 * @param  {done}           options.done                            结果回调函数
 * @return {String}         SDK生成的ID
 *
 * @see {@link NIM#sendCustomMsg|发送自定义消息}
 *
 * @example
 * var content = {
 *     type: 'type',
 *     value: 'value'
 * };
 * content = JSON.stringify(content);
 * var msgId = nim.sendCustomSysMsg({
 *     scene: 'p2p',
 *     to: 'account',
 *     content: content,
 *     sendToOnlineUsersOnly: false,
 *     apnsText: content,
 *     done: sendCustomSysMsgDone
 * });
 * console.log('正在发送p2p自定义系统通知, id=' + msgId);
 * function sendCustomSysMsgDone(error, msg) {
 *     console.log(error);
 *     console.log(msg);
 *     console.log('发送' + msg.scene + '自定义系统通知' + (!error?'成功':'失败') + ', id=' + msg.idClient);
 * }
 */
NIMFn.sendCustomSysMsg = function (options) {
  var self = this;
  util.verifyOptions(options, 'scene to content', 'sysmsg::sendCustomSysMsg');
  util.verifyParamValid('scene', options.scene, self.message.validScenes, 'sysmsg::sendCustomSysMsg');
  self.processCallback(options);
  if (options.scene === 'p2p') {
    options.type = 'customP2p';
  } else {
    options.type = 'customTeam';
  }
  options.sysMsg = new SystemMessage(options);
  var cmd = 'sendCustomSysMsg';
  // 是否是过滤消息
  if (options.filter) {
    cmd = 'sendFilterCustomSysMsg';
  }
  self.sendCmd(cmd, { sysMsg: options.sysMsg, single: true }, options.callback);
  return self.formatReturnSysMsg(options.sysMsg);
};

NIMFn.formatReturnSysMsg = function (sysMsg) {
  var self = this;
  sysMsg = util.copy(sysMsg);
  self.protocol.completeSysMsg(sysMsg);
  sysMsg.status = 'sending';
  sysMsg = SystemMessage.reverse(sysMsg);
  return sysMsg;
};

/**
 * 获取本地系统通知
 * - 如果不{@link support.db|支持数据库}, 算成功, 返回空数组
 *
 * @method getLocalSysMsgs
 * @memberOf NIM#
 *
 * @param  {Object}     options                 配置参数
 * @param  {String}     [options.category]      {@link SystemMessage.category|种类}
 * @param  {String}     [options.type]          {@link SystemMessage.type|类型}
 * @param {Boolean} [options.read] 可选
 * - 如果不传, 默认获取所有已读和未读的系统通知
 * - 如果传 `true`, 那么只获取已读的系统通知
 * - 如果传 `false`, 那么只获取未读的系统通知
 * @param  {String}     [options.lastIdServer]  上次查询的最后一条系统通知的`idServer`, 第一次不填
 * @param  {Number}     [options.limit]         本次查询的消息数量限制, 最多 100 条, 默认 100 条
 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从最近的系统通知开始往前查找本地系统通知；
 *                                              `true`表示从第一条系统通知开始往后查找本地系统通知
 * @param  {done}       options.done            结果回调函数, 成功时会额外附上{@link SystemMessage|系统通知}列表
 * @return {Void}
 *
 * @example
 * nim.getLocalSysMsgs({
 *     lastIdServer: 'lastIdServer',
 *     limit: 100,
 *     done: getLocalSysMsgsDone
 * });
 * function getLocalSysMsgsDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('获取本地系统通知' + (!error?'成功':'失败'));
 *     if (!error) {
 *         console.log(obj.sysMsgs);
 *     }
 * }
 */
NIMFn.getLocalSysMsgs = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var sysMsgs = [];
  util.verifyOptions(options);
  if (options.category) {
    util.verifyParamValid('category', options.category, SystemMessage.validCategories, 'sysmsg::getLocalSysMsgs');
  }
  if (options.type) {
    util.verifyParamValid('type', options.type, SystemMessage.validTypes, 'sysmsg::getLocalSysMsgs');
  }
  if (undef(options.limit)) {
    options.limit = 100;
  }
  util.verifyParamType('limit', options.limit, 'number', 'sysmsg::getLocalSysMsgs');
  util.verifyParamMax('limit', options.limit, 100, 'sysmsg::getLocalSysMsgs');
  if (notundef(options.reverse)) {
    util.verifyParamType('reverse', options.reverse, 'boolean', 'sysmsg::getLocalSysMsgs');
  } else {
    options.reverse = false;
  }
  self.processCallback(options);

  if (db.enable) {
    db.getSysMsgs(options).then(function (records) {
      sysMsgs = records;
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.sysMsgs = sysMsgs;
    options.done(error, options);
  }
};

/**
 * 更新本地系统通知
 * - 更新 `idServer` 对应的本地系统通知
 * - 如果不{@link support.db|支持数据库}, 算成功
 * - 如果对应的系统通知不存在, 算成功, 返回 null
 * - 这些字段只会被更新到本地数据库, 不会被更新到服务器上
 *
 * @method updateLocalSysMsg
 * @memberOf NIM#
 *
 * @param  {Object}     options                 配置参数
 * @param  {String}     options.idServer        idServer
 * @param  {String}     [options.status]        状态
 * @param  {String}     [options.localCustom]   自定义字段
 * @param  {Function}   options.done            结果回调函数, 成功时会额外附上{@link SystemMessage|系统通知}
 * @return {Void}
 *
 * @example
 * nim.updateLocalSysMsg({
 *     idServer: '1234',
 *     status: 'bingo',
 *     localCustom: '{"key","value"}',
 *     done: updateLocalSysMsgDone
 * });
 * function updateLocalSysMsgDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('更新本地系统通知' + (!error?'成功':'失败'));
 * }
 */
NIMFn.updateLocalSysMsg = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var sysMsg = null;
  util.verifyOptions(options, 'idServer', 'sysmsg::updateLocalSysMsg');
  self.processCallback(options);
  if (db.enable) {
    var obj = util.filterObj(options, 'idServer state localCustom');
    db.updateSysMsg(obj).then(function (reocrd) {
      sysMsg = reocrd;
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.sysMsg = sysMsg;
    options.done(error, options);
  }
};

/**
 * 删除本地系统通知
 * - 删除 `idServer` 对应的本地系统通知
 * - 如果不{@link support.db|支持数据库}, 算成功
 * - 如果对应的系统通知不存在, 算成功
 *
 * @method deleteLocalSysMsg
 * @memberOf NIM#
 *
 * @param  {Object}             options             配置参数
 * @param  {String|String[]}    options.idServer    idServer 或 idServer 数组
 * @param  {Function}           options.done        结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteLocalSysMsg({
 *     idServer: '1234',
 *     done: deleteLocalSysMsgDone
 * });
 * function deleteLocalSysMsgDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('删除本地系统通知' + (!error?'成功':'失败'));
 * }
 */
NIMFn.deleteLocalSysMsg = function (options) {
  var self = this;
  var db = self.db;
  var error;
  util.verifyOptions(options, 'idServer', 'sysmsg::deleteLocalSysMsg');
  self.processCallback(options);
  if (db.enable) {
    db.deleteSysMsg(options.idServer).then(function () {
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.done(error, options);
  }
};

/**
 * 删除所有本地系统通知
 * - 如果不{@link support.db|支持数据库}, 算成功
 *
 * @method deleteAllLocalSysMsgs
 * @memberOf NIM#
 *
 * @param  {Object}             options             配置参数
 * @param  {Function}           options.done        结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteAllLocalSysMsgs({
 *     done: deleteAllLocalSysMsgsDone
 * });
 * function deleteAllLocalSysMsgsDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('删除所有本地系统通知' + (!error?'成功':'失败'));
 * }
 */
NIMFn.deleteAllLocalSysMsgs = function (options) {
  var error;
  var self = this;
  var db = self.db;
  self.processCallback(options);
  if (db.enable) {
    db.deleteAllSysMsgs().then(function () {
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  }
  function bingo() {
    self.protocol.onUpdateSysMsgUnread({});
    options.done(error, options);
  }
};

/***/ }),

/***/ "./src/im/api/nim/team.js":
/*!********************************!*\
  !*** ./src/im/api/nim/team.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var Team = __webpack_require__(/*! im/model/team */ "./src/im/model/team.js");
var TeamMember = __webpack_require__(/*! im/model/teamMember */ "./src/im/model/teamMember.js");

/**
 * 创建群
 *
 * - {@link Team.type|普通群}不可以设置{@link Team.joinMode|群加入方式}
 * - {@link Team.type|高级群}的{@link Team.joinMode|群加入方式}默认为`'needVerify'`
 * - {@link Team.type|高级群}的{@link Team.beInviteMode|群被邀请模式}默认为`'needVerify'`
 * - {@link Team.type|高级群}的{@link Team.inviteMode|群邀请模式}默认为`'manager'`
 * - {@link Team.type|高级群}的{@link Team.updateTeamMode|群信息修改权限}默认为`'manager'`
 * - {@link Team.type|高级群}的{@link Team.updateCustomMode|群信息自定义字段修改权限}默认为`'manager'`
 * - {@link Team.type|普通群}被邀请的{@link TeamMember|群成员}在有人说话之后才会看到该{@link Team|群}, 而且会先收到一条类型为{@link IMMessage.attach|'addTeamMembers'}的{@link IMMessage.type|群通知消息}, 然后会收到其它{@link IMMessage.scene|群消息}。
 * - {@link Team.type|高级群}被邀请的{@link TeamMember|群成员}会收到一条类型为{@link SystemMessage.type|'teamInvite'}的{@link SystemMessage|系统通知}。
 *     - 接受邀请后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|'acceptTeamInvite'}的{@link IMMessage.type|群通知消息}。
 *     - 拒绝邀请后, `群主`会收到一条类型为{@link IMMessage.attach|'rejectTeamInvite'}的{@link SystemMessage|系统通知}。
 *
 * @method createTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options                   配置参数
 * @param  {String}   options.type              {@link Team.type|群类型}
 * @param  {String}   options.name              群名字
 * @param  {String}   options.avatar            群头像
 * @param  {String[]} options.accounts          要拉进群的成员的帐号列表
 * @param  {String}   [options.intro]           群简介
 * @param  {String}   [options.announcement]    群公告
 * @param  {String}   [options.joinMode]        {@link Team.joinMode|群加入方式}
 * @param  {String}   [options.beInviteMode]    {@link Team.beInviteMode|群被邀请模式}
 * @param  {String}   [options.inviteMode]      {@link Team.inviteMode|群邀请模式}
 * @param  {String}   [options.updateTeamMode]  {@link Team.updateTeamMode|群信息修改权限}
 * @param  {String}   [options.updateCustomMode]{@link Team.updateCustomMode|群信息自定义字段修改权限}
 * @param  {String}   [options.custom]          扩展字段
 * @param  {String}   [options.ps]              附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param  {done}     options.done              结果回调函数, 成功时会收到{@link Team|群资料}
 * @return {Void}
 *
 * @see {@link NIM#addTeamMembers|拉人入群}
 * @see {@link NIM#removeTeamMembers|踢人出群}
 * @see {@link NIM#updateTeam|更新群}
 *
 * @example
 * // 创建普通群
 * nim.createTeam({
 *     type: 'normal',
 *     name: '普通群',
 *     avatar: 'avatar',
 *     accounts: ['a1', 'a2'],
 *     ps: '我建了一个普通群',
 *     done: createTeamDone
 * });
 * // 创建高级群
 * nim.createTeam({
 *     type: 'advanced',
 *     name: '高级群',
 *     avatar: 'avatar',
 *     accounts: ['a1', 'a2'],
 *     intro: '群简介',
 *     announcement: '群公告',
 *     // joinMode: 'needVerify',
 *     // beInviteMode: 'needVerify',
 *     // inviteMode: 'manager',
 *     // updateTeamMode: 'manager',
 *     // updateCustomMode: 'manager',
 *     ps: '我建了一个高级群',
 *     done: createTeamDone
 * });
 * function createTeamDone(error, obj) {
 *     console.log('创建' + obj.team.type + '群' + (!error?'成功':'失败'), error, obj);
 *     if (!error) {
 *         onCreateTeam(obj.team, obj.owner);
 *     }
 * }
 */
NIMFn.createTeam = function (options) {
  util.verifyOptions(options, 'type name', 'team::createTeam');
  if (undef(options.accounts)) {
    options.accounts = [];
  } else {
    util.verifyParamType('accounts', options.accounts, 'array', 'team::createTeam');
  }
  options.action = 'create';
  this.processPs(options);
  this.processCallback(options);
  options.team = new Team(options);
  var content = {
    team: options.team,
    accounts: options.accounts.slice(0),
    ps: options.ps
  };
  this.sendCmd('createTeam', content, options.callback);
};

/**
 * 更新群
 *
 * - {@link Team.type|普通群}不可以更新
 *     - {@link Team.joinMode|群加入方式}
 *     - {@link Team.beInviteMode|群被邀请模式}
 *     - {@link Team.inviteMode|群邀请模式}
 *     - {@link Team.updateTeamMode|群信息修改权限}
 *     - {@link Team.updateCustomMode|群信息自定义字段修改权限}
 * - {@link NIM#updateTeam|更新群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'updateTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为更新群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为被更新的{@link Team|群信息}。
 *
 * @method updateTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options                   配置参数
 * @param  {String}   options.teamId            群id
 * @param  {String}   [options.name]            群名字
 * @param  {String}   [options.avatar]          群头像
 * @param  {String}   [options.intro]           群简介
 * @param  {String}   [options.announcement]    群公告
 * @param  {String}   [options.joinMode]        {@link Team.joinMode|群加入方式}
 * @param  {String}   [options.beInviteMode]    {@link Team.beInviteMode|群被邀请模式}
 * @param  {String}   [options.inviteMode]      {@link Team.inviteMode|群邀请模式}
 * @param  {String}   [options.updateTeamMode]  {@link Team.updateTeamMode|群信息修改权限}
 * @param  {String}   [options.updateCustomMode]{@link Team.updateCustomMode|群信息自定义字段修改权限}
 * @param  {String}   [options.custom]          扩展字段
 * @param  {done}     options.done              结果回调函数
 * @return {Void}
 *
 * @example
 * nim.updateTeam({
 *     teamId: '123',
 *     name: '群名字',
 *     avatar: 'avatar',
 *     intro: '群简介',
 *     announcement: '群公告',
 *     custom: '自定义字段',
 *     done: updateTeamDone
 * });
 * function updateTeamDone(error, team) {
 *     console.log('更新群' + (!error?'成功':'失败'), error, team);
 * }
 */
NIMFn.updateTeam = function (options) {
  util.verifyOptions(options, 'teamId', 'team::updateTeam');
  options.action = 'update';
  this.processCallback(options);
  options.team = new Team(options);
  this.sendCmd('updateTeam', { team: options.team, single: true }, options.callback);
};

/**
 * 拉人入群
 *
 * - 普通群, {@link NIM#addTeamMembers|拉人入群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|``'addTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为拉人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的[群对象](#群对象), `attach`有一个字段`accounts`的值为被拉的人的帐号列表, `attach`有一个字段`members`的值为被拉的群成员列表。
 *     - 被邀请的群成员在有人说话后才能看到该{@link Team|群}, 而且会先收到一条类型为{@link IMMessage.attach|`'addTeamMembers'`}的{@link IMMessage.type|群通知消息}, 然后会收到其它{@link Message|群消息}。
 * - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
 *     - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
 *     - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
 *
 * @method addTeamMembers
 * @memberOf NIM#
 *
 * @param  {Object}   options             配置参数
 * @param  {String}   options.teamId      群id
 * @param  {String[]} options.accounts    要拉进群的成员的帐号列表
 * @param  {String}   [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param  {String}   [options.custom]    自定义扩展字段，选填，最长512字符，开发者也可以使用JSON格式的字符串来扩展此内容
 * @param  {done}     options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#acceptTeamInvite|接受入群邀请}
 * @see {@link NIM#rejectTeamInvite|拒绝入群邀请}
 * @see {@link NIM#removeTeamMembers|踢人出群}
 *
 * @example
 * nim.addTeamMembers({
 *     teamId: '123',
 *     accounts: ['a3', 'a4'],
 *     ps: '加入我们的群吧',
 *     custom: '',
 *     done: addTeamMembersDone
 * });
 * function addTeamMembersDone(error, obj) {
 *     console.log('入群邀请发送' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.addTeamMembers = function (options) {
  util.verifyOptions(options, 'teamId accounts', 'team::addTeamMembers');
  util.verifyParamType('accounts', options.accounts, 'array', 'team::addTeamMembers');
  this.processPs(options);
  if (util.notexist(options.custom)) {
    options.custom = '';
  }
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    accounts: options.accounts.slice(0),
    ps: options.ps,
    attach: options.custom
  };
  this.sendCmd('addTeamMembers', content, options.callback);
};

/**
 * 踢人出群
 *
 * - {@link NIM#removeTeamMembers|踢人出群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'removeTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为踢人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`accounts`的值为被踢的人的帐号列表。
 *
 * @method removeTeamMembers
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String}     options.teamId      群id
 * @param  {String[]}   options.accounts    要移除的成员帐号列表
 * @param  {done}       options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#addTeamMembers|拉人入群}
 *
 * @example
 * nim.removeTeamMembers({
 *     teamId: '123',
 *     accounts: ['a3', 'a4'],
 *     done: removeTeamMembersDone
 * });
 * function removeTeamMembersDone(error, obj) {
 *     console.log('踢人出群' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.removeTeamMembers = function (options) {
  util.verifyOptions(options, 'teamId accounts', 'team::removeTeamMembers');
  util.verifyParamType('accounts', options.accounts, 'array', 'team::removeTeamMembers');
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    accounts: options.accounts.slice(0)
  };
  this.sendCmd('removeTeamMembers', content, options.callback);
};

/**
 * 接受入群邀请
 *
 * - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
 *     - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
 *     - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
 *
 * @method acceptTeamInvite
 * @memberOf NIM#
 *
 * @param  {Object}   options           配置参数
 * @param  {String}   options.idServer  对应的系统通知的 `idServer`
 * @param  {String}   options.teamId    群id
 * @param  {String}   options.from      邀请方的帐号
 * @param  {done}     options.done      结果回调函数, 成功时会收到{@link Team|群资料}
 * @return {Void}
 *
 * @see {@link NIM#rejectTeamInvite|拒绝入群邀请}
 * @see {@link NIM#addTeamMembers|拉人入群}
 * @see {@link NIM#getTeamMembers|获取群成员}
 *
 * @example
 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
 * nim.acceptTeamInvite({
 *     idServer: sysMsg.idServer,
 *     teamId: '123',
 *     from: 'zyy1',
 *     done: acceptTeamInviteDone
 * });
 * function acceptTeamInviteDone(error, obj) {
 *     console.log('接受入群邀请' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.acceptTeamInvite = function (options) {
  util.verifyOptions(options, 'idServer teamId from', 'team::acceptTeamInvite');
  this.processCallback(options);
  var content = {
    idServer: options.idServer,
    teamId: options.teamId,
    from: options.from
  };
  this.sendCmd('acceptTeamInvite', content, options.callback);
};

/**
 * 拒绝入群邀请
 *
 * - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
 *     - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
 *     - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
 *
 * @method rejectTeamInvite
 * @memberOf NIM#
 *
 * @param  {Object}   options           配置参数
 * @param  {String}   options.idServer  对应的系统通知的 `idServer`
 * @param  {String}   options.teamId    群id
 * @param  {String}   options.from      邀请方的帐号
 * @param  {String}   [options.ps]      附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param  {done}     options.done      结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#acceptTeamInvite|接受入群邀请}
 * @see {@link NIM#addTeamMembers|拉人入群}
 *
 * @example
 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
 * nim.rejectTeamInvite({
 *     idServer: sysMsg.idServer,
 *     teamId: '123',
 *     from: 'zyy1',
 *     ps: '就不',
 *     done: rejectTeamInviteDone
 * });
 * function rejectTeamInviteDone(error, obj) {
 *     console.log('拒绝入群邀请' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.rejectTeamInvite = function (options) {
  util.verifyOptions(options, 'idServer teamId from', 'team::rejectTeamInvite');
  this.processPs(options);
  this.processCallback(options);
  var content = {
    idServer: options.idServer,
    teamId: options.teamId,
    from: options.from,
    ps: options.ps
  };
  this.sendCmd('rejectTeamInvite', content, options.callback);
};

/**
 * 申请入群
 *
 * - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
 *     - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
 *     - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
 *
 * @method applyTeam
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {String}     [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link Team|群资料}
 * @return {Void}
 *
 * @see {@link NIM#passTeamApply|通过入群申请}
 * @see {@link NIM#rejectTeamApply|拒绝入群申请}
 *
 * @example
 * nim.applyTeam({
 *     teamId: '123',
 *     ps: '请加',
 *     done: applyTeamDone
 * });
 * function applyTeamDone(error, obj) {
 *     console.log('申请入群' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.applyTeam = function (options) {
  util.verifyOptions(options, 'teamId', 'team::applyTeam');
  this.processPs(options);
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    ps: options.ps
  };
  this.sendCmd('applyTeam', content, options.callback);
};

/**
 * 通过入群申请
 *
 * - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
 *     - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
 *     - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
 *
 * @method passTeamApply
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String}     options.idServer    对应的系统通知的 `idServer`
 * @param  {String}     options.teamId      群ID
 * @param  {String}     options.from        申请方的帐号
 * @param  {done}       options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#applyTeam|申请入群}
 * @see {@link NIM#rejectTeamApply|拒绝入群申请}
 *
 * @example
 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
 * nim.passTeamApply({
 *     idServer: sysMsg.idServer,
 *     teamId: '123',
 *     from: 'a2',
 *     done: passTeamApplyDone
 * });
 * function passTeamApplyDone(error, obj) {
 *     console.log('通过入群申请' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.passTeamApply = function (options) {
  util.verifyOptions(options, 'idServer teamId from', 'team::passTeamApply');
  this.processCallback(options);
  var content = {
    idServer: options.idServer,
    teamId: options.teamId,
    from: options.from
  };
  this.sendCmd('passTeamApply', content, options.callback);
};

/**
 * 拒绝入群申请
 *
 * - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
 *     - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
 *     - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
 *
 * @method rejectTeamApply
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String}     options.idServer    对应的系统通知的 `idServer`
 * @param  {String}     options.teamId      群ID
 * @param  {String}     options.from        申请方的帐号
 * @param  {String}     [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
 * @param  {done}       options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#applyTeam|申请入群}
 * @see {@link NIM#passTeamApply|通过入群申请}
 *
 * @example
 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
 * nim.rejectTeamApply({
 *     idServer: sysMsg.idServer,
 *     teamId: '123',
 *     from: 'a2',
 *     ps: '就不',
 *     done: rejectTeamApplyDone
 * });
 * function rejectTeamApplyDone(error, obj) {
 *     console.log('拒绝入群申请' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.rejectTeamApply = function (options) {
  util.verifyOptions(options, 'idServer teamId from', 'team::rejectTeamApply');
  this.processPs(options);
  this.processCallback(options);
  var content = {
    idServer: options.idServer,
    teamId: options.teamId,
    from: options.from,
    ps: options.ps
  };
  this.sendCmd('rejectTeamApply', content, options.callback);
};

/**
 * 添加群管理员
 *
 * - {@link NIM#addTeamManagers|添加群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'addTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为添加群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被加为管理员的帐号列表, `attach`有一个字段`members`的值为被加为管理员的群成员列表。
 *
 * @method addTeamManagers
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String}     options.teamId      群id
 * @param  {String[]}   options.accounts    要添加的管理员帐号列表
 * @param  {done}       options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#removeTeamManagers|移除群管理员}
 *
 * @example
 * nim.addTeamManagers({
 *     teamId: '123',
 *     accounts: ['a2', 'a3'],
 *     done: addTeamManagersDone
 * });
 * function addTeamManagersDone(error, obj) {
 *     console.log('添加群管理员' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.addTeamManagers = function (options) {
  util.verifyOptions(options, 'teamId accounts', 'team::addTeamManagers');
  util.verifyParamType('accounts', options.accounts, 'array', 'team::addTeamManagers');
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    accounts: options.accounts.slice(0)
  };
  this.sendCmd('addTeamManagers', content, options.callback);
};

/**
 * 移除群管理员
 *
 * - {@link NIM#removeTeamManagers|移除群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'removeTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为移除群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被移除的管理员的帐号列表, `attach`有一个字段`members`的值为被移除管理员的群成员列表。
 *
 * @method removeTeamManagers
 * @memberOf NIM#
 *
 * @param  {Object}   options             配置参数
 * @param  {String}   options.teamId      群id
 * @param  {String[]} options.accounts    要移除的管理员帐号列表
 * @param  {done}     options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#addTeamManagers|添加群管理员}
 *
 * @example
 * nim.removeTeamManagers({
 *     teamId: '123',
 *     accounts: ['a2', 'a3'],
 *     done: removeTeamManagersDone
 * });
 * function removeTeamManagersDone(error, obj) {
 *     console.log('移除群管理员' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.removeTeamManagers = function (options) {
  util.verifyOptions(options, 'teamId accounts', 'team::removeTeamManagers');
  util.verifyParamType('accounts', options.accounts, 'array', 'team::removeTeamManagers');
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    accounts: options.accounts.slice(0)
  };
  this.sendCmd('removeTeamManagers', content, options.callback);
};

/**
 * 修改自己的群属性
 *
 * 目前支持修改的属性有这些
 * - `nickInTeam`: 自己在群里面的群昵称
 *     - 更新昵称后, 所有其它在线的{@link TeamMember|群成员}会收到{@link NIM|初始化SDK}时传入的`onupdateteammember`回调。
 * - `muteTeam`: 是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定, 设置之后可以调用接口{@link NIM#notifyForNewTeamMsg}来查询是否需要群消息通知
 * - `custom`: 第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
 *
 * @method updateInfoInTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options               配置参数
 * @param  {String}   options.teamId        群id
 * @param  {String}   [options.nickInTeam]  在群里面的昵称
 * @param  {Boolean}  [options.muteTeam]    是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定
 * @param {Boolean} [options.custom] 第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
 * @param  {done}     options.done          结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#updateNickInTeam|修改别人的群昵称}
 *
 * @example
 * nim.updateInfoInTeam({
 *     teamId: '123',
 *     // 此参数为可选参数
 *     // nickInTeam: '群昵称',
 *     // 静音群, 此参数为可选参数
 *     // muteTeam: true,
 *     // 第三方扩展字段
 *     // custom: '{}'
 *     done: updateInfoInTeamDone
 * });
 * function updateInfoInTeamDone(error, obj) {
 *     console.log('修改自己的群属性' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.updateInfoInTeam = function (options) {
  // 注意, 这里以后如果开放了更多的参数, 要在 TeamMember 里面加上相应的验证 verifyParamAtLeastPresentOne
  util.verifyOptions(options, 'teamId', 'team::updateInfoInTeam');
  this.processCallback(options);
  this.sendCmd('updateInfoInTeam', { teamMember: new TeamMember(options), single: true }, options.callback);
};

/**
 * 修改别人的群昵称
 *
 * - 所有其它在线的{@link TeamMember|群成员}会收到{@link NIM|初始化SDK}时传入的`onupdateteammember`回调
 *
 * @method updateNickInTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options             配置参数
 * @param  {String}   options.teamId      群id
 * @param  {String}   options.account     要修改昵称的{@link TeamMember|群成员}的帐号
 * @param  {String}   options.nickInTeam  群昵称
 * @param  {done}     options.done        结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#updateInfoInTeam|修改自己的群属性}
 *
 * @example
 * nim.updateNickInTeam({
 *     teamId: '123',
 *     account: 'a2',
 *     nickInTeam: '群昵称',
 *     done: updateNickInTeamDone
 * });
 * function updateNickInTeamDone(error, obj) {
 *     console.log('修改自己的群属性' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.updateNickInTeam = function (options) {
  util.verifyOptions(options, 'teamId account', 'team::updateNickInTeam');
  this.processCallback(options);
  this.sendCmd('updateNickInTeam', { teamMember: new TeamMember(options), single: true }, options.callback);
};

/**
 * 更新群成员禁言状态
 *
 * - {@link NIM#updateMuteStateInTeam|更新群成员禁言状态}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'updateTeamMute'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为操作方, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为被禁言的帐号, `attach`有一个字段`members`的值为被禁言的群成员列表。
 *
 * @method updateMuteStateInTeam
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @param  {String}   options.teamId      群id
 * @param  {String}   options.account     要修改昵称的{@link TeamMember|群成员}的帐号
 * @param  {Boolean}  options.mute        是否要禁言
 * @param  {done}     options.done        结果回调函数
 * @return {Void}
 *
 * @example
 * nim.updateMuteStateInTeam({
 *     teamId: '123',
 *     account: 'a',
 *     mute: true,
 *     done: updateMuteStateInTeamDone
 * })
 * function updateMuteStateInTeamDone(error, obj) {
 *     console.log('更新群成员禁言状态' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.updateMuteStateInTeam = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamId account mute', 'team::updateMuteStateInTeam');
  self.processCallback(options);
  options.mute = options.mute ? 1 : 0;
  self.sendCmd('updateMuteStateInTeam', options);
};

/**
 * 获取群禁言成员列表
 *
 * @method getMutedTeamMembers
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @param {String[]} options.teamId 群 ID
 * @return {Void}
 *
 * @example
 * nim.getMutedTeamMembers({
 *   teamId: 'teamId',
 *   done: getMutedTeamMembersDone
 * })
 * function getMutedTeamMembersDone (error, obj) {
 *   console.log('获取群禁言成员列表' + (!error?'成功':'失败'));
 * }
 */
NIMFn.getMutedTeamMembers = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamId', 'team::getMutedTeamMembers');
  self.processCallback(options);
  self.sendCmd('getMutedTeamMembers', options);
};

/**
 * 主动退群
 *
 * - {@link NIM#leaveTeam|主动退群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'leaveTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为退群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}。
 *
 * @method leaveTeam
 * @memberOf NIM#
 *
 * @param  {Object}   options           配置参数
 * @param  {String}   options.teamId    群id
 * @param  {done}     options.done      结果回调函数
 * @return {Void}
 *
 * @example
 * nim.leaveTeam({
 *     teamId: '123',
 *     done: leaveTeamDone
 * });
 * function leaveTeamDone(error, obj) {
 *     console.log('主动退群' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.leaveTeam = function (options) {
  util.verifyOptions(options, 'teamId', 'team::leaveTeam');
  this.processCallback(options);
  var content = {
    teamId: options.teamId
  };
  this.sendCmd('leaveTeam', content, options.callback);
};

/**
 * 转让群
 *
 * - {@link NIM#transferTeam|转让群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'transferTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为转让群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为为新群主的帐号, `attach`有一个字段`members`的值为包含新旧群主的群成员列表。
 * - 如果转让群的同时离开群, 那么相当于调用{@link NIM#leaveTeam|主动退群}来离开群, 所有{@link TeamMember|群成员}会再收到一条类型为{@link IMMessage.attach|`'leaveTeam'`}的{@link IMMessage.type|群通知消息}。
 *
 * @method transferTeam
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {String}     options.account 新群主的帐号
 * @param  {Boolean}    options.leave   转让群的同时是否离开群
 * @param  {done}       options.done    结果回调函数
 * @return {Void}
 *
 * @see {@link NIM#leaveTeam|离开群}
 *
 * @example
 * nim.transferTeam({
 *     teamId: '123',
 *     account: 'zyy2',
 *     leave: false,
 *     done: transferOwnerDone
 * });
 * function transferOwnerDone(error, obj) {
 *     console.log('转让群' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.transferTeam = function (options) {
  util.verifyOptions(options, 'teamId account leave', 'team::transferTeam');
  util.verifyParamType('leave', options.leave, 'boolean', 'team::transferTeam');
  this.processCallback(options);
  var content = {
    teamId: options.teamId,
    account: options.account,
    leave: options.leave
  };
  this.sendCmd('transferTeam', content, options.callback);
};

/**
 * 解散群
 *
 * - {@link NIM#dismissTeam|解散群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'dismissTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段为解散群的人的帐号, `to`字段的值为被对应的群ID。
 *
 * @method dismissTeam
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {done}       options.done    结果回调函数
 * @return {Void}
 *
 * @example
 * nim.dismissTeam({
 *     teamId: '123',
 *     done: dismissTeamDone
 * });
 * function dismissTeamDone(error, obj) {
 *     console.log('解散群' + (!error?'成功':'失败'), error, obj);
 * }
 */
NIMFn.dismissTeam = function (options) {
  util.verifyOptions(options, 'teamId', 'team::dismissTeam');
  this.processCallback(options);
  var content = {
    teamId: options.teamId
  };
  this.sendCmd('dismissTeam', content, options.callback);
};

/**
 * 获取群
 *
 * - 开发者可以调用此接口获取群资料
 *
 * @method getTeam
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link Team|群资料}
 * @return {Void}
 *
 * @see {@link NIM#getTeams|获取群列表}
 * @see {@link NIM#getTeamMembers|获取群成员}
 *
 * @example
 * nim.getTeam({
 *     teamId: '123',
 *     done: getTeamDone
 * });
 * function getTeamDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('获取群' + (!error?'成功':'失败'));
 * }
 */
NIMFn.getTeam = function (options) {
  var self = this;
  var db = self.db;
  var teamId;
  util.verifyOptions(options, 'teamId', 'team::getTeam');
  self.processCallback(options);

  options.cbaop = function (error, obj) {
    if (!error) {
      self.logger.log('api::getTeam: cbaop ' + teamId, obj);
    }
  };

  teamId = options.teamId;
  if (db.enable && !options.sync) {
    db.getTeam(teamId).then(function (team) {
      if (team && team.validToCurrentUser) {
        // 检测群对当前用户的有效性，避免获取百八十年前离开群时的群资料
        self.logger.log('api::getTeam: db.getTeam ' + teamId, team);
        options.done(null, team);
      } else {
        getTeamFromServer();
      }
    }, getTeamFromServer);
  } else {
    getTeamFromServer();
  }
  function getTeamFromServer() {
    self.sendCmd('getTeam', { teamId: options.teamId }, options.callback);
  }
};

/**
 * 获取群列表
 *
 * - 如果开发者在{@link NIM|初始化SDK}的时候设置了`syncTeams`为`false`, 那么就收不到`onteams`回调, 可以调用此接口来获取{@link Team|群}列表
 *
 * @method getTeams
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link Team|群}列表
 * @return {Void}
 *
 * @see {@link NIM#getTeam|获取群资料}
 * @see {@link NIM#getTeamMembers|获取群成员}
 *
 * @example
 * nim.getTeams({
 *     done: getTeamsDone
 * });
 * function getTeamsDone(error, teams) {
 *     console.log(error);
 *     console.log(teams);
 *     console.log('获取群列表' + (!error?'成功':'失败'));
 * }
 */
NIMFn.getTeams = function (options) {
  var self = this;
  var db = self.db;
  var timetag = 0;
  util.verifyOptions(options);
  self.processCallback(options);
  if (db.enable) {
    db.getTeamsTimetag().then(function (t) {
      timetag = t;
      getTeamsFromServer();
    }, getTeamsFromServer);
  } else {
    getTeamsFromServer();
  }
  function getTeamsFromServer() {
    self.sendCmd('getTeams', { timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
  }
};

/**
 * 获取群成员
 *
 * - 如果开发者在{@link NIM|初始化SDK}时选择设置了`syncTeamMembers`为`false`, 那么就收不到`onteammembers`回调, 可以调用此方法来获取{@link TeamMember|群成员}列表
 * - 接受入群邀请之后调用此方法来获取{@link TeamMember|群成员}列表
 *
 * @method getTeamMembers
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {done}       options.done    结果回调函数, 成功时会额外附上{@link TeamMember|群成员}列表
 * @return {Void}
 *
 * @see {@link NIM#getTeam|获取群资料}
 * @see {@link NIM#getTeams|获取群列表}
 *
 * @example
 * nim.getTeamMembers({
 *     teamId: '123',
 *     done: getTeamMembersDone
 * });
 * function getTeamMembersDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('获取群成员' + (!error?'成功':'失败'));
 *     if (!error) {
 *         onTeamMembers(obj);
 *     }
 * }
 */
NIMFn.getTeamMembers = function (options) {
  var self = this;
  var timetag = 0;
  util.verifyOptions(options, 'teamId', 'team::getTeamMembers');
  self.processCallback(options);
  // var db = self.db
  // if (db.enable && !options.sync) {
  //   db.getTeam(options.teamId).then(function (team) {
  //     if (team) {
  //       var serverTimetag = team.memberUpdateTime
  //       db.getTeamMembersTimetag(options.teamId).then(function (localTimetag) {
  //           // 如果服务器的时间戳比本地的小, 说明最近同步过, 那么直接从本地获取群成员
  //         if (!isNaN(serverTimetag) && !isNaN(localTimetag) && serverTimetag <= localTimetag) {
  //             db.getTeamMembers(options.teamId).then(function (members) {
  //               options.done(null, {
  //                 teamId: options.teamId,
  //                 members: members
  //               })
  //             }, getTeamMembersFromServer)
  //           } else {
  //             timetag = localTimetag
  //             getTeamMembersFromServer()
  //           }
  //       }, getTeamMembersFromServer)
  //     } else {
  //       getTeamMembersFromServer()
  //     }
  //   }, getTeamMembersFromServer)
  // } else {
  //   getTeamMembersFromServer()
  // }
  // 群成员数据一律从服务器同步
  getTeamMembersFromServer();
  function getTeamMembersFromServer() {
    self.sendCmd('getTeamMembers', { teamId: options.teamId, timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
  }
};

/**
 * 通过群ID及成员账号获取群成员信息
 *
 * @method getTeamMemberByTeamIdAndAccount
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {String}     options.account  群成员账号
 * @param  {done}       options.done    结果回调函数, 成功时会额外附上{@link TeamMember|群成员}列表
 * @return {Void}
 *
 * @see {@link NIM#getTeam|获取群资料}
 * @see {@link NIM#getTeams|获取群列表}
 * @see {@link NIM#getTeamMembers|获取群成员列表}
 *
 * @example
 * nim.getTeamMemberByTeamIdAndAccount({
 *     teamId: '123',
 *     account: 'abc',
 *     done: getTeamMemberDone
 * });
 * function getTeamMemberDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('获取群成员' + (!error?'成功':'失败'));
 *     if (!error) {
 *         onTeamMember(obj);
 *     }
 * }
 */
NIMFn.getTeamMemberByTeamIdAndAccount = function (options) {
  var self = this;
  var timetag = 0;
  util.verifyParamType('teamId', options.teamId, 'numeric or numeric string', 'team::getTeamMemberByTeamIdAndAccount');
  util.verifyOptions(options, 'account', 'team::getTeamMemberByTeamIdAndAccount');
  self.processCallback(options);
  // 群成员数据一律从服务器同步
  getTeamMembersFromServer();
  function getTeamMembersFromServer() {
    self.sendCmd('getTeamMembers', { teamId: options.teamId, timetag: timetag, NOTSTORE: 'timetag' }, function (error, obj, content) {
      var result = {};
      if (obj && obj.members && obj.members.length) {
        for (var i = 0; i < obj.members.length; i++) {
          if (obj.members[i].account === options.account) {
            result[options.account] = obj.members[i];
            break;
          }
        }
      }
      options.callback(error, result, content);
    });
  }
};

/**
 * 获取群成员的邀请者accid
 *
 * @method getTeamMemberInvitorAccid
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.teamId  群id
 * @param  {String[]}   options.accounts  表示需要查询邀请者accid的群成员账号列表，一次最多查200个。当群成员数量小于等于200时为可选参数，不填默认查全部成员；群成员数量大于200时，需要将成员列表分批多次调用此接口查询。
 * @param  {done}       options.done    结果回调函数，返回数据类型为Object，key/value分别是群成员accid/邀请者accid
 * @return {Void}
 *
 * @see {@link NIM#getTeams|获取群列表}
 * @see {@link NIM#getTeamMembers|获取群成员列表}
 *
 * @example
 * nim.getTeamMemberInvitorAccid({
 *     teamId: '123',
 *     account: ['abc'],
 *     done: getTeamMemberInvitorAccidDone
 * });
 * function getTeamMemberInvitorAccidDone(error, obj) {
 *     console.log(error);
 *     console.log(obj);
 *     console.log('获取群成员邀请者' + (!error?'成功':'失败'));
 * }
 */
NIMFn.getTeamMemberInvitorAccid = function (options) {
  var self = this;
  var timetag = 0;
  util.verifyParamType('teamId', options.teamId, 'numeric or numeric string', 'team::getTeamMemberInvitorAccid');
  if (!undef(options.accounts)) {
    util.verifyParamType('accounts', options.accounts, 'array', 'team::getTeamMemberInvitorAccid');
    if (options.accounts.length > 200) {
      util.onParamError('accounts 参数数组长度不能超过200', 'team::getTeamMemberInvitorAccid');
    }
  }
  var data = { teamId: options.teamId };
  if (options.accounts.length) {
    data.accounts = options.accounts.slice(0);
  }
  self.processCallback(options);
  self.sendCmd('getTeamMemberInvitorAccid', data, function (error, obj, content) {
    options.callback(error, content && content.accountsMap || {});
  });
};

/**
 * 是否需要群消息通知
 *
 * @method notifyForNewTeamMsg
 * @memberOf NIM#
 *
 * @param  {Object}     options  配置参数
 * @param {String[]}    options.teamIds 群列表
 * @param  {done}       options.done    结果回调函数, 成功时会附上一个 map, key 是群 ID, value 是一个布尔值, 表示该群是否需要群消息通知
 * @return {Void}
 *
 * @example
 * nim.notifyForNewTeamMsg({
 *     teamIds: ['123'],
 *     done: notifyForNewTeamMsgDone
 * })
 * function notifyForNewTeamMsgDone(error, map) {
 *     console.log(error);
 *     console.log(map);
 *     console.log('查询是否需要群消息通知' + (!error?'成功':'失败'));
 * }
 */
NIMFn.notifyForNewTeamMsg = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamIds', 'team::notifyForNewTeamMsg');
  var promise = self.protocol.notifyForNewTeamMsg(options.teamIds);
  // if (self.usePromise(options)) {
  //     return promise
  // } else {
  //   promise.then(function (map) {
  //     options.done(null, map)
  //   }, function (error) {
  //     options.done(error)
  //   })
  // }
  promise.then(function (map) {
    options.done(null, map);
  }, function (error) {
    options.done(error);
  });
};

/**
 * 获取我所在的群对应的群成员
 * @private
 * @param  {Object} options 配置参数
 * @param {String[]} options.teamIds 群 ID 数组
 * @return {Void}
 */
NIMFn.getMyTeamMembers = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamIds', 'team::getMyTeamMembers');
  var promise = self.processCallbackPromise(options);
  self.sendCmd('getMyTeamMembers', options);
  return promise;
};

/**
 * 获取`teamIds`对应的本地群
 * - 如果不{@link support.db|支持数据库}, 算成功
 *
 * @method getLocalTeams
 * @memberOf NIM#
 *
 * @param  {Object}      options         配置参数
 * @param  {String[]}    options.teamIds teamId 数组
 * @param  {Function}    options.done    结果回调函数, 成功时会额外附上群列表
 * @return {Void}
 *
 * @example
 * nim.getLocalTeams({
 *     teamIds: teamIds
 *     done: getLocalTeamsDone
 * });
 * function getLocalTeamsDone(error, obj) {
 *     console.log('获取本地群' + (!error?'成功':'失败'));
 *     console.log(error);
 *     console.log(obj);
 * }
 */
NIMFn.getLocalTeams = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var teams = [];
  util.verifyOptions(options, 'teamIds', 'team::getLocalTeams');
  util.verifyParamType('teamIds', options.teamIds, 'array', 'team::getLocalTeams');
  self.processCallback(options);
  if (db.enable) {
    db.getTeamsByTeamIds(options.teamIds).then(function (records) {
      teams = records.filter(function (record) {
        return !!record;
      });
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.teams = teams;
    options.done(error, options);
  }
};

NIMFn.getLocalTeamMembers = function (options) {
  var self = this;
  var db = self.db;
  var error;
  var members = [];
  util.verifyOptions(options, 'teamId accounts', 'team::getLocalTeamMembers');
  util.verifyParamType('accounts', options.accounts, 'array', 'team::getLocalTeamMembers');
  self.processCallback(options);
  if (db.enable) {
    db.getInvalidTeamMembers(options.teamId, options.accounts).then(function (records) {
      members = records.filter(function (record) {
        return !!record;
      });
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.members = members;
    options.done(error, options);
  }
};

/**
 * 删除 `teamId` 对应的本地群
 * - 如果不{@link support.db|支持数据库}, 算成功
 * - 如果当前用户还在群里面, 那么会失败
 * - 如果对应的群不存在, 算成功
 * - 如果传了多个 teamId, 但是当前用户还在某个群里面, 那么会失败, 但是所有用户不在的群都会被删掉
 *
 * @method deleteLocalTeam
 * @memberOf NIM#
 *
 * @param  {Object}             options         配置参数
 * @param  {String|String[]}    options.teamId  teamId 或者 teamId 数组
 * @param  {Function}           options.done    结果回调函数
 * @return {Void}
 *
 * @example
 * nim.deleteLocalTeam({
 *     teamId: '1234',
 *     done: deleteLocalTeamDone
 * });
 * function deleteLocalTeamDone(error, obj) {
 *     console.log('删除本地群' + (!error?'成功':'失败'));
 *     console.log(error);
 *     console.log(obj);
 * }
 */
NIMFn.deleteLocalTeam = function (options) {
  var self = this;
  var db = self.db;
  var error;
  util.verifyOptions(options, 'teamId', 'team::deleteLocalTeam');
  self.processCallback(options);
  if (db.enable) {
    db.deleteTeam(options.teamId).then(function () {
      bingo();
    }, function (event) {
      error = event;
      bingo();
    });
  } else {
    bingo();
  }
  function bingo() {
    options.done(error, options);
  }
};

/**
 * 群组禁言
 *
 * @method muteTeamAll
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @param  {String} options.teamId 待禁言群的群id
 * @param  {String} options.type 禁言类型 none: 不禁言 normal: 普通成员禁言 all: 全部禁言(包括群主)
 * @return {Void}
 *
 * @example
 * nim.muteTeamAll({
 *      teamId: '1027484',
 *      type: 'normal'
 *   },
 *   done: muteTeamAllDone
 * })
 * function muteTeamAllDone (error, obj) {
 *   console.log('禁言群' + (!error?'成功':'失败'));
 * }
 */
NIMFn.muteTeamAll = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamId type', 'team::muteTeamAll');
  switch (options.type) {
    case 'none':
      options.muteType = 0;
      break;
    case 'normal':
      options.muteType = 1;
      break;
    case 'all':
      options.muteType = 2;
      break;
    default:
      options.muteType = 1;
      break;
  }
  self.processCallback(options);
  self.sendCmd('muteTeamAll', options);
};

/**
 * 标记群组消息已读
 *
 * @method sendTeamMsgReceipt
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @param  {Object[]} options.teamMsgReceipts 已读消息对象
 * @param  {String} options.teamMsgReceipt.teamId  群序号
 * @param  {String} options.teamMsgReceipt.idServer  消息编号
 * @return {Void}
 *
 * @example
 * nim.sendTeamMsgReceipt({
 *   teamMsgReceipts: [{
 *      teamId: '1027484',
 *      idServer: '68953284018302'
 *   }],
 *   done: sendTeamMsgReceiptDone
 * })
 * function sendTeamMsgReceiptDone (error, obj) {
 *   console.log('标记群组消息已读' + (!error?'成功':'失败'));
 * }
 */
NIMFn.sendTeamMsgReceipt = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamMsgReceipts', 'team::sendTeamMsgReceipt');
  self.processCallback(options);
  self.sendCmd('sendTeamMsgReceipt', options);
};

/**
 * 查询群组消息已读、未读数量
 *
 * @method getTeamMsgReads
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @param  {Object[]} options.teamMsgReceipts 已读消息对象
 * @param  {String} options.teamMsgReceipt.teamId  群序号
 * @param  {String} options.teamMsgReceipt.idServer  消息编号
 * @return {Void}
 *
 * @example
 * nim.getTeamMsgReads({
 *   teamMsgReceipts: [{
 *      teamId: '1027484',
 *      idServer: '68953284018302'
 *   }],
 *   done: getTeamMsgReadsDone
 * })
 * function getTeamMsgReadsDone (error, obj) {
 *   console.log('查询群组消息已读、未读数量' + (!error?'成功':'失败'));
 * }
 */
NIMFn.getTeamMsgReads = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamMsgReceipts', 'team::getTeamMsgReads');
  self.processCallback(options);
  self.sendCmd('getTeamMsgReads', options);
};

/**
 * 查询群组已读、未读账号列表
 *
 * @method getTeamMsgReadAccounts
 * @memberOf NIM#
 *
 * @param  {Object} options 配置参数
 * @param  {Object[]} options.teamMsgReceipt 已读消息对象
 * @param  {String} options.teamMsgReceipt.teamId  群序号
 * @param  {String} options.teamMsgReceipt.idServer  消息编号
 * @return {Void}
 *
 * @example
 * nim.getTeamMsgReadAccounts({
 *   teamMsgReceipt: {
 *      teamId: '1027484',
 *      idServer: '68953284018302'
 *   },
 *   done: getTeamMsgReadAccountsDone
 * })
 * function getTeamMsgReadAccountsDone (error, obj) {
 *   console.log('查询群组已读、未读账号列表' + (!error?'成功':'失败'));
 * }
 */
NIMFn.getTeamMsgReadAccounts = function (options) {
  var self = this;
  util.verifyOptions(options, 'teamMsgReceipt', 'team::getTeamMsgReadAccounts');
  self.processCallback(options);
  self.sendCmd('getTeamMsgReadAccounts', options);
};

/***/ }),

/***/ "./src/im/api/nim/user.js":
/*!********************************!*\
  !*** ./src/im/api/nim/user.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NIMFn = __webpack_require__(/*! ./index */ "./src/im/api/nim/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var objs2accounts = util.objs2accounts;
var User = __webpack_require__(/*! im/model/user */ "./src/im/model/user.js");

/**
 * 更新我的名片
 *
 * @method updateMyInfo
 * @memberOf NIM#
 *
 * @param  {Object} options         配置参数
 * @param  {String} options.nick    昵称
 * @param  {String} options.avatar  头像
 * @param  {String} options.sign    签名
 * @param  {String} options.gender  {@link User.gender|性别}
 * @param  {String} options.email   邮箱
 * @param  {String} options.birth   生日
 * @param  {String} options.tel     手机号
 * @param  {String} options.custom  扩展字段
 * @return {Void}
 *
 * @see {@link NIM#getUser|获取用户名片}
 * @see {@link NIM#getUsers|获取用户名片数组}
 * @see {@link NIM#updateMyInfo|更新登录用户的名片}
 *
 * @example
 * nim.updateMyInfo({
 *     nick: 'newNick',
 *     avatar: 'http://newAvatar',
 *     sign: 'newSign',
 *     gender: 'male',
 *     email: 'new@email.com',
 *     birth: '1900-01-01',
 *     tel: '13523578129',
 *     custom: '{type: "newCustom", value: "new"}',
 *     done: updateMyInfoDone
 * });
 * function updateMyInfoDone(error, user) {
 *     console.log('更新登录用户的名片' + (!error?'成功':'失败'), error, user);
 *     if (!error) {
 *         onUpdateMyInfo(user);
 *     }
 * }
 */
NIMFn.updateMyInfo = function (options) {
  util.verifyOptions(options);
  this.processCallback(options);
  options.user = new User(options);
  // 更新自己的名片不用传 account
  delete options.user.account;
  this.sendCmd('updateMyInfo', { user: options.user, single: true }, options.callback);
};

/**
 * 获取我的名片
 * @private
 * @param  {Object} options 配置参数
 * @return {Void}
 */
NIMFn.getMyInfo = function (options) {
  var self = this;
  options = options || {};
  options.account = self.account;
  return self.getUser(options);
};

/**
 * 获取用户名片
 *
 * @method getUser
 * @memberOf NIM#
 *
 * @param  {Object}     options         配置参数
 * @param  {String}     options.account 账号
 * @param  {Function}   options.done    结果回调函数, 成功时会返回用户名片
 * @return {Void}
 *
 * @see {@link NIM#getUser|获取用户名片}
 * @see {@link NIM#getUsers|获取用户名片数组}
 * @see {@link NIM#updateMyInfo|更新登录用户的名片}
 *
 * @example
 * nim.getUser({
 *     account: 'account',
 *     done: getUserDone
 * });
 * function getUserDone(error, user) {
 *     console.log('获取用户名片' + (!error?'成功':'失败'), error, obj);
 *     if (!error && user) {
 *         onUsers(user);
 *     }
 * }
 */
NIMFn.getUser = function (options) {
  var self = this;
  var db = self.db;
  var account;
  util.verifyOptions(options, 'account', 'user::getUser');
  self.processCallback(options);

  options.cbaop = function (error, obj) {
    if (!error) {
      obj = obj[0] || null;
      self.logger.log('api::getUser: cbaop ' + account, obj);
      return obj;
    }
  };

  account = options.account;
  if (options.sync) {
    getUserFromServer();
  } else {
    if (db.enable) {
      db.getUser(account).then(function (user) {
        if (user) {
          self.logger.log('api::getUser: db.getUser ' + account, user);
          options.done(null, user);
        } else {
          getUserFromServer();
        }
      }, getUserFromServer);
    } else {
      getUserFromServer();
    }
  }

  function getUserFromServer() {
    self.sendCmd('getUsers', { accounts: [account], single: true }, options.callback);
  }
};

/**
 * 获取用户名片数组
 *
 * - 每次最多 150 个
 *
 * @method getUsers
 * @memberOf NIM#
 *
 * @param  {Object}     options             配置参数
 * @param  {String[]}   options.accounts    账号数组
 * @param  {Function}   options.done        结果回调函数, 成功时会返回用户名片列表
 * @return {Void}
 *
 * @see {@link NIM#getUser|获取用户名片}
 * @see {@link NIM#getUsers|获取用户名片数组}
 * @see {@link NIM#updateMyInfo|更新登录用户的名片}
 *
 * @example
 * nim.getUsers({
 *     accounts: ['account1', 'account2'],
 *     done: getUsersDone
 * });
 * function getUsersDone(error, users) {
 *     console.log('获取用户名片数组' + (!error?'成功':'失败'), error, users);
 *     if (!error && users.length) {
 *         onUsers(users);
 *     }
 * }
 */
NIMFn.getUsers = function (options) {
  var self = this;
  var db = self.db;
  var accounts;
  var usersLocal = [];

  util.verifyOptions(options, 'accounts', 'user::getUsers');
  util.verifyParamType('accounts', options.accounts, 'array', 'user::getUsers');
  self.processCallback(options);

  options.cbaop = function (error, obj) {
    if (!error) {
      obj = obj.concat(usersLocal);
      self.logger.log('api::getUsers: cbaop ' + accounts, obj);
      return obj;
    }
  };

  // 去重后校验长度
  accounts = util.deduplicate(options.accounts);
  util.verifyArrayMax('accounts', options.accounts, 150, 'user::getUsers');

  if (options.sync) {
    getUsersFromServer();
  } else {
    if (db.enable) {
      db.getUsers(accounts).then(function (users) {
        if (!!users && users.length === accounts.length) {
          self.logger.log('api::getUsers: db.getUsers', users);
          options.done(null, users);
        } else {
          usersLocal = users;
          // 如果从数据库只拿到了部分用户名片, 那么从服务器获取剩下的用户名片
          var accountsLocal = objs2accounts(users);
          var accountsServer = [];
          accounts.forEach(function (account) {
            if (accountsLocal.indexOf(account) === -1) {
              accountsServer.push(account);
            }
          });
          accounts = accountsServer;
          getUsersFromServer();
        }
      }, getUsersFromServer);
    } else {
      getUsersFromServer();
    }
  }
  function getUsersFromServer() {
    self.sendCmd('getUsers', { accounts: accounts, single: true }, options.callback);
  }
};

/***/ }),

/***/ "./src/im/db/broadcastMsg.js":
/*!***********************************!*\
  !*** ./src/im/db/broadcastMsg.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var TableBroadcastMsg = 'broadcastMsg';

DBFn.putBroadcastMsg = function (broadcastMsgs) {
  var self = this;
  return new Promise(function (resolve) {
    if (!util.isArray(broadcastMsgs)) {
      broadcastMsgs = [broadcastMsgs];
    }
    var array = [];
    var counter = broadcastMsgs.length;
    broadcastMsgs.forEach(function (broadcastMsg) {
      broadcastMsg = util.copy(broadcastMsg);
      self.put(TableBroadcastMsg, broadcastMsg).then(function (record) {
        array.push(record[0]);
        bingo();
      }, bingo);
    });
    // 就算有失败, 也算完成, 最终返回所有存储成功的记录
    function bingo() {
      counter--;
      if (counter === 0) {
        resolve(array);
      }
    }
  });
};

DBFn.getBroadcastMsgs = function (options) {
  var self = this;
  options = options || {};
  return self.getAll(TableBroadcastMsg, options);
};

/***/ }),

/***/ "./src/im/db/friend.js":
/*!*****************************!*\
  !*** ./src/im/db/friend.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var TableFriend = 'friend';

/*
 * 更新好友、删除好友
 * - 成功后更新对应的好友时间戳
 */
DBFn.mergeFriends = function (friends, friends2delete, timetag) {
  var self = this;
  return self.updateAndDelete(TableFriend, friends, friends2delete).then(function () {
    self.logger.log('db::mergeFriends: updateAndDelete done', friends);
    // 此时间戳不一定有
    if (timetag) {
      self.updateFriendTimetag(timetag);
    }
    return [friends, friends2delete, timetag];
  });
};

DBFn.putFriend = function (friend) {
  return this.put(TableFriend, friend);
};

/*
 * 更新好友, 加好友都走这里
 */
DBFn.updateFriend = function (friend) {
  var self = this;
  // 先复制, 不受外界干扰
  friend = util.copy(friend);
  var account = friend.account;
  return this.getOne(TableFriend, null, account, {
    modifyObj: friend
  }).then(function (record) {
    if (record) {
      self.logger.log('db::updateFriend: ' + account, friend);
    } else {
      self.logger.warn('db::updateFriend: no record ' + account);
    }
    return record;
  });
};

DBFn.deleteFriend = function (account) {
  var self = this;
  var p1 = self.remove(TableFriend, account);
  var p2 = self.deleteUser(account);
  return Promise.all([p1, p2]);
};

DBFn.getFriends = function () {
  var filter = function filter(friend) {
    return friend.valid;
  };
  return this.getAll(TableFriend, {
    filter: filter
  });
};

DBFn.getFriend = function (account) {
  return this.getOne(TableFriend, null, account);
};

/***/ }),

/***/ "./src/im/db/index.js":
/*!****************************!*\
  !*** ./src/im/db/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DB = __webpack_require__(/*! dbjs */ "./src/polyfill/libDb/general.js");

DB.fn = DB.prototype;

module.exports = DB;

__webpack_require__(/*! ./kv */ "./src/im/db/kv.js");
__webpack_require__(/*! ./timetag */ "./src/im/db/timetag.js");
__webpack_require__(/*! ./relation */ "./src/im/db/relation.js");
__webpack_require__(/*! ./friend */ "./src/im/db/friend.js");
__webpack_require__(/*! ./team */ "./src/im/db/team.js");
__webpack_require__(/*! ./superTeam */ "./src/im/db/superTeam.js");
__webpack_require__(/*! ./user */ "./src/im/db/user.js");
__webpack_require__(/*! ./msg */ "./src/im/db/msg.js");
__webpack_require__(/*! ./sysMsg */ "./src/im/db/sysMsg.js");
__webpack_require__(/*! ./broadcastMsg */ "./src/im/db/broadcastMsg.js");
__webpack_require__(/*! ./session */ "./src/im/db/session.js");

/***/ }),

/***/ "./src/im/db/kv.js":
/*!*************************!*\
  !*** ./src/im/db/kv.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var TableKV = 'kv';

DBFn.setKey = function (key, value) {
  return this.put(TableKV, {
    key: key,
    value: value
  });
};

DBFn.getKey = function (key) {
  return this.get(TableKV, key).then(function (record) {
    return record && record.value;
  });
};

DBFn.setDonnop = function (config) {
  return this.setKey('donnop', config);
};

DBFn.getDonnop = function () {
  return this.getKey('donnop');
};

/***/ }),

/***/ "./src/im/db/msg.js":
/*!**************************!*\
  !*** ./src/im/db/msg.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var TableSession = 'session';
var TableMsg = 'msg1';
var IndexSession = 'sessionId';
var IndexTime = 'time';
var IndexStatus = 'status';
var IndexSessionTime = 'sessionTime';
/*
 * 存储消息
 */
DBFn.putMsg = function (msgs) {
  var self = this;
  if (!util.isArray(msgs)) {
    msgs = [msgs];
  }
  // 如果没有消息或者是过滤（云商服专用）, 直接返回
  if (!msgs.length || msgs[0].filter) {
    return Promise.resolve();
  }
  msgs = msgs.filter(function (msg) {
    return !msg.ignore;
  });
  return self.put(TableMsg, msgs);
};

/*
 * 更新消息
 * 只允许更新 localCustom
 */
DBFn.updateMsg = function (msg) {
  var self = this;
  // 如果是过滤（云商服专用）, 直接返回
  if (msg.filter) {
    return;
  }
  var idClient = msg.idClient;
  var modifyObj = util.filterObj(msg, 'resend status idServer time localCustom');
  return self.getOne(TableMsg, null, idClient, {
    modifyObj: modifyObj
  }).then(function (record) {
    if (record) {
      self.logger.log('db::updateMsg: ' + idClient, modifyObj);
    } else {
      self.logger.warn('db::updateMsg: no record ' + idClient);
    }
    return record;
  });
};

/**
 *  获取消息列表
 *
 *  @private
 *  @param  {Object} options  查询参数
 *  @param {String} [options.sessionId] 如果提供该参数, 那么查询该会话的消息
 *  @param {String[]} [options.sessionIds] 如果提供该参数[indexedDB专用], 那么查询这几个会话的消息
 *  @param {Number} [options.start=0] 开始时间
 *  @param {Number} [options.end=Infinity] 结束时间
 *  @param {Boolean} [options.desc=true] true 表示从 end 开始查, false 表示从 begin 开始查
 *  @param {Number} [options.limit=100] limit 数量限制
 *  @param {String} [options.type] 如果提供该参数, 那么查询该类型的消息
 *  @param {String[]} [options.types] 如果提供该参数[indexedDB专用], 那么查询这几种类型的消息
 *  @param {String} [options.keyword] 如果提供参数[indexedDB专用], 那么查询匹配该关键词的消息
 *  @param {Function} [options.filterFunc] 可选参数[indexedDB专用], 过滤函数, 接收消息对象, 返回 true 表示结果保留该消息
 *  @return {Promise}
 */

DBFn.getMsgs = function (options) {
  if (Config.isBrowser) {
    return this.getMsgsIndexedDB(options);
  } else if (Config.isRN) {
    return this.getMsgsRN(options);
  } else {
    return Promise.resolve();
  }
};

DBFn.getMsgsRN = function (options) {
  var self = this;
  var config = {};
  if (typeof options.start === 'number') {
    config.lowerBound = ['time', options.start];
  }
  if (typeof options.end === 'number' && options.end !== Infinity) {
    config.upperBound = ['time', options.end];
  }
  config.desc = false;
  config.sortIndex = 'time';
  if (typeof options.desc === 'boolean') {
    config.desc = options.desc;
  }
  if (typeof options.limit === 'number') {
    config.limit = options.limit;
  }
  config.searchIndex = [];
  if (options.sessionId) {
    config.searchIndex.push(['sessionId', options.sessionId]);
  }
  if (typeof options.type === 'string') {
    config.searchIndex.push(['type', options.type]);
  }
  return self.getAll(TableMsg, config);
};

DBFn.getMsgsIndexedDB = function (options) {
  var self = this;
  self.checkDB();

  options = options || {};
  var index = IndexTime;

  // 检测是否按照会话过滤, 同时如果是单会话, 切换索引
  var filterSession = false;
  var multiSession = false;
  var sessionId = options.sessionId || [];
  var sessionIds = options.sessionIds || [];
  if (util.isString(sessionId)) {
    sessionId = [sessionId];
  } else if (!Array.isArray(sessionId)) {
    sessionId = [];
  }
  if (util.isString(sessionIds)) {
    sessionIds = [sessionIds];
  } else if (!Array.isArray(sessionIds)) {
    sessionIds = [];
  }
  var allSession = sessionId.concat(sessionIds);
  if (allSession.length === 1) {
    filterSession = true;
    index = IndexSessionTime;
    sessionId = allSession[0];
  } else if (allSession.length > 1) {
    filterSession = true;
    multiSession = true;
    sessionIds = allSession;
  }

  // bound
  var start = options.start || 0;
  var end = options.end || Infinity;
  var lowerBound = start;
  var upperBound = end;
  // 如果是搜索单个会话, 那么 bound 的值是不一样的
  if (filterSession && !multiSession) {
    lowerBound = [sessionId, start];
    upperBound = [sessionId, end];
  }

  // order & limit
  var desc = options.desc !== false;
  var limit = options.limit || 100;

  // 单类型还是多类型
  var filterType = false;
  var multiType = false;
  var type = options.type || [];
  var types = options.types || [];
  if (util.isString(type)) {
    type = [type];
  } else if (!Array.isArray(type)) {
    type = [];
  }
  if (util.isString(types)) {
    types = [types];
  } else if (!Array.isArray(types)) {
    types = [];
  }
  var allType = type.concat(types);
  if (allType.length === 1) {
    filterType = true;
    type = allType[0];
  } else if (allType.length > 1) {
    filterType = true;
    multiType = true;
    types = allType;
  }

  var keyword = options.keyword || '';
  var filterFunc = options.filterFunc;

  var filter = void 0;
  if (multiSession || filterType || keyword || util.isFunction(filterFunc)) {
    filter = function filter(record) {
      if (multiSession && sessionIds.indexOf(record.sessionId) === -1) {
        return false;
      }
      if (filterType) {
        if (multiType) {
          if (types.indexOf(record.type) === -1) {
            return false;
          }
        } else {
          if (type !== record.type) {
            return false;
          }
        }
      }
      if (keyword) {
        var text = record.text || record.tip || '';
        if (text.indexOf(keyword) === -1) {
          return false;
        }
      }
      if (filterFunc) {
        return filterFunc(record);
      }
      return true;
    };
  }
  // return self.getAll(TableMsg, {
  //   index,
  //   lowerBound,
  //   upperBound,
  //   desc,
  //   limit,
  //   filter
  // })
  return self.server.query(TableMsg, index).bound(lowerBound, upperBound, true, true).desc(desc).limit(limit).filter(filter).execute();
};

DBFn.getMsgCountAfterAck = function (options) {
  if (Config.isBrowser) {
    return this.getMsgCountAfterAckIndexedDB(options);
  } else if (Config.isRN) {
    return this.getMsgCountAfterAckRN(options);
  } else {
    return Promise.resolve();
  }
};

// 开启同步会话未读数时，计算未读数
DBFn.getMsgCountAfterAckRN = function (options) {
  var self = this;
  options = options || {};
  var _options = options,
      sessionId = _options.sessionId,
      ack = _options.ack;

  self.checkDB();
  return self.getAll(TableMsg, {
    searchIndex: ['sessionId', sessionId],
    lowerBound: ['time', ack]
  }).then(function (msgs) {
    // 自己发的消息不算未读数，dbjs.filter函数有问题，手动算了
    var returnMsgs = msgs.filter(function (msg) {
      if (msg.flow === 'out') {
        return false;
      } else if (msg.type === 'notification') {
        if (options.shouldCountNotifyUnread(msg)) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    });
    return Promise.resolve(returnMsgs.length);
  });
};

// 开启同步会话未读数时，计算未读数
DBFn.getMsgCountAfterAckIndexedDB = function (options) {
  var self = this;
  options = options || {};
  var _options2 = options,
      sessionId = _options2.sessionId;

  self.checkDB();
  return self.server.query(TableMsg, IndexSessionTime).bound([sessionId, options.ack], [sessionId, Infinity], true, true) // 不包含ack
  .execute()
  // return self.getAll(
  //   TableMsg, {
  //     index: IndexSessionTime,
  //     lowerBound: [sessionId, options.ack],
  //     upperBound: [sessionId, Infinity]
  //   }
  // )
  .then(function (msgs) {
    // 自己发的消息不算未读数，dbjs.filter函数有问题，手动算了
    var returnMsgs = msgs.filter(function (msg) {
      if (msg.flow === 'out') {
        return false;
      } else if (msg.type === 'notification') {
        if (options.shouldCountNotifyUnread(msg)) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    });
    return Promise.resolve(returnMsgs.length);
  });
};

// 不返回给开发者某些属性，以及加一些额外的属性
DBFn.amendMsg = function (msg) {
  if (msg) {
    // 如果没有 text 字段，补一个空的
    if (util.notexist(msg.text)) {
      msg.text = '';
    }
    return msg;
  } else {
    return null;
  }
};

DBFn.getMsgByIdClient = function (idClient) {
  var self = this;
  return self.getOne(TableMsg, null, idClient).then(function (record) {
    return self.amendMsg(record);
  });
};

DBFn.getMsgsByIdClients = function (idClients) {
  var self = this;
  var array = [];
  var promise;
  idClients.forEach(function (idClient) {
    promise = self.getMsgByIdClient(idClient);
    array.push(promise);
  });
  return Promise.all(array);
};

DBFn.clearSendingMsgs = function () {
  var self = this;
  return self.getOnly(TableMsg, IndexStatus, 'sending', {
    modifyObj: {
      status: 'fail'
    }
  }).then(function (results) {
    self.logger.log('db::clearSendingMsgs: msgs send failed', results);
  });
};

// idClients 单个或数组
DBFn.deleteMsg = function (idClients) {
  var self = this;
  var array = [];
  var promise;
  if (!util.isArray(idClients)) {
    idClients = [idClients];
  }
  idClients.forEach(function (idClient) {
    promise = self.getOne(TableMsg, null, idClient, {
      remove: true
    }).then(function (msg) {
      self.logger.log('db::deleteMsg:', msg);
      return msg;
    });
    array.push(promise);
  });
  return array.length === 1 ? array[0] : Promise.all(array);
};

DBFn.deleteMsgsBySessionId = function (options) {
  var self = this;
  return self.getOnly(TableMsg, IndexSession, options.sessionId, {
    remove: true
  });
};

// 删除所有消息和会话
DBFn.deleteAllMsgs = function () {
  var self = this;
  var p1 = self.clearTable(TableMsg);
  var p2 = self.clearTable(TableSession);
  return Promise.all([p1, p2]);
};

/***/ }),

/***/ "./src/im/db/relation.js":
/*!*******************************!*\
  !*** ./src/im/db/relation.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var TableBlacklist = 'blacklist';
var TableMutelist = 'mutelist';

/*
 * 更新、删除
 * - 成功后更新时间戳
 */
DBFn.mergeRelations = function (blacklist, blacklist2delete, mutelist, mutelist2delete, timetag) {
  var self = this;
  var p1 = self.updateAndDelete(TableBlacklist, blacklist, blacklist2delete);
  var p2 = self.updateAndDelete(TableMutelist, mutelist, mutelist2delete);
  return Promise.all([p1, p2]).then(function () {
    self.logger.log('db::mergeRelations: timetag ' + timetag);
    self.updateRelationTimetag(timetag);
    return [blacklist, blacklist2delete, mutelist, mutelist2delete, timetag];
  });
};

DBFn.getRelations = function () {
  var self = this;
  var p1 = self.getAll(TableBlacklist);
  var p2 = self.getAll(TableMutelist);
  return Promise.all([p1, p2]);
};

DBFn.markInBlacklist = function (obj) {
  var self = this;
  // 先复制, 不受外界干扰
  obj = util.copy(obj);
  if (obj.isAdd) {
    var record = obj.record;
    return self.put(TableBlacklist, record);
  } else {
    var account = obj.account;
    return self.remove(TableBlacklist, account);
  }
};

DBFn.markInMutelist = function (obj) {
  var self = this;
  // 先复制, 不受外界干扰
  obj = util.copy(obj);
  if (obj.isAdd) {
    var record = obj.record;
    return self.put(TableMutelist, record);
  } else {
    var account = obj.account;
    return self.remove(TableMutelist, account);
  }
};

/***/ }),

/***/ "./src/im/db/session.js":
/*!******************************!*\
  !*** ./src/im/db/session.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var TableSession = 'session';
var IndexUpdateTime = 'updateTime';

/*
 * 存储会话, 如果没有记录, 那么创建新的纪录
 */
DBFn.putSession = function (session) {
  session = util.merge({}, session);
  if (typeof session.updateTime === 'undefined') {
    if (session.lastMsg && session.lastMsg.time) {
      session.updateTime = session.lastMsg.time;
    }
  }
  delete session.unread;
  return this.modifyOrPut({
    table: TableSession,
    obj: session,
    key: 'id',
    modifyObjWhenPut: {
      unread: 0
    }
  });
};

// params sessionId 或 lastSessionId
DBFn.getSessions = function (options) {
  options = options || {};
  var desc = !options.reverse;
  var limit = options.limit || 100;
  // 如果没有提供 lastSessionId, 那么匹配所有的记录
  // 如果提供了 lastSessionId, 那么匹配从 lastSessionId 的下一条开始的所有记录
  var lastSessionId = options.lastSessionId;
  var sessionId = options.sessionId;
  var findLastRecord = false;
  var filter;
  if (notundef(lastSessionId)) {
    filter = function filter(session) {
      if (findLastRecord) {
        return true;
      } else {
        if (session.id === lastSessionId) {
          findLastRecord = true;
        }
        return false;
      }
    };
  } else if (notundef(sessionId)) {
    return this.get(TableSession, sessionId);
  }
  return this.getAll(TableSession, {
    index: IndexUpdateTime,
    desc: desc,
    limit: limit,
    filter: filter
  });
};

DBFn.getSession = function (sessionId) {
  return this.get(TableSession, sessionId);
};

/*
 * 修改已有的会话
 * 只允许更新部分字段
 */
DBFn.updateSession = function (session) {
  var self = this;
  var sessionId = session.id;
  var modifyObj = util.filterObj(session, 'ack unread lastMsg localCustom msgReceiptTime msgReceiptServerTime');
  Object.keys(session).forEach(function (key) {
    if (key.indexOf('last') === 0) {
      modifyObj[key] = session[key];
    }
  });
  return this.getOne(TableSession, null, sessionId, {
    modifyObj: modifyObj
  }).then(function (record) {
    if (record) {
      self.logger.log('db::updateSession: ' + sessionId, modifyObj);
    } else {
      self.logger.warn('db::updateSession: no record ' + sessionId);
    }
    return record;
  });
};

DBFn.resetSessionUnread = function (sessionId) {
  return this.updateSession({
    id: sessionId,
    unread: 0
  });
};

/**
 * 删除会话
 * @private
 * @param  {String|String[]} id     id 或者 id 数组
 */
DBFn.deleteSession = function (id) {
  return this.remove(TableSession, id);
};

/***/ }),

/***/ "./src/im/db/superTeam.js":
/*!********************************!*\
  !*** ./src/im/db/superTeam.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var SuperTeam = __webpack_require__(/*! im/model/superTeam */ "./src/im/model/superTeam.js");
var SuperTeamMember = __webpack_require__(/*! im/model/superTeamMember */ "./src/im/model/superTeamMember.js");
var TableTeam = 'superTeam';
var IndexTeamId = 'teamId';
var IndexAccount = 'account';
var TableTeamMember = 'superTeamMember';

/*
 * 更新群和解散群
 * - 成功后更新对应的群时间戳
 */
DBFn.mergeSuperTeams = function (teams, teams2delete, timetag) {
  var self = this;
  var p1 = self.put(TableTeam, teams);
  var p2 = self.leaveTeams(teams2delete, timetag);
  return Promise.all([p1, p2]).then(function () {
    self.logger.log('db::mergeSuperTeams:');
    self.updateSuperTeamTimetag(timetag);
    return [teams, teams2delete, timetag];
  });
};

/*
 * 添加群
 */
DBFn.putSuperTeam = function (teams) {
  if (!teams) {
    return;
  }
  if (!util.isArray(teams)) {
    teams = [teams];
  }
  teams.forEach(function (team) {
    // 创建群时服务器并没有返回这个字段
    team.validToCurrentUser = true;
  });
  return this.put(TableTeam, teams);
};

DBFn.updateSuperTeam = function (team) {
  var self = this;
  // 先复制, 不受外界干扰
  team = util.copy(team);
  var teamId = team.teamId;
  return self.getOne(TableTeam, null, teamId, {
    modifyObj: team
  }).then(function (record) {
    if (record) {
      self.logger.log('db::updateSuperTeam: ' + teamId, team);
    } else {
      self.logger.warn('db::updateSuperTeam: no record ' + teamId);
      return self.putSuperTeam(team);
    }
    return record;
  });
};

/*
 * 离开群
 * - 标记该群（成功后更新对应的群时间戳）
 * - 成功后移除该群的所有群成员（成功后移除对应的群成员时间戳）
 */
DBFn.leaveSuperTeam = function (teamId) {
  var self = this;
  return self.updateSuperTeam({
    teamId: teamId,
    validToCurrentUser: false
  }).then(function () {
    return self.removeAllSuperTeamMembers(teamId);
  });
};

/*
 * 解散群
 * - 标记该群
 * - 成功后移除该群的所有群成员（成功后移除对应的群成员时间戳）
 */
DBFn.dismissSuperTeam = function (teamId, timetag) {
  var self = this;
  var modifyObj = {
    teamId: teamId,
    valid: false,
    validToCurrentUser: false,
    updateTime: timetag
  };
  return self.updateSuperTeam(modifyObj).then(function () {
    return self.removeAllSuperTeamMembers(teamId);
  });
};

DBFn.leaveSuperTeams = function (teams, timetag) {
  var self = this;
  var array = [];
  var promise;
  teams.forEach(function (team) {
    promise = self.leaveSuperTeam(team.teamId, timetag);
    array.push(promise);
  });
  return Promise.all(array);
};

DBFn.getSuperTeamsByTeamIds = function (teamIds) {
  var self = this;
  var array = [];
  var promise;
  teamIds.forEach(function (teamId) {
    promise = self.getSuperTeam(teamId);
    array.push(promise);
  });
  return Promise.all(array);
};

DBFn.getSuperTeam = function (teamId) {
  teamId = '' + teamId;
  var self = this;
  return self.getOne(TableTeam, null, teamId).then(function (team) {
    if (!team) {
      return null;
    }
    self.updateSuperTeamProperties([team]);
    return team;
  });
};

/**
 * 同步过程中会调用这个方法, 在这里要对升级过程中缺失的字段进行补充
 */
DBFn.getSuperTeams = function () {
  var self = this;
  return self.getAll(TableTeam, {
    filter: isValidTeamToCurrentUser
  }).then(function (teams) {
    self.updateSuperTeamProperties(teams);
    return teams;
  });
};

function isValidTeamToCurrentUser(team) {
  return team.valid && team.validToCurrentUser;
}

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 */
DBFn.updateSuperTeamProperties = function (teams) {
  teams.forEach(function (team) {
    if (team) {
      SuperTeam.fillProperties(team);
    }
  });
};

DBFn.mergeSuperTeamMembers = function (teamId, members, members2delete, timetag) {
  var self = this;
  var p1 = self.putSuperTeamMembers(members);
  var p2 = self.updateSuperTeamMembers(members2delete);
  return Promise.all([p1, p2]).then(function () {
    self.logger.log('db::mergeSuperTeamMembers: ' + teamId);
    return self.updateSuperTeamMemberTimetag(teamId, timetag);
  });
};

/*
 * 群成员
 */

DBFn.putSuperTeamMembers = function (members) {
  return this.put(TableTeamMember, members);
};

function teamMemberIsValid(teamMember) {
  return teamMember && teamMember.valid;
}

// 对缺失字段进行补充
function amendTeamMember(teamMember) {
  if (teamMember) {
    util.fillUndef(teamMember, {
      mute: false,
      custom: ''
    });
  }
  return teamMember;
}

DBFn.getSuperTeamMembersByAccount = function (account) {
  var self = this;
  return self.getOnly(TableTeamMember, IndexAccount, account, {
    filter: teamMemberIsValid,
    mapper: amendTeamMember
  }).then();
};

/**
 * 同步过程中会调用这个方法, 在这里要对升级过程中缺失的字段进行补充
 */
DBFn.getSuperTeamMembers = function (teamId) {
  var self = this;
  teamId = '' + teamId;
  var filter = function filter(teamMember) {
    return teamMember.valid;
  };
  return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
    filter: filter,
    mapper: amendTeamMember
  }).then(function (members) {
    return self.updateSuperTeamMemberProperties(members).then(function () {
      return members;
    });
  });
};

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 * 不再使用, 统一使用 amendTeamMember
 */
DBFn.updateSuperTeamMemberProperties = function (members) {
  var self = this;
  var array = [];
  var p;
  members.forEach(function (member) {
    if (SuperTeamMember.fillProperties(member)) {
      p = self.updateSuperTeamMember(member);
      array.push(p);
    }
  });
  return Promise.all(array);
};

DBFn.getInvalidSuperTeamMembers = function (teamId, accounts) {
  var self = this;
  teamId = '' + teamId;
  var array = [];
  var promise;
  accounts.forEach(function (account) {
    promise = self.getOne(TableTeamMember, 'id', SuperTeamMember.genId(teamId, account)).then(function (member) {
      return amendTeamMember(member);
    });
    array.push(promise);
  });
  return Promise.all(array);
};

/*
 * 更新群成员
 */
DBFn.updateSuperTeamMember = function (member) {
  var self = this;
  var teamId = member.teamId;
  var account = member.account;
  var id = SuperTeamMember.genId(teamId, account);
  // member 包含 account id 等不需要更新的属性, 所以先过滤一下
  var modifyObj = util.filterObj(member, 'nickInTeam muteTeam mute custom updateTime type valid');
  return this.getOne(TableTeamMember, 'id', id, {
    modifyObj: modifyObj,
    mapper: amendTeamMember
  }).then(function (m) {
    if (m) {
      self.logger.log('db::updateSuperTeamMember: ' + teamId + ' ' + account, modifyObj);
    } else {
      self.logger.warn('db::updateSuperTeam: no record ' + teamId + ' ' + account);
    }
    return m;
  });
};

/*
 * 更新群成员
 */
DBFn.updateSuperTeamMembers = function (members) {
  var self = this;
  if (!members.length) {
    return Promise.resolve();
  }
  var array = [];
  var promise;
  members.forEach(function (member) {
    promise = self.updateSuperTeamMember(member);
    array.push(promise);
  });
  return Promise.all(array);
};

/*
 * 更新群的管理员
 * - 后续性能如果有问题的话, 增加一个索引, idType = id + type
 */
// DBFn.updateSuperTeamManagers = function (teamId, accounts, isManager, timetag) {
//   var members = accounts.map(function (account) {
//     return {
//       teamId: teamId,
//       account: account,
//       type: isManager ? 'manager' : 'normal',
//       updateTime: timetag
//     }
//   })
//   return this.updateSuperTeamMembers(members)
// }

DBFn.removeSuperTeamMembersByAccounts = function (teamId, accounts) {
  var members = accounts.map(function (account) {
    return {
      teamId: teamId,
      account: account,
      valid: false
    };
  });
  return this.updateSuperTeamMembers(members);
};

/*
 * 移除群的所有群成员, 成功后移除对应的群成员时间戳
 */
DBFn.removeAllSuperTeamMembers = function (teamId) {
  var self = this;
  var modifyObj = {
    valid: false
  };
  return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
    modifyObj: modifyObj
  }).then(function () {
    self.logger.warn('db::removeAllSuperTeamMembers: ' + teamId);
    return self.deleteSuperTeamMemberTimetag(teamId);
  });
};

DBFn.deleteSuperTeamMembers = function (teamId) {
  var self = this;
  return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
    remove: true
  }).then(function () {
    self.logger.warn('db::deleteTeamMembers: ' + teamId);
    self.deleteSuperTeamMemberTimetag(teamId);
  });
};

/*
 * 删除群 单个或者数组
 * - 如果还在群里面, 那么不删除
 */
DBFn.deleteSuperTeam = function (teamIds) {
  var self = this;
  var array = [];
  var promise;
  if (!util.isArray(teamIds)) {
    teamIds = [teamIds];
  }
  teamIds.forEach(function (teamId) {
    teamId = '' + teamId;
    promise = self.get(TableTeam, teamId).then(function (team) {
      if (!!team && isValidTeamToCurrentUser(team)) {
        throw NIMError.stillInTeamError({ callFunc: 'team::deleteTeam', team: team });
      } else {
        var p1 = self.remove(TableTeam, teamId);
        var p2 = self.deleteSuperTeamMembers(teamId);
        return Promise.all([p1, p2]);
      }
    });
    array.push(promise);
  });
  return array.length === 1 ? array[0] : Promise.all(array);
};

/***/ }),

/***/ "./src/im/db/sysMsg.js":
/*!*****************************!*\
  !*** ./src/im/db/sysMsg.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var TableSysMsg = 'sysMsg';
var IndexIdServer = 'idServer';
var IndexType = 'type';
var IndexCategory = 'category';
var TableSysMsgUnread = 'sysMsgUnread';

/*
 * 存储系统通知（不存自定义系统通知）
 * - 收到离线系统通知
 * - 收到系统通知
 * 策略为只管存, 并且保存存储成功的系统通知,
 * 如果失败, 说明对应的系统通知已经存在, 那么刚好过滤掉,
 * 最终返回所有存储成功的系统通知
 */
DBFn.putSysMsg = function (sysMsgs) {
  var self = this;
  return new Promise(function (resolve) {
    if (!util.isArray(sysMsgs)) {
      sysMsgs = [sysMsgs];
    }
    // 如果是过滤（云商服专用）, 直接返回
    if (sysMsgs[0].filter) {
      return;
    }
    var array = [];
    var counter = sysMsgs.length;
    sysMsgs.forEach(function (sysMsg) {
      sysMsg = util.copy(sysMsg);
      self.put(TableSysMsg, sysMsg).then(function (record) {
        array.push(record[0]);
        bingo();
      }, bingo);
    });
    // 就算有失败, 也算完成, 最终返回所有存储成功的记录
    function bingo() {
      counter--;
      if (counter === 0) {
        resolve(array);
      }
    }
  });
};

/*
 * 获取系统通知
 */
DBFn.getSysMsgs = function (options) {
  var self = this;
  options = options || {};
  var desc = !options.reverse;
  var limit = options.limit || 100;
  var index = null;
  var matchValue = null;
  // 如果有种类, 更换索引
  if (options.category) {
    index = IndexCategory;
    matchValue = options.category;
  }
  // 如果有类型, 更换索引
  if (options.type) {
    index = IndexType;
    matchValue = options.type;
  }
  // 如果没有提供 lastIdServer 和 read, 那么匹配所有的记录
  // 如果提供了 lastIdServer, 那么匹配从 lastIdServer 的下一条开始的所有记录
  // 如果提供了 read, 那么匹配该属性
  var lastIdServer = options.lastIdServer;
  var findLastRecord = false;
  var read = options.read;
  var filter;
  if (notundef(lastIdServer) || notundef(read)) {
    filter = function filter(sysMsg) {
      if (notundef(lastIdServer)) {
        lastIdServer = '' + lastIdServer;
        if (findLastRecord) {
          return bingo();
        } else {
          if (sysMsg.idServer === lastIdServer) {
            findLastRecord = true;
          }
          return false;
        }
      }
      return bingo();
      function bingo() {
        if (notundef(read)) {
          return sysMsg.read === read;
        }
        return true;
      }
    };
  }
  options = {
    filter: filter,
    desc: desc,
    limit: limit
  };
  if (!index) {
    return self.getAll(TableSysMsg, options);
  } else {
    return self.getOnly(TableSysMsg, index, matchValue, options);
  }
};

DBFn.getSysMsgByIdServer = function (idServer) {
  return this.getOne(TableSysMsg, IndexIdServer, idServer);
};

/*
 * 更新系统通知
 * 只允许更新 read, state, localCustom
 */
DBFn.updateSysMsg = function (sysMsg) {
  var self = this;
  if (sysMsg.filter) {
    return;
  }
  var idServer = '' + sysMsg.idServer;
  var modifyObj = util.filterObj(sysMsg, 'read state error localCustom');
  return this.getOne(TableSysMsg, IndexIdServer, idServer, {
    modifyObj: modifyObj
  }).then(function (record) {
    if (record) {
      self.logger.log('db::updateSysMsg: ' + idServer, modifyObj);
    } else {
      self.logger.warn('db::updateSession: ' + idServer);
    }
    return record;
  });
};

/*
 * 标记系统通知为已读
 * sysMsgs 可以为数组或者单个
 */
DBFn.markSysMsgRead = function (sysMsgs) {
  var self = this;
  return new Promise(function (resolve, reject) {
    if (!util.isArray(sysMsgs)) {
      sysMsgs = [sysMsgs];
    }
    var checkArray = [];
    var checkPromise;
    var markArray = [];
    var markPromise;
    sysMsgs.forEach(function (sysMsg) {
      checkPromise = self.getSysMsgByIdServer(sysMsg.idServer).then(function (sysMsg) {
        if (!!sysMsg && !sysMsg.read) {
          markPromise = self.updateSysMsg({
            idServer: sysMsg.idServer,
            read: true
          });
          markArray.push(markPromise);
        }
      }, reject);
      checkArray.push(checkPromise);
    });
    Promise.all(checkArray).then(function () {
      Promise.all(markArray).then(function (records) {
        resolve(records);
      }, reject);
    }, reject);
  });
};

/*
 * 删除系统通知
 * idServers 可以为数组或者单个
 */
DBFn.deleteSysMsg = function (idServers) {
  var self = this;
  var array = [];
  var promise;
  if (!util.isArray(idServers)) {
    idServers = [idServers];
  }
  idServers.forEach(function (idServer) {
    idServer = '' + idServer;
    promise = self.getOne(TableSysMsg, IndexIdServer, idServer, {
      remove: true
    });
    array.push(promise);
  });
  return array.length === 1 ? array[0] : Promise.all(array);
};

DBFn.deleteAllSysMsgs = function () {
  var self = this;
  var p1 = self.clearTable(TableSysMsg);
  var p2 = self.clearTable(TableSysMsgUnread);
  return Promise.all([p1, p2]);
};

/*
 * 获取系统通知未读数
 */
DBFn.getSysMsgUnread = function () {
  return this.getAll(TableSysMsgUnread).then(function (records) {
    var obj = {};
    records.forEach(function (record) {
      obj[record.type] = record.num;
    });
    return obj;
  });
};

/*
 * 更新系统通知未读数
 */
DBFn.updateSysMsgUnread = function (sysMsgUnread) {
  var self = this;
  // 先复制, 不受外界干扰
  sysMsgUnread = util.copy(sysMsgUnread);
  var records = [];
  Object.keys(sysMsgUnread).forEach(function (type) {
    records.push({
      type: type,
      num: sysMsgUnread[type]
    });
  });
  return this.put(TableSysMsgUnread, records).then(function () {
    self.logger.log('db::updateSysMsgUnread: ', sysMsgUnread);
    return sysMsgUnread;
  });
};

/***/ }),

/***/ "./src/im/db/team.js":
/*!***************************!*\
  !*** ./src/im/db/team.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var Team = __webpack_require__(/*! im/model/team */ "./src/im/model/team.js");
var TeamMember = __webpack_require__(/*! im/model/teamMember */ "./src/im/model/teamMember.js");
var TableTeam = 'team';
var IndexTeamId = 'teamId';
var IndexAccount = 'account';
var TableTeamMember = 'teamMember';

/*
 * 更新群和解散群
 * - 成功后更新对应的群时间戳
 */
DBFn.mergeTeams = function (teams, teams2delete, timetag) {
  var self = this;
  var p1 = self.put(TableTeam, teams);
  var p2 = self.leaveTeams(teams2delete, timetag);
  return Promise.all([p1, p2]).then(function () {
    self.logger.log('db::mergeTeams:');
    self.updateTeamTimetag(timetag);
    return [teams, teams2delete, timetag];
  });
};

/*
 * 添加群
 */
DBFn.putTeam = function (teams) {
  if (!teams) {
    return;
  }
  if (!util.isArray(teams)) {
    teams = [teams];
  }
  teams.forEach(function (team) {
    // 创建群时服务器并没有返回这个字段
    team.validToCurrentUser = true;
  });
  return this.put(TableTeam, teams);
};

DBFn.updateTeam = function (team) {
  var self = this;
  // 先复制, 不受外界干扰
  team = util.copy(team);
  var teamId = team.teamId;
  return self.getOne(TableTeam, null, teamId, {
    modifyObj: team
  }).then(function (record) {
    if (record) {
      self.logger.log('db::updateTeam: ' + teamId, team);
    } else {
      self.logger.warn('db::updateTeam: no record ' + teamId);
      if (team.validToCurrentUser) {
        // 不存储之前不存在，对当前用户无效的群信息
        return self.putTeam(team);
      }
    }
    return record;
  });
};

/*
 * 转让群
 * - 更新两个的群成员
 * - 成功后更新群
 */
DBFn.transferTeam = function (team, from, to) {
  var self = this;
  var teamId = team.teamId;
  var memberUpdateTime = team.memberUpdateTime;
  var m1 = {
    teamId: teamId,
    account: from,
    type: 'normal',
    updateTime: memberUpdateTime
  };
  var m2 = {
    teamId: teamId,
    account: to,
    type: 'owner',
    updateTime: memberUpdateTime
  };
  return self.updateTeamMembers([m1, m2]).then(function () {
    return self.putTeam(team).then(function () {
      self.logger.log('db::transferTeam: ' + team.teamId + ' ' + from + ' -> ' + to);
      return [team, from, to];
    });
  });
};

/*
 * 离开群
 * - 标记该群（成功后更新对应的群时间戳）
 * - 成功后移除该群的所有群成员（成功后移除对应的群成员时间戳）
 */
DBFn.leaveTeam = function (teamId) {
  var self = this;
  return self.updateTeam({
    teamId: teamId,
    validToCurrentUser: false
  }).then(function () {
    return self.removeAllTeamMembers(teamId);
  });
};

/*
 * 解散群
 * - 标记该群
 * - 成功后移除该群的所有群成员（成功后移除对应的群成员时间戳）
 */
DBFn.dismissTeam = function (teamId, timetag) {
  var self = this;
  var modifyObj = {
    teamId: teamId,
    valid: false,
    validToCurrentUser: false,
    updateTime: timetag
  };
  return self.updateTeam(modifyObj).then(function () {
    return self.removeAllTeamMembers(teamId);
  });
};

DBFn.leaveTeams = function (teams, timetag) {
  var self = this;
  var array = [];
  var promise;
  teams.forEach(function (team) {
    promise = self.leaveTeam(team.teamId, timetag);
    array.push(promise);
  });
  return Promise.all(array);
};

DBFn.getTeamsByTeamIds = function (teamIds) {
  var self = this;
  var array = [];
  var promise;
  teamIds.forEach(function (teamId) {
    promise = self.getTeam(teamId);
    array.push(promise);
  });
  return Promise.all(array);
};

DBFn.getTeam = function (teamId) {
  teamId = '' + teamId;
  var self = this;
  return self.getOne(TableTeam, null, teamId).then(function (team) {
    if (!team) {
      return null;
    }
    self.updateTeamProperties([team]);
    return team;
  });
};

/**
 * 同步过程中会调用这个方法, 在这里要对升级过程中缺失的字段进行补充
 */
DBFn.getTeams = function () {
  var self = this;
  return self.getAll(TableTeam, {
    filter: isValidTeamToCurrentUser
  }).then(function (teams) {
    self.updateTeamProperties(teams);
    return teams;
  });
};

function isValidTeamToCurrentUser(team) {
  return team.valid && team.validToCurrentUser;
}

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 */
DBFn.updateTeamProperties = function (teams) {
  teams.forEach(function (team) {
    if (team) {
      Team.fillProperties(team);
    }
  });
};

DBFn.mergeTeamMembers = function (teamId, members, members2delete, timetag) {
  var self = this;
  var p1 = self.putTeamMembers(members);
  var p2 = self.updateTeamMembers(members2delete);
  return Promise.all([p1, p2]).then(function () {
    self.logger.log('db::mergeTeamMembers: ' + teamId);
    return self.updateTeamMemberTimetag(teamId, timetag);
  });
};

/*
 * 群成员
 */

DBFn.putTeamMembers = function (members) {
  return this.put(TableTeamMember, members);
};

function teamMemberIsValid(teamMember) {
  return teamMember && teamMember.valid;
}

// 对缺失字段进行补充
function amendTeamMember(teamMember) {
  if (teamMember) {
    util.fillUndef(teamMember, {
      mute: false,
      custom: ''
    });
  }
  return teamMember;
}

DBFn.getTeamMembersByAccount = function (account) {
  var self = this;
  return self.getOnly(TableTeamMember, IndexAccount, account, {
    filter: teamMemberIsValid,
    mapper: amendTeamMember
  }).then();
};

/**
 * 同步过程中会调用这个方法, 在这里要对升级过程中缺失的字段进行补充
 */
DBFn.getTeamMembers = function (teamId) {
  var self = this;
  teamId = '' + teamId;
  var filter = function filter(teamMember) {
    return teamMember.valid;
  };
  return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
    filter: filter,
    mapper: amendTeamMember
  }).then(function (members) {
    return self.updateTeamMemberProperties(members).then(function () {
      return members;
    });
  });
};

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 * 不再使用, 统一使用 amendTeamMember
 */
DBFn.updateTeamMemberProperties = function (members) {
  var self = this;
  var array = [];
  var p;
  members.forEach(function (member) {
    if (TeamMember.fillProperties(member)) {
      p = self.updateTeamMember(member);
      array.push(p);
    }
  });
  return Promise.all(array);
};

DBFn.getInvalidTeamMembers = function (teamId, accounts) {
  var self = this;
  teamId = '' + teamId;
  var array = [];
  var promise;
  accounts.forEach(function (account) {
    promise = self.getOne(TableTeamMember, null, TeamMember.genId(teamId, account)).then(function (member) {
      return amendTeamMember(member);
    });
    array.push(promise);
  });
  return Promise.all(array);
};

/*
 * 更新群成员
 */
DBFn.updateTeamMember = function (member) {
  var self = this;
  var teamId = member.teamId;
  var account = member.account;
  var id = TeamMember.genId(teamId, account);
  // member 包含 account id 等不需要更新的属性, 所以先过滤一下
  var modifyObj = util.filterObj(member, 'nickInTeam muteTeam mute custom updateTime type valid');
  return this.getOne(TableTeamMember, null, id, {
    modifyObj: modifyObj,
    mapper: amendTeamMember
  }).then(function (m) {
    if (m) {
      self.logger.log('db::updateTeamMember: ' + teamId + ' ' + account, modifyObj);
    } else {
      self.logger.warn('db::updateTeam: no record ' + teamId + ' ' + account);
    }
    return m;
  });
};

/*
 * 更新群成员
 */
DBFn.updateTeamMembers = function (members) {
  var self = this;
  if (!members.length) {
    return Promise.resolve();
  }
  var array = [];
  var promise;
  members.forEach(function (member) {
    promise = self.updateTeamMember(member);
    array.push(promise);
  });
  return Promise.all(array);
};

/*
 * 更新群的管理员
 * - 后续性能如果有问题的话, 增加一个索引, idType = id + type
 */
DBFn.updateTeamManagers = function (teamId, accounts, isManager, timetag) {
  var members = accounts.map(function (account) {
    return {
      teamId: teamId,
      account: account,
      type: isManager ? 'manager' : 'normal',
      updateTime: timetag
    };
  });
  return this.updateTeamMembers(members);
};

DBFn.removeTeamMembersByAccounts = function (teamId, accounts) {
  var members = accounts.map(function (account) {
    return {
      teamId: teamId,
      account: account,
      valid: false
    };
  });
  return this.updateTeamMembers(members);
};

/*
 * 移除群的所有群成员, 成功后移除对应的群成员时间戳
 */
DBFn.removeAllTeamMembers = function (teamId) {
  var self = this;
  var modifyObj = {
    valid: false
  };
  return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
    modifyObj: modifyObj
  }).then(function () {
    self.logger.warn('db::removeAllTeamMembers: ' + teamId);
    return self.deleteTeamMemberTimetag(teamId);
  });
};

DBFn.deleteTeamMembers = function (teamId) {
  var self = this;
  return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
    remove: true
  }).then(function () {
    self.logger.warn('db::deleteTeamMembers: ' + teamId);
    self.deleteTeamMemberTimetag(teamId);
  });
};

/*
 * 删除群 单个或者数组
 * - 如果还在群里面, 那么不删除
 */
DBFn.deleteTeam = function (teamIds) {
  var self = this;
  var array = [];
  var promise;
  if (!util.isArray(teamIds)) {
    teamIds = [teamIds];
  }
  teamIds.forEach(function (teamId) {
    teamId = '' + teamId;
    promise = self.get(TableTeam, teamId).then(function (team) {
      if (!!team && isValidTeamToCurrentUser(team)) {
        throw NIMError.stillInTeamError({ callFunc: 'team::deleteTeam', team: team });
      } else {
        var p1 = self.remove(TableTeam, teamId);
        var p2 = self.deleteTeamMembers(teamId);
        return Promise.all([p1, p2]);
      }
    });
    array.push(promise);
  });
  return array.length === 1 ? array[0] : Promise.all(array);
};

/***/ }),

/***/ "./src/im/db/timetag.js":
/*!******************************!*\
  !*** ./src/im/db/timetag.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;

DBFn.getTimetags = function (filter) {
  var timetags = {};
  var mapper = function mapper(record) {
    if (record.name.indexOf('team-') !== -1) {
      // 群成员全部为全量同步
      timetags[record.name] = 0;
    } else {
      timetags[record.name] = record.value;
    }
    return record;
  };
  return this.getAll('timetag', {
    filter: filter,
    mapper: mapper
  }).then(function () {
    return timetags;
  });
};

DBFn.getTeamMemberTimetags = function () {
  return this.getTimetags(function (record) {
    return record.name.indexOf('team-') !== -1;
  });
};

DBFn.getTimetag = function (name) {
  return this.getOne('timetag', null, name).then(function (obj) {
    obj = obj || { value: 0 };
    return obj.value;
  });
};

DBFn.getTeamMemberTimetag = function (teamId) {
  return 0; // this.getTimetag('team-' + teamId)
};

DBFn.updateTimetag = function (name, timetag) {
  var record = { name: name, value: timetag };
  return this.put('timetag', record);
};

DBFn.updateMyInfoTimetag = function (timetag) {
  return this.updateTimetag('myInfo', timetag);
};

DBFn.updateRelationTimetag = function (timetag) {
  return this.updateTimetag('relations', timetag);
};

DBFn.getRelationsTimetag = function () {
  return this.getTimetag('relations');
};

DBFn.updateFriendTimetag = function (timetag) {
  return this.updateTimetag('friends', timetag);
};

DBFn.getFriendsTimetag = function () {
  return this.getTimetag('friends');
};

DBFn.updateFriendUserTimetag = function (timetag) {
  return this.updateTimetag('friendUsers', timetag);
};

DBFn.updateTeamTimetag = function (timetag) {
  return this.updateTimetag('teams', timetag);
};

DBFn.getTeamsTimetag = function () {
  return this.getTimetag('teams');
};

DBFn.updateSuperTeamTimetag = function (timetag) {
  return this.updateTimetag('superTeams', timetag);
};

DBFn.getSuperTeamsTimetag = function () {
  return this.getTimetag('superTeams');
};

DBFn.updateTeamMemberTimetag = function (teamId, timetag) {
  return this.updateTimetag('team-' + teamId, timetag);
};

DBFn.getTeamMembersTimetag = function (teamId) {
  return this.getTimetag('team-' + teamId);
};

DBFn.updateSuperTeamMemberTimetag = function (teamId, timetag) {
  return this.updateTimetag('superTeam-' + teamId, timetag);
};

DBFn.getSuperTeamMembersTimetag = function (teamId) {
  return this.getTimetag('superTeam-' + teamId);
};

DBFn.updateMyTeamMembersTimetag = function (timetag) {
  return this.updateTimetag('myTeamMembers', timetag);
};

DBFn.getBroadcastMsgTimetag = function (timetag) {
  return this.getTimetag('broadcastMsg');
};

DBFn.updateBroadcastMsgTimetag = function (timetag) {
  return this.updateTimetag('broadcastMsg', parseInt(timetag));
};

/*
 * 什么时候更新漫游消息时间戳
 * - 收到漫游消息和离线消息后, 拿到最后一条消息的时间戳, 再更新漫游消息时间戳
 * - 发消息成功后更新漫游消息时间戳
 * - 收到消息后更新漫游消息时间戳
 */
DBFn.updateRoamingMsgTimetag = function (timetag) {
  return this.updateTimetag('roamingMsgs', timetag);
};
DBFn.updateSuperTeamRoamingMsgTimetag = function (timetag) {
  return this.updateTimetag('superTeamRoamingMsgs', timetag);
};

DBFn.updateMsgReceiptsTimetag = function (timetag) {
  return this.updateTimetag('msgReceipts', timetag);
};

DBFn.updateDonnopTimetag = function (timetag) {
  return this.updateTimetag('donnop', timetag);
};

DBFn.updateDeleteMsgTimetag = function (timetag) {
  return this.updateTimetag('deleteMsg', timetag);
};

DBFn.updateSessionAck = function (timetag) {
  return this.updateTimetag('sessionAck', timetag);
};

DBFn.deleteTimetag = function (name) {
  return this.remove('timetag', name);
};

DBFn.deleteTeamMemberTimetag = function (teamId) {
  return this.deleteTimetag('team-' + teamId);
};
DBFn.deleteSuperTeamMemberTimetag = function (teamId) {
  return this.deleteTimetag('superTeam-' + teamId);
};

/***/ }),

/***/ "./src/im/db/user.js":
/*!***************************!*\
  !*** ./src/im/db/user.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DBFn = __webpack_require__(/*! ./index */ "./src/im/db/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var TableUser = 'user';

/**
 * 处理我的信息
 * @private
 * @param  {Boolean} shouldUpdateTimetag 是否更新时间戳
 */
DBFn.mergeMyInfo = function (user, shouldUpdateTimetag) {
  var self = this;
  return self.put(TableUser, user).then(function () {
    if (shouldUpdateTimetag) {
      return self.updateMyInfoTimetag(user.updateTime);
    }
    return user;
  });
};

DBFn.mergeFriendUsers = function (users, timetag) {
  var self = this;
  return self.putUsers(users).then(function () {
    self.updateFriendUserTimetag(timetag);
  });
};

DBFn.putUsers = function (users) {
  return this.put(TableUser, users);
};

DBFn.putUser = function (user) {
  return this.put(TableUser, user);
};

DBFn.updateUser = function (user) {
  var self = this;
  // 先复制, 不受外界干扰
  user = util.copy(user);
  var account = user.account;
  return this.getOne(TableUser, null, account, {
    modifyObj: user
  }).then(function (record) {
    if (record) {
      self.logger.log('db::updateUser: ' + account, user);
    } else {
      self.logger.warn('db::updateUser: no record ' + account);
    }
    return record;
  });
};

// 如果是好友, 更新其用户信息
DBFn.putUsersIfIsFriend = function (users) {
  var self = this;
  var waitArray = [];
  var updateArray = [];
  var promise;
  users.forEach(function (user) {
    promise = self.getFriend(user.account).then(function (record) {
      if (!!record) {
        promise = self.putUser(user);
        updateArray.push(promise);
      }
      return record;
    });
    waitArray.push(promise);
  });
  return Promise.all(waitArray).then(function () {
    return Promise.all(updateArray).then(function (updateResult) {
      return updateResult;
    });
  });
};

DBFn.deleteUser = function (account) {
  return this.remove(TableUser, account);
};

DBFn.getUser = function (account) {
  return this.getOne(TableUser, null, account);
};

DBFn.getUsers = function (accounts) {
  function filter(user) {
    return accounts.indexOf(user.account) !== -1;
  }
  return this.getAll(TableUser, {
    filter: filter
  });
};

DBFn.getAllUsers = function () {
  return this.getAll(TableUser);
};

/***/ }),

/***/ "./src/im/model/ImageOp.js":
/*!*********************************!*\
  !*** ./src/im/model/ImageOp.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * 操作类型
 * @memberOf ImageOp
 * @name type
 * @readOnly
 * @enum {String}
 */
var typeMap = {
    // 去除图片元数据
    stripmeta: 0,
    // 修改图片类型
    // type: 1,
    // 高斯模糊
    blur: 2,
    // 修改图片质量
    quality: 3,
    // 对图片进行剪裁
    crop: 4,
    // 对图片进行旋转
    rotate: 5,
    // 基于像素对图片进行缩略
    // pixel: 6,
    // 基于长宽的图片缩略
    thumbnail: 7,
    // 图片水印
    // watermark: 8,
    // 图片interlace
    interlace: 9
    // tmp: 10
};
var typeReverseMap = {
    0: 'stripmeta',
    1: 'type',
    2: 'blur',
    3: 'quality',
    4: 'crop',
    5: 'rotate',
    6: 'pixel',
    7: 'thumbnail',
    8: 'watermark',
    9: 'interlace',
    10: 'tmp'
};

function ImageOp(options) {
    util.verifyOptions(options, 'type', 'image::ImageOp');
    util.verifyParamValid('type', options.type, ImageOp.validTypes, 'image::ImageOp');
    util.merge(this, options);
    this.type = typeMap[options.type];
}

ImageOp.validTypes = Object.keys(typeMap);

ImageOp.reverse = function (imageOp) {
    var obj = util.copy(imageOp);
    obj.type = typeReverseMap[obj.type];
    return obj;
};

ImageOp.reverseImageOps = function (imageOps) {
    return imageOps.map(function (imageOp) {
        return ImageOp.reverse(imageOp);
    });
};

module.exports = ImageOp;

/***/ }),

/***/ "./src/im/model/avSignal.js":
/*!**********************************!*\
  !*** ./src/im/model/avSignal.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 发起会话的类型
var AvSignalEventType = {
  1: 'ROOM_CLOSE',
  2: 'ROOM_JOIN',
  3: 'INVITE',
  4: 'CANCEL_INVITE',
  5: 'REJECT',
  6: 'ACCEPT',
  7: 'LEAVE',
  8: 'CONTROL'
};

var AvSignalMemberInfo = {
  1: 'accid',
  2: 'uid',
  3: 'createTime',
  4: 'expireTime',
  5: 'web_uid'
};

var AvSignalErrorMsg = {
  10404: 'ROOM_NOT_EXISTS', // 房间不存在
  10405: 'ROOM_HAS_EXISTS', // 房间已存在
  10406: 'ROOM_MEMBER_NOT_EXISTS', // 不在房间内
  10407: 'ROOM_MEMBER_HAS_EXISTS', // 已经在房间内
  10408: 'INVITE_NOT_EXISTS', // 邀请不存在或已过期
  10409: 'INVITE_HAS_REJECT', // 邀请已经拒绝
  10410: 'INVITE_HAS_ACCEPT', // 邀请已经接受了
  10201: 'PEER_NIM_OFFLINE', // 对方云信不在线
  10202: 'PEER_PUSH_OFFLINE', // 对方推送亦不可达
  10419: 'ROOM_MEMBER_EXCEED', // 房间人数超限
  10420: 'ROOM_MEMBER_HAS_EXISTS_OTHER_CLIENT', // 已经在房间内（自己的其他端）
  10417: 'UID_CONFLICT' // uid冲突
};

var parseAvSignalType = function parseAvSignalType(type) {
  return AvSignalEventType[type] || type;
};

var parseAvSignalMember = function parseAvSignalMember(member) {
  var memberParsed = {};
  Object.keys(member).forEach(function (key) {
    memberParsed[AvSignalMemberInfo[key]] = member[key];
  });
  return memberParsed;
};

var parseAvSignalError = function parseAvSignalError(error) {
  error.message = AvSignalErrorMsg[error.code] || error.message || error;
  return error;
};

module.exports = {
  parseAvSignalType: parseAvSignalType,
  parseAvSignalMember: parseAvSignalMember,
  parseAvSignalError: parseAvSignalError
};

/***/ }),

/***/ "./src/im/model/friend.js":
/*!********************************!*\
  !*** ./src/im/model/friend.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;

/**
 * 好友请求类型
 *
 * - `'addFriend'` (直接加为好友)
 * - `'applyFriend'` (申请加为好友)
 * - `'passFriendApply'` (通过好友申请)
 * - `'rejectFriendApply'` (拒绝好友申请)
 *
 * @memberOf Friend
 * @name requestType
 * @readOnly
 * @enum {String}
 */
var requestTypeMap = {
  addFriend: 1,
  applyFriend: 2,
  passFriendApply: 3,
  rejectFriendApply: 4
};
var requestTypeReverseMap = {
  1: 'addFriend',
  2: 'applyFriend',
  3: 'passFriendApply',
  4: 'rejectFriendApply'

  /**
   * @constructor
   *
   * @property {String}   account     账号
   * @property {String}   alias       昵称
   * @property {String}   custom      扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
   * @property {Number}   createTime  成为好友的时间
   * @property {Number}   updateTime  更新时间
   */
};function Friend(options) {
  util.verifyOptions(options, 'account', 'friend::Friend');
  util.verifyParamAtLeastPresentOne(options, 'alias custom', 'friend::Friend');
  this.account = options.account;
  if (notundef(options.alias)) {
    this.alias = options.alias;
  }
  if (notundef(options.custom)) {
    this.custom = options.custom;
  }
}

Friend.reverse = function (friend) {
  var obj = util.filterObj(friend, 'account alias custom createTime updateTime serverex');
  if (notundef(friend.flag)) {
    obj.valid = friend.flag === '1';
  }
  if (notundef(obj.createTime)) {
    obj.createTime = +obj.createTime;
  }
  if (notundef(obj.updateTime)) {
    obj.updateTime = +obj.updateTime;
  }
  return obj;
};

Friend.validTypes = function () {
  return Object.keys(requestTypeMap);
};

Friend.getByteFromType = function (type) {
  return requestTypeMap[type];
};

Friend.getTypeFromByte = function (typeInByte) {
  return requestTypeReverseMap[typeInByte];
};

Friend.assembleFriend = function (account) {
  var timetag = +new Date();
  return {
    account: account,
    alias: '',
    createTime: timetag,
    custom: '',
    updateTime: timetag,
    valid: true
  };
};

module.exports = Friend;

/***/ }),

/***/ "./src/im/model/loginPort.js":
/*!***********************************!*\
  !*** ./src/im/model/loginPort.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _device = __webpack_require__(/*! utiljs/device */ "./src/util/device.js");

var _device2 = _interopRequireDefault(_device);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var typeReverseMap = _device2.default.clientTypeMap;

/**
 * 云信允许多端同时登录, LoginPort代表一个登录端
 *
 * @constructor
 * @property {String}   type            登录的{@link LoginPort.type|设备类型}
 * @property {String}   os              登录设备的操作系统
 * @property {String}   mac             登录设备的 mac 地址
 * @property {String}   deviceId        登录设备ID, uuid
 * @property {String}   account         登录的帐号
 * @property {Number}   connectionId    登录设备的连接号
 * @property {String}   ip              登录的服务器 IP
 * @property {Number}   time            登录时间
 * @property {Boolean}  online          是否在线
 */
/**
 * 设备类型
 *
 * - `'Android'` (安卓)
 * - `'iOS'` (苹果)
 * - `'PC'` (桌面)
 * - `'WindowsPhone'` (微软)
 * - `'Web'` (浏览器)
 *
 * @memberOf LoginPort
 * @name type
 * @readOnly
 * @enum {String}
 */

function LoginPort() {}

LoginPort.reverse = function (loginPort) {
  var obj = loginPort;
  obj.type = typeReverseMap[obj.type];
  return obj;
};

LoginPort.reverseType = function (type) {
  return typeReverseMap[type] || type;
};

module.exports = LoginPort;

/***/ }),

/***/ "./src/im/model/message/base/message.js":
/*!**********************************************!*\
  !*** ./src/im/model/message/base/message.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var device = __webpack_require__(/*! utiljs/device */ "./src/util/device.js");

function Message() {}

Message.typeMap = {
  text: 0,
  image: 1,
  audio: 2,
  video: 3,
  geo: 4,
  notification: 5,
  file: 6,
  tip: 10,
  robot: 11, // robotIn
  // robotOut: 12,
  custom: 100
};

var typeReverseMap = Message.typeReverseMap = {
  0: 'text',
  1: 'image',
  2: 'audio',
  3: 'video',
  4: 'geo',
  5: 'notification',
  6: 'file',
  10: 'tip',
  11: 'robot', // robotIn
  // 12: 'robotOut',
  100: 'custom'
};

Message.validTypes = Object.keys(Message.typeMap);

Message.setFlow = function (msg, account) {
  // 自己发的就算自己发的
  var out = account === msg.from;
  // 如果同时也是自己收的, 那么比较设备号, 设备号一样的话就算自己发的
  if (out && account === msg.to) {
    out = device.deviceId === msg.fromDeviceId;
  }
  msg.flow = out ? 'out' : 'in';
  if (msg.type === 'robot') {
    if (msg.content && msg.content.msgOut) {
      msg.flow = 'in';
    }
  }
};

Message.getType = function (msg) {
  var type = msg.type;
  return typeReverseMap[type] || type;
};

module.exports = Message;

/***/ }),

/***/ "./src/im/model/message/im/audio.js":
/*!******************************************!*\
  !*** ./src/im/model/message/im/audio.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FileMessage = __webpack_require__(/*! ./file */ "./src/im/model/message/im/file.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

function AudioMessage() {}
AudioMessage.prototype = Object.create(FileMessage.prototype);

AudioMessage.verifyFile = function (file, callFunc) {
    util.verifyOptions(file, 'dur', true, 'file.', callFunc);
};

module.exports = AudioMessage;

/***/ }),

/***/ "./src/im/model/message/im/custom.js":
/*!*******************************************!*\
  !*** ./src/im/model/message/im/custom.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * 自定义消息
 * @private
 */
function CustomMessage(options) {
    util.verifyOptions(options, 'content', 'msg::CustomMessage');
    options.type = 'custom';
    Message.call(this, options);
    this.attach = options.content;
}

CustomMessage.prototype = Object.create(Message.prototype);

CustomMessage.reverse = function (msg) {
    var obj = Message.reverse(msg);
    obj.content = msg.attach;
    return obj;
};

module.exports = CustomMessage;

/***/ }),

/***/ "./src/im/model/message/im/file.js":
/*!*****************************************!*\
  !*** ./src/im/model/message/im/file.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _url = __webpack_require__(/*! utiljs/url */ "./src/util/url.js");

var Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var CONFIG = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");


function FileMessage(options) {
  if (util.notundef(options.type)) {
    util.verifyFileType(options.type, 'msg::FileMessage');
  } else {
    options.type = 'file';
  }
  util.verifyOptions(options, 'file', 'msg::FileMessage');
  util.verifyOptions(options.file, 'url ext size', true, 'file.', 'msg::FileMessage');
  switch (options.type) {
    case 'image':
      ImageMessage.verifyFile(options.file, 'msg::FileMessage');
      break;
    case 'audio':
      AudioMessage.verifyFile(options.file, 'msg::FileMessage');
      break;
    case 'video':
      VideoMessage.verifyFile(options.file, 'msg::FileMessage');
      break;
    default:
      break;
  }
  Message.call(this, options);
  this.attach = JSON.stringify(options.file);
}

FileMessage.prototype = Object.create(Message.prototype);

FileMessage.reverse = function (msg) {
  var obj = Message.reverse(msg);
  msg.attach = msg.attach ? '' + msg.attach : '';
  obj.file = msg.attach ? JSON.parse(msg.attach) : {};
  obj.file.url = (0, _url.genPrivateUrl)(obj.file.url);
  // 如果是音频, 转成mp3
  if (obj.type === 'audio' && !obj.file.mp3Url) {
    obj.file.mp3Url = obj.file.url + (~obj.file.url.indexOf('?') ? '&' : '?') + 'audioTrans&type=mp3';
  }

  if (CONFIG.httpsEnabled && obj.file.url.indexOf('https://') !== 0) {
    obj.file.url = obj.file.url.replace('http', 'https');
  }
  return obj;
};

module.exports = FileMessage;
var ImageMessage = __webpack_require__(/*! ./image */ "./src/im/model/message/im/image.js");
var AudioMessage = __webpack_require__(/*! ./audio */ "./src/im/model/message/im/audio.js");
var VideoMessage = __webpack_require__(/*! ./video */ "./src/im/model/message/im/video.js");

/***/ }),

/***/ "./src/im/model/message/im/geo.js":
/*!****************************************!*\
  !*** ./src/im/model/message/im/geo.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

function GeoMessage(options) {
    options.type = 'geo';
    util.verifyOptions(options, 'geo', 'msg::GeoMessage');
    util.verifyOptions(options.geo, 'lng lat title', true, 'geo.', 'msg::GeoMessage');
    util.verifyParamType('geo.lng', options.geo.lng, 'number', 'msg::GeoMessage');
    util.verifyParamType('geo.lat', options.geo.lat, 'number', 'msg::GeoMessage');
    util.verifyParamType('geo.title', options.geo.title, 'string', 'msg::GeoMessage');
    Message.call(this, options);
    this.attach = JSON.stringify(options.geo);
}

GeoMessage.prototype = Object.create(Message.prototype);

GeoMessage.reverse = function (msg) {
    var obj = Message.reverse(msg);
    msg.attach = !!msg.attach ? '' + msg.attach : '';
    obj.geo = !!msg.attach ? JSON.parse(msg.attach) : {};
    return obj;
};

module.exports = GeoMessage;

/***/ }),

/***/ "./src/im/model/message/im/image.js":
/*!******************************************!*\
  !*** ./src/im/model/message/im/image.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var FileMessage = __webpack_require__(/*! ./file */ "./src/im/model/message/im/file.js");

function ImageMessage() {}
ImageMessage.prototype = Object.create(FileMessage.prototype);

ImageMessage.verifyFile = function (file, callFunc) {
    util.verifyOptions(file, 'w h', true, 'file.', callFunc);
};

module.exports = ImageMessage;

/***/ }),

/***/ "./src/im/model/message/im/index.js":
/*!******************************************!*\
  !*** ./src/im/model/message/im/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

var Index = function Index(options) {
  this.account = options.account;
};

var pro = Index.prototype;

var Message = pro.Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var TextMessage = pro.TextMessage = __webpack_require__(/*! ./text */ "./src/im/model/message/im/text.js");
var FileMessage = pro.FileMessage = __webpack_require__(/*! ./file */ "./src/im/model/message/im/file.js");
var GeoMessage = pro.GeoMessage = __webpack_require__(/*! ./geo */ "./src/im/model/message/im/geo.js");
var NotificationMessage = pro.NotificationMessage = __webpack_require__(/*! ./notification */ "./src/im/model/message/im/notification.js");
var CustomMessage = pro.CustomMessage = __webpack_require__(/*! ./custom */ "./src/im/model/message/im/custom.js");
var TipMessage = pro.TipMessage = __webpack_require__(/*! ./tip */ "./src/im/model/message/im/tip.js");
var RobotMessage = pro.RobotMessage = __webpack_require__(/*! ./robot */ "./src/im/model/message/im/robot.js");

pro.validScenes = Message.validScenes;
pro.validTypes = Message.validTypes;

pro.reverse = function (msg) {
  var obj;
  var type = Message.getType(msg);
  switch (type) {
    case 'text':
      obj = TextMessage.reverse(msg);
      break;
    case 'image':
    case 'audio':
    case 'video':
    case 'file':
      obj = FileMessage.reverse(msg);
      break;
    case 'geo':
      obj = GeoMessage.reverse(msg);
      break;
    case 'notification':
      obj = NotificationMessage.reverse(msg);
      break;
    case 'custom':
      obj = CustomMessage.reverse(msg);
      break;
    case 'tip':
      obj = TipMessage.reverse(msg);
      break;
    case 'robot':
      // robotIn
      obj = RobotMessage.reverse(msg);
      break;
    // case 'robotOut':
    //   obj = RobotMessage.reverse(msg)
    //   break
    default:
      obj = Message.reverse(msg);
      break;
  }
  Message.setExtra(obj, this.account);
  return obj;
};

pro.reverseMsgs = function (msgs, options) {
  var self = this;
  var modifyObj;
  var mapper;
  return msgs.map(function (msg) {
    msg = self.reverse(msg);
    if (options) {
      modifyObj = options.modifyObj;
      if (modifyObj) {
        msg = util.merge(msg, modifyObj);
      }
      mapper = options.mapper;
      if (util.isFunction(mapper)) {
        msg = mapper(msg);
      }
    }
    return msg;
  });
};

module.exports = Index;

/***/ }),

/***/ "./src/im/model/message/im/message.js":
/*!********************************************!*\
  !*** ./src/im/model/message/im/message.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var notundef = util.notundef;
var exist = util.exist;
var loginPort = __webpack_require__(/*! im/model/loginPort */ "./src/im/model/loginPort.js");
var BaseMessage = __webpack_require__(/*! ../base/message */ "./src/im/model/message/base/message.js");

var ApnsAccountsAll = '#%@all@%#';

/**
 * 场景
 *
 * - `'p2p'` (单人聊天)
 * - `'team'` (群聊)
 * - `'superTeam'` (超大群聊天)
 *
 * @memberOf IMMessage
 * @name scene
 * @readOnly
 * @enum {String}
 */
var sceneMap = {
  // 单人聊天
  p2p: 0,
  // 群聊
  team: 1,
  // 超大群
  superTeam: 5
};
var sceneReverseMap = {
  0: 'p2p',
  1: 'team',
  5: 'superTeam'
};
var validScenes = Object.keys(sceneMap);

/**
 * 消息类型
 *
 * - `'text'` (文本)
 * - `'image'` (图片)
 * - `'audio'` (音频)
 * - `'video'` (视频)
 * - `'file'` (文件)
 * - `'geo'` (地理位置)
 * - `'custom'` (自定义消息)
 * - `'tip'` (提醒消息)
 * - `'robot'` (机器人消息)
 *     - 提醒消息用于会话内的状态提醒，如进入会话时出现的欢迎消息，或者会话命中敏感词后的提示消息等等.
 * - `'notification'` (群通知消息)
 *     - 某些群操作后所有群成员会收到一条相应的群通知消息, 详细介绍请参考{@link IMMessage.attach|群通知消息的类型}
 *     - 此类消息不会计入未读数
 *
 * @memberOf IMMessage
 * @name type
 * @readOnly
 * @enum {String}
 */
var typeMap = BaseMessage.typeMap;
var validTypes = BaseMessage.validTypes;

/**
 * IM 消息
 *
 * @constructor
 * @name IMMessage
 * @property {String}   scene           {@link IMMessage.scene|场景}
 * @property {String}   from            消息发送方, 帐号
 * @property {String}   fromNick        消息发送方的昵称
 * @property {String}   fromClientType  发送方的{@link LoginPort.type|设备类型}
 * @property {String}   fromDeviceId    发送端设备id
 * @property {String}   to              消息接收方, 帐号或群id
 * @property {Number}   time            时间戳
 * @property {Number}   userUpdateTime  发送方信息更新时间
 * @property {String}   type            {@link IMMessage.type|消息类型}
 * @property {String}   sessionId       消息所属的{@link Session|会话}的ID
 * @property {String}   target          聊天对象, 账号或者群id
 * @property {String}   flow            消息的流向
 * - 'in'表示此消息是收到的消息
 * - 'out'表示此消息是发出的消息
 * @property {String}   status          消息发送状态
 * - `'sending'` 发送中
 * - `'success'` 发送成功
 * - `'fail'` 发送失败
 * @property {String}   [text]          文本消息的文本内容, 请参考{@link NIM#sendText|发送文本消息}
 * @property {Object}   [file]          文件消息的文件对象, 具体字段请参考{@link Image|图片对象}、{@link Audio|音频对象}、{@link Video|视频对象}和{@link File|文件对象}, 请参考{@link NIM#sendFile|发送文件消息}
 * @property {Object}   [geo]           地理位置消息的{@link Geo|地理位置对象}, 请参考{@link NIM#sendGeo|发送地理位置消息}
 * @property {String} [tip] 提醒消息的内容, 请参考{@link NIM#sendTipMsg|发送提醒消息}
 * @property {String}   [content]       自定义消息的消息内容, 开发者可以自行扩展, 建议封装成JSON格式字符串, 请参考{@link NIM#sendCustomMsg|发送自定义消息}
 * @property {Object}   [attach]        {@link IMMessage.type|群通知消息}的附加信息,
 *                                      参考{@link IMMessage.attach|群通知消息的类型}来查看不同类型的群通知消息对应的附加信息
 * @property {String}   idClient        SDK生成的消息id, 在发送消息之后会返回给开发者, 开发者可以在发送消息的结果回调里面根据这个ID来判断相应消息的发送状态, 到底是发送成功了还是发送失败了, 然后根据此状态来更新页面的UI。如果发送失败, 那么可以重新发送此消息
 * @property {String}   [idServer]      服务器用于区分消息用的ID, 用于{@link NIM#getHistoryMsgs|获取历史消息}和{@link NIM#searchHistoryMsgs|获取包含关键词的历史消息}, 此字段可能没有, 所以开发者应该使用`idClient`来唯一标识消息
 * @property {Boolean}  isMuted         该消息在接收方是否应该被静音
 * @property {Boolean}  resend          是否是重发的消息
 * @property {String}   [custom]        扩展字段
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @property {String}   [pushContent]   自定义推送文案
 * @property {String}   [pushPayload]   自定义的推送属性
 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
 * @property {Object}   [apns]          特殊推送选项, 只在群会话中使用
 * @property {String[]} [apns.accounts] 需要特殊推送的账号列表, 此字段不存在的话表示推送给当前会话内的所有用户
 * @property {String}   [apns.content]  需要特殊推送的文案
 * @property {String}   [apns.forcePush] 是否强制推送, true 表示即使推送列表中的用户屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
 * @property {String}   [localCustom]   本地自定义扩展字段
 * - 在{@link support.db|支持数据库}时可以调用{@Link NIM#updateLocalMsg|更新本地消息}来更新此字段, 此字段只会被更新到本地数据库, 不会被更新到服务器上
 * @property {Boolean}  isHistoryable   是否存储云端历史
 * @property {Boolean}  isRoamingable   是否支持漫游
 * @property {Boolean}  isSyncable      是否支持发送者多端同步
 * @property {Boolean}  cc              是否支持抄送
 * @property {Boolean}  isPushable      是否需要推送
 * @property {Boolean}  isOfflinable    是否要存离线
 * @property {Boolean}  isUnreadable    是否计入消息未读数
 * @property {Boolean}  isReplyMsg      是否为应答消息（用于机器人等类似场景等应答消息内容）
 * @property {Integer}  tempTeamMemberCount  群已读消息快照大小（即消息发送时的群人数-1）
 * @property {Boolean}  needPushNick    是否需要推送昵称
 * @property {Boolean}  isLocal         是否是本地消息, 请查阅{@link NIM#sendText|发送文本消息}
 */
function Message(options) {
  util.verifyOptions(options, 'scene to type', 'msg::Message');
  util.verifyParamValid('scene', options.scene, validScenes, 'msg::Message');
  var self = this;
  self.scene = sceneMap[options.scene];
  self.to = '' + options.to;
  self.type = typeMap[options.type];
  self.resend = options.resend ? 1 : 0;
  // 如果不是重发, 那么生成idClient；如果是重发, 那么由开发者传入idClient
  if (!options.resend) {
    self.idClient = util.guid();
  } else {
    util.verifyOptions(options, 'idClient', 'msg::Message');
    self.idClient = options.idClient;
  }
  // 文本字段
  if (notundef(options.text)) {
    self.body = '' + options.text;
  }
  if (notundef(options.custom)) {
    if ((0, _typeof3.default)(options.custom) === 'object') {
      self.custom = JSON.stringify(options.custom);
    } else {
      self.custom = '' + options.custom;
    }
  }
  if (notundef(options.body)) {
    self.body = '' + options.body;
  }
  if (notundef(options.pushContent)) {
    self.pushContent = '' + options.pushContent;
  }
  if (notundef(options.pushPayload)) {
    self.pushPayload = '' + options.pushPayload;
  }
  // 特殊推送选项
  var apns = options.apns;
  if (notundef(apns) && options.scene === 'team') {
    // 需要特殊推送的账号列表
    var apnsAccounts = apns.accounts;
    if (notundef(apnsAccounts)) {
      util.verifyParamType('apns.accounts', apnsAccounts, 'array', 'msg::Message');
    }
    self.apnsAccounts = apnsAccounts ? JSON.stringify(apnsAccounts) : ApnsAccountsAll;
    // 需要特殊推送的文案
    self.apnsContent = apns.content || options.pushContent || '';
    // 是否强制推送
    util.verifyBooleanWithDefault(apns, 'forcePush', true, 'options.apns', 'msg::Message');
    self.apnsForcePush = apns.forcePush ? 1 : 0;
  }
  // 开关
  if (notundef(options.isHistoryable)) {
    self.isHistoryable = options.isHistoryable ? 1 : 0;
  }
  if (notundef(options.isRoamingable)) {
    self.isRoamingable = options.isRoamingable ? 1 : 0;
  }
  if (notundef(options.isSyncable)) {
    self.isSyncable = options.isSyncable ? 1 : 0;
  }
  if (notundef(options.cc)) {
    self.cc = options.cc ? 1 : 0;
  }
  if (notundef(options.isPushable)) {
    self.isPushable = options.isPushable ? 1 : 0;
  }
  if (notundef(options.isOfflinable)) {
    self.isOfflinable = options.isOfflinable ? 1 : 0;
  }
  if (notundef(options.isUnreadable)) {
    self.isUnreadable = options.isUnreadable ? 1 : 0;
  }
  if (notundef(options.needPushNick)) {
    self.needPushNick = options.needPushNick ? 1 : 0;
  }
  if (notundef(options.needMsgReceipt)) {
    self.needMsgReceipt = options.needMsgReceipt ? 1 : 0;
  }
  if (notundef(options.yidunEnable)) {
    self.yidunEnable = options.yidunEnable ? 1 : 0;
  }
  if (notundef(options.antiSpamUsingYidun)) {
    self.antiSpamUsingYidun = options.antiSpamUsingYidun ? 1 : 0;
  }
  if (notundef(options.clientAntiSpam)) {
    self.clientAntiSpam = options.clientAntiSpam ? 1 : 0;
  }
  if (notundef(options.antiSpamContent)) {
    if ((0, _typeof3.default)(options.antiSpamContent) === 'object') {
      self.antiSpamContent = JSON.stringify(options.antiSpamContent);
    } else {
      self.antiSpamContent = '' + options.antiSpamContent;
    }
  }
  if (notundef(options.antiSpamBusinessId)) {
    if ((0, _typeof3.default)(options.antiSpamBusinessId) === 'object') {
      self.antiSpamBusinessId = JSON.stringify(options.antiSpamBusinessId);
    } else {
      self.antiSpamBusinessId = '' + options.antiSpamBusinessId;
    }
  }
  // self.filterClientAntispam()
}

util.merge(Message.prototype, BaseMessage.prototype);

Message.prototype.getScene = function () {
  return sceneReverseMap[this.scene];
};

// Message.getScene = function (msg) {
//   var scene = msg.scene
//   return sceneReverseMap[scene] || scene
// }

Message.getType = BaseMessage.getType;

Message.reverse = function (msg) {
  var scene = sceneReverseMap[msg.scene];
  var obj = {
    scene: scene || msg.scene,
    from: msg.from,
    fromNick: msg.fromNick,
    fromClientType: loginPort.reverseType(msg.fromClientType),
    fromDeviceId: msg.fromDeviceId,
    // to 为第三方账号或者群ID, 强制转为字符串
    to: '' + msg.to,
    time: +msg.time,
    type: Message.getType(msg),
    // 文本字段
    text: exist(msg.body) ? msg.body : '',
    isHistoryable: undef(msg.isHistoryable) || +msg.isHistoryable === 1,
    isRoamingable: undef(msg.isRoamingable) || +msg.isRoamingable === 1,
    isSyncable: undef(msg.isSyncable) || +msg.isSyncable === 1,
    cc: undef(msg.cc) || +msg.cc === 1,
    isPushable: undef(msg.isPushable) || +msg.isPushable === 1,
    isOfflinable: undef(msg.isOfflinable) || +msg.isOfflinable === 1,
    isUnreadable: undef(msg.isUnreadable) || +msg.isUnreadable === 1,
    isReplyMsg: undef(msg.isReplyMsg) || +msg.isReplyMsg === 1,
    needPushNick: undef(msg.needPushNick) || +msg.needPushNick === 1,
    needMsgReceipt: +msg.needMsgReceipt === 1,
    isLocal: false
    // 只有返回这个字段时才显示，含义：发送此条消息时，发送方`'from'`是否在接收方`'to'`的黑名单列表中
  };if (msg.isInBlackList) {
    obj.isInBlackList = +msg.isInBlackList === 1;
  }
  // 只有消息接收者才用处理字段 isMuted
  if (notundef(msg.isMuted)) {
    obj.isMuted = +msg.isMuted === 1;
  }
  if (notundef(msg.resend)) {
    obj.resend = +msg.resend === 1;
  }
  if (notundef(msg.idClient)) {
    obj.idClient = msg.idClient;
  }
  // 漫游消息和离线消息没有 idServer
  if (notundef(msg.idServer)) {
    obj.idServer = '' + msg.idServer;
  }
  if (notundef(msg.userUpdateTime)) {
    obj.userUpdateTime = +msg.userUpdateTime;
  }
  if (notundef(msg.custom)) {
    obj.custom = msg.custom;
  }
  if (notundef(msg.pushContent)) {
    obj.pushContent = msg.pushContent;
  }
  if (notundef(msg.pushPayload)) {
    obj.pushPayload = msg.pushPayload;
  }
  if (notundef(msg.tempTeamMemberCount)) {
    obj.tempTeamMemberCount = +msg.tempTeamMemberCount;
  }
  // 特殊推送选项
  if (notundef(msg.apnsAccounts)) {
    obj.apns = {};
    if (msg.apnsAccounts !== ApnsAccountsAll) {
      var accounts = msg.apnsAccounts;
      try {
        obj.apns.accounts = JSON.parse(accounts);
      } catch (error) {
        obj.apns.accounts = [];
      }
    }
    obj.apns.content = msg.apnsContent || '';
    obj.apns.forcePush = +msg.apnsForcePush === 1;
  }

  // SDK 自己加的属性
  obj.status = msg.status || 'success';
  if (notundef(msg.filter)) {
    obj.filter = msg.filter;
  }
  return obj;
};

Message.setExtra = function (obj, account) {
  obj.target = Message.getMsgTarget(obj, account);
  obj.sessionId = obj.scene + '-' + obj.target;
  BaseMessage.setFlow(obj, account);
};

// 获取聊天对象
Message.getMsgTarget = function (msg, account) {
  if (msg.scene === 'p2p') {
    return msg.to === account ? msg.from : msg.to;
  } else if (msg.scene === 'team' || msg.scene === 'superTeam') {
    return msg.to;
  }
};

// 根据 idClient 去重
Message.deduplication = function (msgs) {
  var set = {};
  var array = [];
  var idClient;
  msgs.forEach(function (msg) {
    idClient = msg.idClient;
    if (!set[idClient]) {
      set[idClient] = true;
      array.push(msg);
    }
  });
  return array;
};

// 按照时间正序排序, 但是不改变原数组, 并且返回新数组
Message.sortMsgs = function (msgs) {
  msgs = msgs.slice(0);
  util.sortObjArray(msgs, {
    sortPath: 'time'
  });
  return msgs;
};

/**
 * 获取数组中的最后一条消息（时间戳最大的）
 * @private
 * @param  {Object[]} msgs  消息数组
 * @return {Object}         最后一条消息
 */
Message.getLastMsg = function (msgs) {
  msgs = Message.sortMsgs(msgs);
  return msgs[msgs.length - 1];
};

Message.getLastNotIgnoredMsg = function (msgs) {
  msgs = Message.sortMsgs(msgs);
  var msg = null;
  for (var i = msgs.length - 1; i >= 0; i--) {
    msg = msgs[i];
    if (!msg.ignore) {
      return msg;
    }
  }
  return null;
};

Message.getMaxTimetag = function (msgs) {
  return Message.getLastMsg(msgs).time;
};

Message.validScenes = validScenes;
Message.validTypes = validTypes;

module.exports = Message;

/***/ }),

/***/ "./src/im/model/message/im/notification.js":
/*!*************************************************!*\
  !*** ./src/im/model/message/im/notification.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* exported notificationTypes */

var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var parser = __webpack_require__(/*! im/protocol/parser */ "./src/im/protocol/parser/index.js").IM;
var team = __webpack_require__(/*! im/model/team */ "./src/im/model/team.js");
var User = __webpack_require__(/*! im/model/user */ "./src/im/model/user.js");

/**
 * 群通知消息
 *
 * - 群通知消息是{@link IMMessage|消息}的一种, 请参考{@link IMMessage.type|消息类型}, 某些群操作后所有群成员会收到一条相应的群通知消息
 * - 群通知消息有一个字段`attach`包含了额外的信息, `attach`有一个字段`type`来标识群通知消息的类型
 *     - `'updateTeam'` (更新群)
 *         - {@link NIM#updateTeam|更新群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'updateTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为更新群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为被更新的{@link Team|群信息}。
 *     - `'addTeamMembers'` (拉人入群)
 *         - 普通群, {@link NIM#addTeamMembers|拉人入群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|``'addTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为拉人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的[群对象](#群对象), `attach`有一个字段`accounts`的值为被拉的人的帐号列表, `attach`有一个字段`members`的值为被拉的群成员列表。
 *         - 被邀请的群成员在有人说话后才能看到该{@link Team|群}, 而且会先收到一条类型为{@link IMMessage.attach|`'addTeamMembers'`}的{@link IMMessage.type|群通知消息}, 然后会收到其它{@link Message|群消息}。
 *     - `'removeTeamMembers'` (踢人出群)
 *         - {@link NIM#removeTeamMembers|踢人出群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'removeTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为踢人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`accounts`的值为被踢的人的帐号列表。
 *     - `'acceptTeamInvite'` (接受入群邀请)
 *         - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
 *             - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
 *             - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
 *     - `'passTeamApply'` (通过入群申请)
 *         - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
 *             - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
 *             - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
 *     - `'addTeamManagers'` (添加群管理员)
 *         - {@link NIM#addTeamManagers|添加群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'addTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为添加群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被加为管理员的帐号列表, `attach`有一个字段`members`的值为被加为管理员的群成员列表。
 *     - `'removeTeamManagers'` (移除群管理员)。
 *         - {@link NIM#removeTeamManagers|移除群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'removeTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为移除群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被移除的管理员的帐号列表, `attach`有一个字段`members`的值为被移除管理员的群成员列表。
 *     - `'leaveTeam'` (主动退群)
 *         - {@link NIM#leaveTeam|主动退群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'leaveTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为退群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}。
 *     - `'dismissTeam'` (解散群)
 *         - {@link NIM#dismissTeam|解散群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'dismissTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段为解散群的人的帐号, `to`字段的值为被对应的群ID。
 *     - `'transferTeam'` (转让群)
 *         - {@link NIM#transferTeam|转让群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'transferTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为转让群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为为新群主的帐号, `attach`有一个字段`members`的值为包含新旧群主的群成员列表。
 *     - `'updateTeamMute'` (更新群成员禁言状态)
 *         - {@link NIM#updateMuteStateInTeam|更新群成员禁言状态}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach|`'updateTeamMute'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为操作方, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为被禁言的帐号, `attach`有一个字段`members`的值为被禁言的群成员列表。
 *     - `'updateSuperTeam'` (更新超大群)
 *         - {@link NIM#updateSuperTeam|更新超大群}后, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'updateSuperTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为更新群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为被更新的{@link SuperTeam|超大群信息}。
 *     - `'addSuperTeamMembers'` (拉人入超大群)
 *         - 普通群, {@link NIM#addSuperTeamMembers|拉人入超大群}后, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'addSuperTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为拉人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link SuperTeam|超大群对象}, `attach`有一个字段`accounts`的值为被拉的人的帐号列表, `attach`有一个字段`members`的值为被拉的群成员列表。
 *         - 被邀请的群成员在有人说话后才能看到该{@link SuperTeam|超大群}, 而且会先收到一条类型为{@link IMMessage.attach|`'addSuperTeamMembers'`}的{@link IMMessage.type|群通知消息}, 然后会收到其它{@link Message|群消息}。
 *     - `'removeSuperTeamMembers'` (踢人出超大群)
 *         - {@link NIM#removeSuperTeamMembers|踢人出超大群}后, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'removeSuperTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为踢人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`accounts`的值为被踢的人的帐号列表。
 *     - `'leaveSuperTeam'` (主动退出超大群)
 *         - {@link NIM#leaveSuperTeam|主动退群}后, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'leaveSuperTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为退群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}。
 *     - `'dismissSuperTeam'` (解散超大群)
 *         - 解散超大群后, 所有{@link SuperTeamMember|超大群群成员}会收到一条类型为{@link IMMessage.attach|`'dismissSuperTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段为解散群的人的帐号, `to`字段的值为被对应的群ID。
 *     
 * - 如果`attach`有`account`或者`accounts`字段, 那么`attach`的字段`users`包含这些账号对应的用户名片
 * - 更新群昵称不会收到群通知消息, 所有其它在线的群成员会收到{@link NIM|初始化SDK}时传入的`onupdateteammember`回调或`onUpdateSuperTeamMember`回调, 请参考{@link NIM#updateInfoInSuperTeam|修改自己的超大群属性}、{@link NIM#updateInfoInTeam|修改自己的群属性}和{@link NIM#updateNickInTeam|修改别人的群昵称}
 *
 * @memberOf IMMessage
 * @name attach
 * @readOnly
 * @enum {String}
 */
var notificationTypes = {};

var notificationTypeReverseMap = {
    0: 'addTeamMembers',
    1: 'removeTeamMembers',
    2: 'leaveTeam',
    3: 'updateTeam',
    4: 'dismissTeam',
    5: 'passTeamApply',
    6: 'transferTeam',
    7: 'addTeamManagers',
    8: 'removeTeamManagers',
    9: 'acceptTeamInvite',
    10: 'updateTeamMute',
    101: 'netcallMiss',
    102: 'netcallBill',
    401: 'addSuperTeamMembers',
    402: 'removeSuperTeamMembers',
    403: 'leaveSuperTeam',
    404: 'updateSuperTeam',
    405: 'dismissSuperTeam'
};

// 群通知消息
function NotificationMessage() {}

NotificationMessage.prototype = Object.create(Message.prototype);

NotificationMessage.reverse = function (msg) {
    var obj = Message.reverse(msg);
    // 如果是通知, 那么可能会有附加信息, 如果有, 解析之
    msg.attach = !!msg.attach ? '' + msg.attach : '';
    if (!!msg.attach) {
        var attach = JSON.parse(msg.attach);
        obj.attach = {
            type: notificationTypeReverseMap[attach.id] || attach.id
        };
        if (notundef(attach.data)) {
            var data = attach.data;
            if (notundef(data.tinfo)) {
                obj.attach.team = team.reverse(parser.syncUnserialize(data.tinfo, 'team'), true);
            }
            if (notundef(data.ids)) {
                obj.attach.accounts = data.ids;
            }
            if (notundef(data.id)) {
                obj.attach.account = data.id;
            }
            if (notundef(data.uinfos)) {
                obj.attach.users = data.uinfos.map(function (uinfo) {
                    return User.reverse(parser.syncUnserialize(uinfo, 'user'));
                });
            }
            if (notundef(data.mute)) {
                obj.attach.mute = +data.mute === 1;
            }
            if (notundef(data.attach)) {
                obj.attach.custom = data.attach;
            }
            if (notundef(data.channel)) {
                obj.attach.channelId = data.channel;
            }
            if (notundef(data.calltype)) {
                // 音频通话或者视频通话
                obj.attach.netcallType = data.calltype;
            }
            if (notundef(data.duration)) {
                obj.attach.duration = data.duration;
            }
            if (notundef(data.time)) {
                obj.attach.time = data.time;
            }
            if (notundef(data.from)) {
                // 主叫方accid
                obj.attach.from = data.from;
            }
            if (notundef(data.ext)) {
                // 可能来自于发起通话时设置的
                obj.attach.ext = data.ext;
            }
            // 音视频话单详情调整 to 为被呼叫方
            if (obj.attach.accounts && obj.attach.accounts.length <= 2 && obj.from === obj.to) {
                obj.attach.accounts.some(function (account) {
                    if (account !== obj.to) {
                        obj.to = account;
                        return true;
                    }
                });
            }
        }
    } else {
        obj.attach = {};
    }
    return obj;
};

module.exports = NotificationMessage;

/***/ }),

/***/ "./src/im/model/message/im/robot.js":
/*!******************************************!*\
  !*** ./src/im/model/message/im/robot.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

var botType = {
  'welcome': '00',
  'text': '01',
  'link': '03'
};

var botReverseType = {
  '01': 'text',
  '02': 'image',
  '03': 'answer',
  '11': 'template'

  // attach 格式：
  // type	00/01/03	String	00欢迎消息 01 文本 03 模块跳转	N
  // content	文本	String	说话内容	type为01时，不允许为N
  // target	target	String	返回消息类型为BOT时出现的link元素类型block中的target	type为03时，不允许为N
  // params	params	String	返回消息类型为BOT时出现的link元素类型block中的params	Y

};function RobotMessage(options) {
  util.verifyOptions(options, 'content', 'msg::RobotMessage');
  // 如果没有填写robotAccid，则认为to为机器人
  if (util.undef(options.robotAccid)) {
    options.robotAccid = options.to;
  }
  var attach = options.content;
  switch (attach.type) {
    case 'welcome':
      if (util.undef(options.body)) {
        this.body = '欢迎消息';
      }
      break;
    case 'text':
      util.verifyOptions(attach, 'content', 'msg::RobotMessage');
      if (util.undef(options.body)) {
        this.body = attach.content;
      }
      break;
    case 'link':
      util.verifyOptions(attach, 'target', 'msg::RobotMessage');
      // util.verifyOptions(attach, 'params', 'msg::RobotMessage')
      break;
  }
  if (attach.type) {
    attach.type = botType[attach.type];
  }
  attach = {
    param: attach,
    robotAccid: options.robotAccid
  };
  this.attach = JSON.stringify(attach);
  options.type = 'robot';
  Message.call(this, options);
}

RobotMessage.prototype = Object.create(Message.prototype);

RobotMessage.reverse = function (msg) {
  var obj = Message.reverse(msg);
  if (obj.type === 'robot') {
    var content = JSON.parse(msg.attach);
    if (content.param) {
      content.param.type = botReverseType[content.param.type] || 'unknown';
    }
    if (content.robotMsg) {
      content = util.merge(content, content.robotMsg);
      var tempMsg = content.message;
      if (content.flag === 'bot') {
        content.message = tempMsg.map(function (item) {
          item.type = botReverseType[item.type] || 'unknown';
          return item;
        });
      } else if (content.flag === 'faq') {
        // ...
      }
      delete content.robotMsg;
    }
    obj.content = content;
  }
  // 重新生成一个idClient
  // obj.idClient = util.guid()
  return obj;
};

module.exports = RobotMessage;

/***/ }),

/***/ "./src/im/model/message/im/text.js":
/*!*****************************************!*\
  !*** ./src/im/model/message/im/text.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

function TextMessage(options) {
    util.verifyOptions(options, 'text', 'msg::TextMessage');
    options.type = 'text';
    Message.call(this, options);
}
TextMessage.prototype = Object.create(Message.prototype);

TextMessage.reverse = function (msg) {
    var obj = Message.reverse(msg);
    return obj;
};

module.exports = TextMessage;

/***/ }),

/***/ "./src/im/model/message/im/tip.js":
/*!****************************************!*\
  !*** ./src/im/model/message/im/tip.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Message = __webpack_require__(/*! ./message */ "./src/im/model/message/im/message.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * 提醒消息
 * @private
 */
function TipMessage(options) {
    util.verifyOptions(options, 'tip', 'msg::TipMessage');
    options.type = 'tip';
    Message.call(this, options);
    this.body = options.tip;
}

TipMessage.prototype = Object.create(Message.prototype);

TipMessage.reverse = function (msg) {
    var obj = Message.reverse(msg);
    obj.text = '';
    obj.tip = msg.body;
    if (msg.attach) {
        obj.attach = msg.attach;
    }
    return obj;
};

module.exports = TipMessage;

/***/ }),

/***/ "./src/im/model/message/im/video.js":
/*!******************************************!*\
  !*** ./src/im/model/message/im/video.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FileMessage = __webpack_require__(/*! ./file */ "./src/im/model/message/im/file.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

function VideoMessage() {}
VideoMessage.prototype = Object.create(FileMessage.prototype);

VideoMessage.verifyFile = function (file, callFunc) {
    util.verifyOptions(file, 'dur w h', true, 'file.', callFunc);
};

module.exports = VideoMessage;

/***/ }),

/***/ "./src/im/model/msgEvent.js":
/*!**********************************!*\
  !*** ./src/im/model/msgEvent.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * - 此模型为事件的发布与订阅信息
 * @private
 * @name MsgEventTag
 * @property {Integer} event_type(1),          //integer 事件类型，服务器保留1～99999
 * @property {Integer} event_value(2),        //integer 事件状态
 * @property {String} msgid_client(3),        //string 客户端生成的消息id
 * @property {String} config(4),              //string 用户自定义事件扩展属性，最长256字节
 * @property {Long} ttl(5),                 //long 事件有效期，单位：秒，时间范围：60s到7天
 * @property {Integer} broadcast_type(6),      //integer 事件广播类型：1:仅在线 2:在线和离线
 * @property {Integer} sync_self(7),            //integer 0:不同步给自己，1：同步给自己
 * @property {Integer} //服务器预留字段，客户端不填写
 * @property {Integer} ttl_type(8),           //integer TtlType枚举值
 * @property {Integer} durable(9),            //integer 是否需要持久化(可选字段)，默认为需要持久化,0:不需要持久化，1：需要持久化
 * @property {Long} event_time(10),          //long 事件发布的时间戳，服务器补充
 * @property {String} msgid_server(11),       //string, 服务端生成的消息id
 * @property {Integer} //服务器补充的事件发布人相关信息
 * @property {Long} appid(101),               //long 应用ID
 * @property {Long} publisher_uid(102),      //long 事件发布者的uid
 * @property {String} publisher_accid(103),    //string 事件发布者的accid
 * @property {Integer} client_type(105),        //integer 发送客户端类型(可选,客户端不填)
 * @property {String} consid(106),           //string 发送设备id(可选,客户端不填)
  }
*/
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");

function MsgEvent(options) {
  util.verifyOptions(options, 'type value', 'event::MsgEvent');
  util.verifyParamType('type', options.type, 'number', 'event::MsgEvent');
  // util.verifyParamMin('type', options.type, 100000, 'event::MsgEvent')
  util.verifyParamType('value', options.value, 'number', 'event::MsgEvent');
  this.type = options.type;
  this.value = options.value;
  this.idClient = util.guid();

  if (notundef(options.custom)) {
    // util.verifyArrayMax('custom', '' + options.custom, 256, 'event::MsgEvent')
    this.custom = '' + options.custom;
  }

  // 默认有效时间7天, 60 - 604800
  this.validTime = options.validTime || 604800;
  util.verifyParamType('validTime', this.validTime, 'number', 'event::MsgEvent');
  util.verifyParamMin('validTime', this.validTime, 60, 'event::MsgEvent');
  util.verifyParamMax('validTime', this.validTime, 3600 * 24 * 7, 'event::MsgEvent');

  if (notundef(options.broadcastType)) {
    util.verifyParamType('broadcastType', options.broadcastType, 'number', 'event::MsgEvent');
    if ([1, 2].indexOf(options.broadcastType) < 0) {
      throw new NIMError('参数错误"broadcastType":只能为1或2');
    }
    this.broadcastType = options.broadcastType;
  } else {
    this.broadcastType = 2;
  }
  if (notundef(options.sync)) {
    util.verifyParamType('sync', options.sync, 'boolean', 'event::MsgEvent');
    this.sync = options.sync;
  } else {
    this.sync = false;
  }
}

MsgEvent.prototype.assembleEvent = function () {
  return {
    type: this.type,
    value: this.value,
    idClient: this.idClient,
    custom: this.custom || '',
    validTime: this.validTime,
    broadcastType: this.broadcastType,
    sync: this.sync === true ? 1 : 0
  };
};

module.exports = MsgEvent;

/***/ }),

/***/ "./src/im/model/msgEventSubscribe.js":
/*!*******************************************!*\
  !*** ./src/im/model/msgEventSubscribe.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * - 此模型为事件的发布与订阅信息
 * @private 
 * @name MsgEventSubscribeTag
 * @property {Integer} event_type(1),      //integer 事件类型
 * @property {Long} ttl(2),             //long 订阅有效期，单位：秒，范围：60s到30天
 * @property {Integer} sync_event(3),      //integer 订阅后是否立即同步最新事件，1:同步，0:不同步
 * @property {Integer} //服务器内部填写
 * @property {Long} publisher_uid(101),   //long 被订阅人（事件发布人）的uid
 * @property {String} publisher_accid(102), //String 被订阅人（事件发布人）的accid
 * @property {Long} subscribe_uid(103),   //long 订阅人的uid
 * @property {String} subscribe_accid(104), //string 订阅人的accid
 * @property {Long} subscribe_time(105),  //long 订阅时间戳
    ;
 }
*/
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;

function MsgEventSubscribe(options) {
  util.verifyOptions(options, 'type', 'event::MsgEventSubscribe');
  util.verifyParamType('type', options.type, 'number', 'event::MsgEventSubscribe');
  if (util.findObjIndexInArray([1, 2, 3], options.type) < 0) {
    util.verifyParamMin('type', options.type, 100000, 'event::MsgEventSubscribe');
  }
  this.type = options.type;

  if (notundef(options.subscribeTime)) {
    util.verifyParamType('subscribeTime', options.subscribeTime, 'number', 'event::MsgEventSubscribe');
    util.verifyParamMin('subscribeTime', options.subscribeTime, 60, 'event::MsgEventSubscribe');
    util.verifyParamMax('subscribeTime', options.subscribeTime, 3600 * 24 * 30, 'event::MsgEventSubscribe');
    this.subscribeTime = options.subscribeTime;
  } else {
    this.subscribeTime = 3600 * 24 * 30;
  }
  if (notundef(options.sync)) {
    util.verifyParamType('sync', options.sync, 'boolean', 'event::MsgEventSubscribe');
    this.sync = options.sync;
  } else {
    this.sync = true;
  }
}

MsgEventSubscribe.prototype.assembleEvent = function (options) {
  return {
    type: this.type,
    subscribeTime: this.subscribeTime,
    sync: this.sync === true ? 1 : 0
  };
};

module.exports = MsgEventSubscribe;

/***/ }),

/***/ "./src/im/model/nimerror.js":
/*!**********************************!*\
  !*** ./src/im/model/nimerror.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 错误
 *
 * @constructor
 * @param {String} message  错误消息
 * @param {Number} code     错误码
 * @param {Object} event    错误事件
 * @param {String} event.callFunc    调用方法
 */
function NIMError(message, code) {
  var event = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var self = this;
  self.message = message || event.message || '';
  if ((typeof code === 'undefined' ? 'undefined' : (0, _typeof3.default)(code)) === 'object') {
    self.event = code;
    self.code = 'Other_Error';
  } else if (typeof code !== 'undefined') {
    self.code = code;
  }
  // self.time = new Date()
  self.timetag = +new Date();
  if (typeof event !== 'undefined') {
    self.event = event;
  }
  if (self.event) {
    self.callFunc = self.event.callFunc || null;
    delete self.event.callFunc;
  }
}

NIMError.prototype = Object.create(Error.prototype);
NIMError.prototype.name = 'NIMError';

/**
 * 错误码错误信息表
 *
 * @memberOf NIMError
 * @readOnly
 * @enum {String}
 */
var codeMap = {
  201: '客户端版本不对, 需升级sdk',
  302: '用户名或密码错误, 请检查appKey和token是否有效, account和token是否匹配',
  403: '非法操作或没有权限',
  404: '对象(用户/群/聊天室)不存在',
  405: '参数长度过长',
  408: '客户端请求超时',
  414: '参数错误',
  415: '服务不可用/没有聊天室服务器可分配',
  // http://doc.hz.netease.com/pages/viewpage.action?pageId=60393173
  416: '频率控制',
  417: '重复操作',
  422: '帐号被禁用',
  500: '服务器内部错误',
  501: '数据库操作失败',
  503: '服务器繁忙',
  508: '删除有效期过了',
  509: '已失效',
  7101: '被拉黑',
  801: '群人数达到上限',
  802: '没有权限',
  803: '群不存在或未发生变化',
  804: '用户不在群里面',
  805: '群类型不匹配',
  806: '创建群数量达到限制',
  807: '群成员状态不对',
  809: '已经在群里',
  811: '强推列表中帐号数量超限',
  812: '群被禁言',
  813: '因群数量限制，部分拉人成功',
  814: '禁止使用群组消息已读服务',
  815: '群管理员人数上限',
  997: '协议已失效',
  998: '解包错误',
  999: '打包错误',
  9102: '通道失效',
  9103: '已经在其他端接听/拒绝过这通电话',
  11001: '对方离线, 通话不可送达',
  13002: '聊天室状态异常',
  13003: '在黑名单中',
  13004: '在禁言名单中',
  13006: '聊天室处于整体禁言状态,只有管理员能发言',
  // 请确保flash版本号大于10
  Connect_Failed: '无法建立连接, 请确保能 ping/telnet 到云信服务器; 如果是IE8/9, 请确保项目部署在 HTTPS 环境下',
  Error_Internet_Disconnected: '网断了',
  Error_Connection_is_not_Established: '连接未建立',
  Error_Connection_Socket_State_not_Match: 'socket状态不对',
  Error_Timeout: '超时',
  Param_Error: '参数错误',
  No_File_Selected: '请选择文件',
  Wrong_File_Type: '文件类型错误',
  File_Too_Large: '文件过大',
  Cross_Origin_Iframe: '不能获取跨域Iframe的内容',
  Not_Support: '不支持',
  NO_DB: '无数据库',
  DB: '数据库错误',
  Still_In_Team: '还在群里',
  Session_Exist: '会话已存在',
  Session_Not_Exist: '会话不存在',
  Error_Unknown: '未知错误',
  Operation_Canceled: '操作取消'

  // 200 成功
  // 406 未发生变化
  // 808 申请成功
  // 810 邀请成功
};var secureCodes = [200, 406, 808, 810];
secureCodes.forEach(function (code) {
  codeMap[code] = null;
});

// 这个函数是Parser.prototype.parseResponse使用，没有callFunc
NIMError.genError = function (code) {
  var msg = codeMap[code];
  if (msg === undefined) {
    msg = '操作失败';
  }
  if (msg === null) {
    return null;
  } else {
    return new NIMError(msg, code);
  }
};

NIMError.multiInstance = function (event) {
  return new NIMError('不允许初始化多个实例', 'Not_Allow_Multi_Instance', event);
};

NIMError.newNetworkError = function (event) {
  var code = 'Error_Internet_Disconnected';
  return new NIMError(codeMap[code], code, event);
};

NIMError.newConnectError = function (event) {
  var code = 'Connect_Failed';
  return new NIMError(codeMap[code] || null, code, event);
};

NIMError.newConnectionError = function (event) {
  var code = 'Error_Connection_is_not_Established';
  return new NIMError(codeMap[code], code, event);
};

NIMError.newSocketStateError = function (event) {
  var code = 'Error_Connection_Socket_State_not_Match';
  return new NIMError(codeMap[code], code, event);
};
NIMError.newTimeoutError = function (event) {
  var code = 'Error_Timeout';
  return new NIMError(codeMap[code], code, event);
};

NIMError.newFrequencyControlError = function (event) {
  var code = 416;
  var error = new NIMError(codeMap[code], code, event);
  // 表明此错误是由客户端生成的，此字段只是用于自动化测试
  error.from = 'local';
  return error;
};

NIMError.newParamError = function (message, event) {
  var code = 'Param_Error';
  return new NIMError(message || codeMap[code], code, event);
};

NIMError.newNoFileError = function (message, event) {
  var code = 'No_File_Selected';
  return new NIMError(message || codeMap[code], code, event);
};

NIMError.newWrongFileTypeError = function (message, event) {
  var code = 'Wrong_File_Type';
  return new NIMError(message || codeMap[code], code, event);
};

NIMError.newFileTooLargeError = function (message, event) {
  var code = 'File_Too_Large';
  return new NIMError(message || codeMap[code], code, event);
};

NIMError.newCORSIframeError = function (event) {
  var code = 'Cross_Origin_Iframe';
  return new NIMError(codeMap[code], code, event);
};

NIMError.newSupportError = function (msg, code, event) {
  return new NIMError('不支持' + msg, 'Not_Support_' + code, event);
};

NIMError.newSupportDBError = function (event) {
  return NIMError.newSupportError('数据库', 'DB', event);
};

NIMError.noDBError = function (event) {
  var code = 'NO_DB';
  return new NIMError(codeMap[code], code, event);
};

NIMError.newDBError = function (event) {
  var code = 'DB';
  return new NIMError(codeMap[code], code, event);
};

NIMError.newUnknownError = function (event) {
  var code = 'Error_Unknown';
  return new NIMError(codeMap[code], code, event);
};

NIMError.stillInTeamError = function (event) {
  var code = 'Still_In_Team';
  return new NIMError(codeMap[code], code, event);
};

NIMError.sessionExist = function (event) {
  var code = 'Session_Exist';
  return new NIMError(codeMap[code], code, event);
};

NIMError.sessionNotExist = function (event) {
  var code = 'Session_Not_Exist';
  return new NIMError(codeMap[code], code, event);
};

NIMError.cancel = function (event) {
  var code = 'Operation_Canceled';
  return new NIMError(codeMap[code], code, event);
};

// 自定义错误类型
NIMError.customError = function (code, event) {
  code = code || 'Other_Error';
  event = event || {};
  var message = '';
  if (!event.message) {
    message = codeMap[code] || code;
  }
  if ((typeof code === 'undefined' ? 'undefined' : (0, _typeof3.default)(code)) !== 'object') {
    return new NIMError(message, code, event);
  } else if (typeof event === 'undefined') {
    return new NIMError(message, 'Other_Error', code);
  } else {
    return new NIMError(message, 'Other_Error', event);
  }
};

module.exports = NIMError;

/***/ }),

/***/ "./src/im/model/pushNotificationMultiportConfig.js":
/*!*********************************************************!*\
  !*** ./src/im/model/pushNotificationMultiportConfig.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;

/**
 * 多端推送配置项
 * @private
 * @property {Boolean} shouldPushNotificationWhenPCOnline 桌面端在线时是否需要发送推送给手机端
 */
function PushNotificationMultiportConfig(options) {
  var self = this;
  if (notundef(options.shouldPushNotificationWhenPCOnline)) {
    self.open = options.shouldPushNotificationWhenPCOnline ? 2 : 1;
  }
}

PushNotificationMultiportConfig.getDefaultConfig = function () {
  return {
    shouldPushNotificationWhenPCOnline: true
  };
};

PushNotificationMultiportConfig.reverse = function (donnop) {
  var obj = {
    shouldPushNotificationWhenPCOnline: +donnop.open !== 1
  };
  return obj;
};

module.exports = PushNotificationMultiportConfig;

/***/ }),

/***/ "./src/im/model/session.js":
/*!*********************************!*\
  !*** ./src/im/model/session.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * @constructor
 * @property {String}   id                  会话ID
 * @property {String}   scene               {@link IMMessage.type|场景}
 * @property {String}   to                  聊天对象, 账号或群ID
 * @property {Long}     updateTime          会话更新的时间
 * @property {Number}   unread              未读数
 * @property {Message}  lastMsg             此会话的最后一条消息
 * @property {Long}     [msgReceiptTime]    消息已读回执时间戳, 如果有此字段, 说明此时间戳之前的所有消息对方均已读
 * - 目前仅对{@link IMMessage.type|`'p2p'`}会话起作用
 * - 此字段不一定有, 只有对方发送过已读回执之后才会有
 * - 调用接口{@link NIM#sendMsgReceipt|sendMsgReceipt}来发送消息已读回执
 * - 调用接口{@link NIM#isMsgRemoteRead|isMsgRemoteRead}来查询消息是否被对方读过了
 * @property {String}   localCustom         本地自定义扩展字段
 * - 在{@link support.db|支持数据库}时可以调用{@Link NIM#updateLocalSession|更新本地会话}来更新此字段, 此字段只会被更新到本地数据库, 不会被更新到服务器上
 */
function Session() {}

Session.parse = function (session) {
    var arr = session.split('|');
    return {
        scene: arr[0],
        to: arr[1]
    };
};

Session.genSessionByMsg = function (msg) {
    var session = {
        id: msg.sessionId,
        scene: msg.scene,
        to: msg.target,
        updateTime: msg.time,
        lastMsg: msg
    };
    return session;
};

// lastTypeMsg: lastTextMsg, lastImageMsg, etc.
// lastFlowMsg: lastInMsg, lastOutmsg
// 无卵用, 去掉吧
Session.appendLastMsg = function (session) {
    var msg = session.lastMsg;
    var type = util.capFirstLetter(msg.type);
    session['last' + type + 'Msg'] = msg;
    var flow = util.capFirstLetter(msg.flow);
    session['last' + flow + 'Msg'] = msg;
};

// 根据最后一条未被忽略的消息来生成会话
Session.genSessionByMsgs = function (Message, msgs) {
    var lastMsg = Message.getLastNotIgnoredMsg(msgs);
    if (lastMsg) {
        return Session.genSessionByMsg(lastMsg);
    }
    return null;
};

Session.trim = function (session) {
    delete session.msgReceiptSendTime;
    delete session.msgReceiptServerTime;
    delete session.ack;
    delete session.unreadMsgs;
};

Session.isComplete = function (session) {
    return session.id && session.scene && session.to;
};

module.exports = Session;

/***/ }),

/***/ "./src/im/model/specialRelation.js":
/*!*****************************************!*\
  !*** ./src/im/model/specialRelation.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

/**
 * 黑名单/静音名单
 * @constructor
 * @name Relation
 * @property {String}   account     账号
 * @property {Long}     updateTime  更新时间
 */
function SpecialRelation() {}

SpecialRelation.parse = function (sr) {
  var obj = util.copy(sr);
  obj.isBlacked = obj.isBlacked === '1';
  obj.isMuted = obj.isMuted === '1';
  obj.createTime = +obj.createTime;
  obj.updateTime = +obj.updateTime;
  return obj;
};

module.exports = SpecialRelation;

/***/ }),

/***/ "./src/im/model/superTeam.js":
/*!***********************************!*\
  !*** ./src/im/model/superTeam.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var fillPropertyWithDefault = util.fillPropertyWithDefault;
var objKeys = Object.keys;

var map = {};
var reverseMap = {};
var validMap = {};
var modeNames = [];

var typeMap = {
  normal: 0,
  advanced: 1
};
var typeReverseMap = {
  0: 'normal',
  1: 'advanced'

  /**
   * 超大群
   *
   * @constructor
   * @property {String}   teamId                  群Id
   * @property {String}   type                    群类型 预留字段
   * @property {String}   name                    群名字
   * @property {String}   avatar                  群头像
   * @property {String}   intro                   群简介
   * @property {String}   announcement            群公告
   * @property {String}   owner                   群主
   * @property {Number}   level                   群人数上限
   * @property {Number}   memberNum               群成员数量
   * @property {Number}   memberUpdateTime        群成员最后更新时间
   * @property {Number}   createTime              群创建时间
   * @property {Number}   updateTime              群最后更新时间
   * @property {String}   custom                  第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
   * @property {String}   serverCustom            第三方服务器扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
   * @property {Boolean}  valid                   是否有效, 解散后该群无效
   * @property {Boolean}  validToCurrentUser      该群是否对当前用户有效, 如果无效, 那么说明被踢了
   * @property {Boolean}  mute                    是否禁言, 禁言状态下普通成员不能发送消息, 创建者和管理员可以发送消息
   */

};function SuperTeam(options) {
  var self = this;
  // 更新群时会用到
  util.verifyOptions(options, 'action', 'superTeam::SuperTeam');
  util.verifyOptions(options, 'teamId', 'superTeam::SuperTeam');

  if (notundef(options.teamId)) {
    self.teamId = options.teamId;
  }
  if (notundef(options.type)) {
    self.type = typeMap[options.type];
  }
  if (notundef(options.avatar)) {
    self.avatar = '' + options.avatar;
  }
  if (notundef(options.name)) {
    self.name = '' + options.name;
  }
  if (notundef(options.intro)) {
    self.intro = '' + options.intro;
  }
  if (notundef(options.announcement)) {
    self.announcement = '' + options.announcement;
  }
  // if (notundef(options.updateTeamMode)) {
  //   self.updateTeamMode = '' + options.updateTeamMode
  // }
  if (notundef(options.custom)) {
    self.custom = '' + options.custom;
  }
  modeNames.forEach(self.setMode.bind(self, options));
}

// 设置各种模式并验证其正确性
SuperTeam.prototype.setMode = function (options, name) {
  var self = this;
  name = name + 'Mode';
  if (notundef(options[name])) {
    util.verifyParamValid(name, options[name], validMap[name], 'Superteam::Team');
    self[name] = map[name][options[name]];
  }
};

/**
 * 逆转team, 因为可能是更新team信息, 可能只有部分信息, 所以用filter过滤不存在的信息
 *
 * @private
 * @param  {SuperTeam} team 超大群
 * @param  {flag} 不需要填充
 * @return {Object}
 */
SuperTeam.reverse = function (team, flag) {
  var obj = util.copy(team);
  if (notundef(obj.teamId)) {
    obj.teamId = '' + obj.teamId;
  }
  if (notundef(obj.type)) {
    obj.type = typeReverseMap[obj.type];
  }
  if (notundef(obj.level)) {
    obj.level = +obj.level;
  }
  if (notundef(obj.valid)) {
    obj.valid = +obj.valid === 1;
  }
  if (notundef(obj.memberNum)) {
    obj.memberNum = +obj.memberNum;
  }
  if (notundef(obj.memberUpdateTime)) {
    obj.memberUpdateTime = +obj.memberUpdateTime;
  }
  if (notundef(obj.createTime)) {
    obj.createTime = +obj.createTime;
  }
  if (notundef(obj.updateTime)) {
    obj.updateTime = +obj.updateTime;
  }
  if (notundef(obj.validToCurrentUser)) {
    obj.validToCurrentUser = obj.validToCurrentUser === '1';
  }
  if (notundef(obj.mute)) {
    obj.mute = obj.mute === '1';
  }
  if (notundef(obj.muteType)) {
    switch (obj.muteType) {
      case '0':
        obj.mute = false;
        obj.muteType = 'none';
        break;
      case '1':
        obj.mute = true;
        obj.muteType = 'normal';
        break;
      case '2':
        obj.mute = true;
        obj.muteType = 'all';
        break;
      default:
        break;
    }
  } else if (notundef(obj.mute)) {
    if (obj.mute === 1) {
      obj.mute = true;
      obj.muteType = 'normal';
    } else {
      obj.mute = false;
      obj.muteType = 'none';
    }
  }
  modeNames.forEach(reverseMode.bind(null, obj));
  delete obj.bits;
  if (!flag) {
    SuperTeam.fillProperties(obj);
  }
  return obj;
};

function reverseMode(obj, name) {
  name = name + 'Mode';
  if (notundef(obj[name])) {
    obj[name] = reverseMap[name][obj[name]];
  }
}

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 */
SuperTeam.fillProperties = function (team) {
  // var fill1 = fillPropertyWithDefault(team, 'beInviteMode', 'needVerify')
  // var fill2 = fillPropertyWithDefault(team, 'inviteMode', 'manager')
  // var fill3 = fillPropertyWithDefault(team, 'updateTeamMode', 'manager')
  // var fill4 = fillPropertyWithDefault(team, 'updateCustomMode', 'manager')
  var fill5 = fillPropertyWithDefault(team, 'avatar', '');
  return fill5;
  // return fill1 || fill2 || fill3 || fill4 || fill5
};

module.exports = SuperTeam;

/***/ }),

/***/ "./src/im/model/superTeamMember.js":
/*!*****************************************!*\
  !*** ./src/im/model/superTeamMember.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var fillPropertyWithDefault = util.fillPropertyWithDefault;

/**
 * 超大群成员类型
 *
 * - `'normal'` (普通成员)
 * - `'owner'` (群主)
 *
 * @memberOf SuperTeamMember
 * @name type
 * @readOnly
 * @enum {String}
 */
var typeReverseMap = {
    0: 'normal',
    1: 'owner',
    2: 'manager'

    /**
     * 群成员
     *
     * @constructor
     * @property {Number}   teamId          群ID
     * @property {String}   account         帐号
     * @property {String}   type            {@link TeamMember.type|群成员类型}
     * @property {String}   nickInTeam      在群里面的昵称
     * @property {Boolean}  muteTeam        是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定
     * @property {Number}   joinTime        入群时间
     * @property {Number}   updateTime      更新时间
     * @property {Boolean}  active          普通群拉人进来的时候, 被拉的人处于未激活状态, 未激活状态下看不到这个群, 当有人说话后自动转为激活状态, 能看到该群
     * @property {Boolean} mute 是否被禁言
     * @property {String} custom 第三方扩展字段
     */
};function SuperTeamMember(options) {
    var self = this;
    util.verifyOptions(options, 'teamId', 'superTeam::TeamMember');
    util.verifyParamAtLeastPresentOne(options, 'nickInTeam muteTeam muteNotiType custom', 'superTeam::SuperTeamMember');
    self.teamId = options.teamId;
    // 当更新自己的昵称时, 不会传`account`
    if (notundef(options.account)) {
        self.account = options.account;
    }
    if (notundef(options.nickInTeam)) {
        self.nickInTeam = options.nickInTeam;
    }
    if (notundef(options.muteNotiType)) {
        self.bits = options.muteNotiType;
    } else if (notundef(options.muteTeam)) {
        self.bits = 0;
        if (options.muteTeam) {
            self.bits += 1 << 0;
        }
    }
    if (notundef(options.mute)) {
        self.mute = options.mute ? 1 : 0;
    }
    if (notundef(options.custom)) {
        self.custom = '' + options.custom;
    }
}

SuperTeamMember.reverse = function (teamMember) {
    var obj = util.copy(teamMember);
    if (notundef(obj.teamId)) {
        obj.teamId = '' + obj.teamId;
    }
    if (notundef(obj.type)) {
        obj.type = typeReverseMap[obj.type];
    }
    if (notundef(obj.active)) {
        obj.active = +obj.active === 1;
    }
    if (notundef(obj.valid)) {
        obj.valid = +obj.valid === 1;
    }
    if (notundef(obj.mute)) {
        obj.mute = +obj.mute === 1;
    }
    if (notundef(obj.joinTime)) {
        obj.joinTime = +obj.joinTime;
    }
    if (notundef(obj.updateTime)) {
        obj.updateTime = +obj.updateTime;
    }
    if (notundef(obj.bits)) {
        // 需要同时知道其他标志位的值才能正确设置, 目前只有一个标志位所以是没问题
        var bits = obj.bits;
        delete obj.bits;
        obj.muteTeam = !!(bits & 1);
        obj.muteNotiType = bits;
    }
    // 添加 ID
    if (notundef(obj.teamId) && notundef(obj.account)) {
        obj.id = SuperTeamMember.genId(obj.teamId, obj.account);
    }
    return obj;
};

SuperTeamMember.reverseMembers = function (members) {
    return members.map(function (member) {
        return SuperTeamMember.reverse(member);
    });
};

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 */
SuperTeamMember.fillProperties = function (member) {
    var fill1 = fillPropertyWithDefault(member, 'mute', false);
    var fill2 = fillPropertyWithDefault(member, 'custom', '');
    return fill1 || fill2;
};

SuperTeamMember.genId = function (teamId, account) {
    return teamId + '-' + account;
};

SuperTeamMember.accounts2ids = function (teamId, accounts) {
    return accounts.map(function (a) {
        return SuperTeamMember.genId(teamId, a);
    });
};

SuperTeamMember.assembleMembers = function (team, accounts) {
    if (!util.isArray(accounts)) {
        accounts = [accounts];
    }
    return accounts.map(function (account) {
        return SuperTeamMember.assembleMember(team, account);
    });
};

SuperTeamMember.assembleMember = function (team, account) {
    return {
        id: SuperTeamMember.genId(team.teamId, account),
        account: account,
        teamId: team.teamId,
        type: 'normal',
        nickInTeam: "",
        muteTeam: false,
        mute: false,
        joinTime: team.memberUpdateTime,
        updateTime: team.memberUpdateTime,
        active: true,
        valid: true
    };
};

SuperTeamMember.assembleOwner = function (team) {
    var owner = SuperTeamMember.assembleMember(team, team.owner);
    owner.type = 'owner';
    return owner;
};

module.exports = SuperTeamMember;

/***/ }),

/***/ "./src/im/model/systemMessage.js":
/*!***************************************!*\
  !*** ./src/im/model/systemMessage.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var notundef = util.notundef;
var parser = __webpack_require__(/*! im/protocol/parser */ "./src/im/protocol/parser/index.js").IM;
var team = __webpack_require__(/*! im/model/team */ "./src/im/model/team.js");
var TeamMember = __webpack_require__(/*! im/model/teamMember */ "./src/im/model/teamMember.js");

/**
 * 系统通知类型
 *
 * - `'addFriend'`
 *     - {@link NIM#addFriend|直接加某个用户为好友}后, 对方不需要确认, 直接成为当前登录用户的好友。
 *     - 对方会收到一条类型为`'addFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号。
 * - `'applyFriend'`
 *     - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
 *         - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
 *         - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
 * - `'passFriendApply'`
 *     - 见 `'applyFriend'`
 * - `'rejectFriendApply'`
 *     - 见 `'applyFriend'`
 * - `'deleteFriend'`
 *     - {@link NIM#deleteFriend|删除好友}后, 被删除的人会收到一条类型为`'deleteFriend'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为删除方的帐号, `to`字段的值为被删除方的账号。
 * - `'teamInvite'`
 *     - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
 *         - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
 *         - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
 * - `'rejectTeamInvite'`
 *     - 见`'teamInvite'`
 * - `'applyTeam'`
 *     - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
 *         - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
 *         - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
 * - `'rejectTeamApply'`
 *     - 见`'applyTeam'`
 * - `'deleteMsg'`
 *     - {@link NIM#deleteMsg|撤回消息}后, 消息接收方会收到一条类型为`'deleteMsg'`的{@link SystemMessage|系统通知}, 此类系统通知的 `msg` 为被删除的消息的部分字段。如果是群消息, 那么群里的所有人都会收到这条系统通知. 如果同时在多个端登录了同一个账号, 那么其它端也会收到这条系统通知.
 * - `'custom'`
 *     - 自定义系统通知
 *
 * @memberOf SystemMessage
 * @name type
 * @readOnly
 * @enum {String}
 */
var typeMap = {
  customP2p: 100,
  customTeam: 101,
  deleteMsgP2p: 7,
  deleteMsgTeam: 8
};
var typeReverseMap = {
  0: 'applyTeam',
  1: 'rejectTeamApply',
  2: 'teamInvite',
  3: 'rejectTeamInvite',
  5: 'friendRequest',
  6: 'deleteFriend',
  7: 'deleteMsgP2p',
  8: 'deleteMsgTeam',
  // 自定义系统通知
  100: 'customP2p',
  101: 'customTeam',
  // 云商服自定义系统通知, 直接复用100
  102: 'customP2p'
};
var friendRequestReverseMap = {
  1: 'addFriend',
  2: 'applyFriend',
  3: 'passFriendApply',
  4: 'rejectFriendApply'
};

var categoryTeam = 'team';
var categoryFriend = 'friend';
var categoryMsg = 'msg';
var categories = [categoryTeam, categoryFriend, categoryMsg];
var type2category = {
  applyTeam: categoryTeam,
  rejectTeamApply: categoryTeam,
  teamInvite: categoryTeam,
  rejectTeamInvite: categoryTeam,
  addFriend: categoryFriend,
  applyFriend: categoryFriend,
  passFriendApply: categoryFriend,
  rejectFriendApply: categoryFriend,
  deleteFriend: categoryFriend,
  deleteMsg: categoryMsg

  /**
   * 内建系统通知的种类
   * - `'team'`
   * - `'friend'`
   *
   * @memberOf SystemMessage
   * @name category
   * @readOnly
   * @enum {String}
   */

  /**
   * 内建系统通知的状态
   * - `'init'`: 未处理状态
   * - `'passed'`: 已通过
   * - `'rejected'`: 已拒绝
   * - `'error'`: 错误
   *
   * @memberOf SystemMessage
   * @name state
   * @readOnly
   * @enum {String}
   */

  /**
   * 系统通知
   *
   * 系统通知分为两种
   * - 内建系统通知
   *     - 目前所有的内建系统通知都是与高级群相关的通知, 某些群操作后相关的群成员会收到相应的系统通知。
   *     - 内建系统通知与{@link IMMessage.type|群通知消息}的区别是系统通知是发给单人的通知, 群通知消息是发给所有群成员的消息。
   * - 自定义系统通知
   *     - 开发者可以向其他用户或群{@link NIM#sendCustomSysMsg|发送自定义系统通知}
   *     - 自定义系统通知和自定义消息的区别如下
   *         - 自定义消息属于{@link IMMessage|消息}, 会存储在云信的消息数据库中, 需要跟其他{@link IMMessage|消息}一同展现给用户。
   *         - 自定义系统通知属于{@link SystemMessage|系统通知}, 用于第三方通知自己, 不会存储在云信的数据库中, SDK不会解析这些通知, SDK仅仅负责传递这些通知。
   * - 请参考{@link NIM|初始化SDK}时传入的`onofflinesysmsgs`、`onofflinecustomsysmsgs`、`onsysmsg`、`oncustomsysmsg`等回调。
   *
   * @constructor
   * @property {Number}           time                    时间戳
   * @property {String}           [type]                  {@link SystemMessage.type|系统通知类型}
   * @property {String}           from                    系统通知的来源, 账号或者群ID
   * @property {String}           to                      系统通知的目标, 账号或者群ID
   * @property {String}           [idServer]              内建系统通知的 idServer
   * @property {Boolean}          [read]                  内建系统通知是否已读
   * @property {String}           [category]              {@link SystemMessage.category|内建系统通知的种类}
   * @property {String}           [state]                 内建系统通知的{@link SystemMessage|state}
   * @property {NIMError}         [error]                 内建系统通知的{@link SystemMessage.state|state} 为 `'error'` 时, 此字段包含错误的信息
   * @property {String}           [localCustom]           内建系统通知的本地自定义扩展字段
   * - 在{@link support.db|支持数据库}时可以调用{@Link NIM#updateLocalSysMsg|更新本地系统通知}来更新此字段, 此字段只会被更新到本地数据库, 不会被更新到服务器上
   * @property {String}           [ps]                    内建系统通知的附言
   * @property {Object}           [attach]                内建系统通知的附加信息, 参考{@link SystemMessage.type|系统通知类型}来查看不同类型的系统通知对应的附加信息
   * @property {String}           [attach.custom]         附加消息的扩展字段, 可能没有
   * @property {String}           [scene]                 自定义系系统通知的场景, 参考{@link IMMessage.scene|消息场景}
   * @property {String}           [content]               自定义系统通知的内容
   * @property {Boolean}          isPushable              是否需要推送
   * @property {String}           [apnsText]              自定义系统通知的推送文案, 仅对接收方为iOS设备有效
   * @property {String}           [pushPayload]           自定义系统通知的推送属性
   * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
   * @property {Boolean}          needPushNick            是否需要推送昵称
   * @property {Boolean}          [sendToOnlineUsersOnly] 自定义系统通知是否只发送给在线用户。
   * - `true`时只发送给在线用户, 适合发送即时通知, 比如正在输入。
   * - `false`时假如目标用户或群不在线, 会在其上线后推送过去。
   * - 该参数只对点对点自定义系统通知有效, 对群自定义系统通知无效, 群自定义系统通知只会发给在线的群成员, 不会存离线。
   * @property {Boolean}          cc                      自定义系统通知是否抄送
   */
};function SystemMessage(options) {
  var self = this;
  util.verifyOptions(options, 'type to', 'sysmsg::SystemMessage');
  util.verifyParamValid('type', options.type, SystemMessage.validTypes, 'sysmsg::SystemMessage');
  if (options.type.indexOf('custom') !== -1) {
    util.verifyOptions(options, 'content', 'sysmsg::SystemMessage');
    self.attach = options.content;
    if (notundef(options.apnsText)) {
      self.apnsText = '' + options.apnsText;
    }
    if (notundef(options.pushPayload)) {
      if ((0, _typeof3.default)(options.pushPayload) === 'object') {
        self.pushPayload = JSON.stringify(options.pushPayload);
      } else {
        self.pushPayload = '' + options.pushPayload;
      }
    }
    // 开关
    if (notundef(options.sendToOnlineUsersOnly)) {
      self.sendToOnlineUsersOnly = !!options.sendToOnlineUsersOnly ? 0 : 1;
    }
    if (notundef(options.cc)) {
      self.cc = !!options.cc ? 1 : 0;
    }
    if (notundef(options.isPushable)) {
      self.isPushable = options.isPushable ? 1 : 0;
    }
    if (notundef(options.isUnreadable)) {
      self.isUnreadable = options.isUnreadable ? 1 : 0;
    }
    if (notundef(options.needPushNick)) {
      self.needPushNick = options.needPushNick ? 1 : 0;
    }
  }
  self.time = options.time || +new Date();
  self.type = typeMap[options.type];
  self.to = options.to;
  if (notundef(options.from)) {
    self.from = options.from;
  }
  if (notundef(options.ps)) {
    self.ps = options.ps;
  }
  if (notundef(options.deletedIdClient)) {
    self.deletedIdClient = options.deletedIdClient;
  }
  if (notundef(options.deletedIdServer)) {
    self.deletedIdServer = options.deletedIdServer;
  }
  if (notundef(options.opeAccount)) {
    self.opeAccount = options.opeAccount;
  }
  if (notundef(options.yidunEnable)) {
    self.yidunEnable = options.yidunEnable ? 1 : 0;
  }
  if (notundef(options.antiSpamContent)) {
    if ((0, _typeof3.default)(options.antiSpamContent) === 'object') {
      self.antiSpamContent = JSON.stringify(options.antiSpamContent);
    } else {
      self.antiSpamContent = '' + options.antiSpamContent;
    }
  }
  if (notundef(options.antiSpamBusinessId)) {
    if ((0, _typeof3.default)(options.antiSpamBusinessId) === 'object') {
      self.antiSpamBusinessId = JSON.stringify(options.antiSpamBusinessId);
    } else {
      self.antiSpamBusinessId = '' + options.antiSpamBusinessId;
    }
  }
  self.idClient = options.idClient || util.guid();
}

SystemMessage.validTypes = Object.keys(typeMap).concat(Object.keys(type2category));
SystemMessage.validCategories = ['team', 'friend'];

SystemMessage.isCustom = function (sysMsg) {
  return sysMsg.type === 'custom';
};

SystemMessage.reverse = function (sysMsg) {
  var obj = {
    time: +sysMsg.time,
    to: sysMsg.to,
    type: typeReverseMap[sysMsg.type]
  };

  if (notundef(sysMsg.from)) {
    obj.from = sysMsg.from;
  }
  if (notundef(sysMsg.idServer)) {
    obj.idServer = '' + sysMsg.idServer;
  }
  if (notundef(sysMsg.deletedIdClient)) {
    obj.deletedIdClient = sysMsg.deletedIdClient;
  }
  if (notundef(sysMsg.deletedIdServer)) {
    obj.deletedIdServer = '' + sysMsg.deletedIdServer;
  }
  if (notundef(sysMsg.deletedMsgTime)) {
    obj.deletedMsgTime = +sysMsg.deletedMsgTime;
  }
  if (notundef(sysMsg.deletedMsgFromNick)) {
    obj.deletedMsgFromNick = '' + sysMsg.deletedMsgFromNick;
  }
  if (notundef(sysMsg.opeAccount)) {
    obj.opeAccount = sysMsg.opeAccount;
  }
  if (notundef(sysMsg.ps)) {
    obj.ps = sysMsg.ps;
  }

  // 内建系统通知, attach里面是额外数据
  sysMsg.attach = !!sysMsg.attach ? '' + sysMsg.attach : '';
  if (obj.type === 'customP2p' || obj.type === 'customTeam') {
    // 自定义的系统通知
    obj.content = sysMsg.attach;
    if (notundef(sysMsg.apnsText)) {
      obj.apnsText = sysMsg.apnsText;
    }
    if (notundef(sysMsg.pushPayload)) {
      obj.pushPayload = sysMsg.pushPayload;
    }
    // 开关
    util.merge(obj, {
      sendToOnlineUsersOnly: undef(sysMsg.sendToOnlineUsersOnly) || +sysMsg.sendToOnlineUsersOnly === 0,
      cc: undef(sysMsg.cc) || +sysMsg.cc === 1,
      isPushable: undef(sysMsg.isPushable) || +sysMsg.isPushable === 1,
      isUnreadable: undef(sysMsg.isUnreadable) || +sysMsg.isUnreadable === 1,
      needPushNick: notundef(sysMsg.needPushNick) && +sysMsg.needPushNick === 1
    });
    // 设置 scene
    obj.scene = obj.type.slice(6).toLowerCase();
    // 最终展示给用户的类型就是`'custome'`
    obj.type = 'custom';
  } else if (obj.type === 'deleteMsgP2p' || obj.type === 'deleteMsgTeam') {
    // 撤回消息的通知
    obj.scene = obj.type.slice(9).toLowerCase();
    obj.type = 'deleteMsg';
  } else {
    if (!!sysMsg.attach) {
      obj.attach = {};
      var attach = JSON.parse(sysMsg.attach);
      if (notundef(attach.vt)) {
        // 好友系统请求
        obj.type = friendRequestReverseMap[attach.vt];
        delete obj.attach;
      } else {
        // 群系统通知
        if (notundef(attach.tinfo)) {
          obj.attach.team = team.reverse(parser.syncUnserialize(attach.tinfo, 'team'));
        }
        if (notundef(attach.tlist)) {
          obj.attach.member = TeamMember.reverse(parser.syncUnserialize(attach.tlist, 'teamMember'));
        }
        if (notundef(attach.attach)) {
          obj.attach.custom = attach.attach;
        }
      }
    }
    obj.category = type2category[obj.type];
    obj.read = false;
    obj.state = 'init';
  }

  // 开关
  if (notundef(sysMsg.cc)) {
    obj.cc = +sysMsg.cc === 1;
  }

  // SDK 自己加的属性
  obj.status = sysMsg.status || 'success';
  if (notundef(sysMsg.filter)) {
    obj.filter = sysMsg.filter;
  }

  return obj;
};

SystemMessage.reverseSysMsgs = function (sysMsgs, options) {
  options = options || {};
  var mapper = options.mapper;
  var needMap = util.isFunction(mapper);
  return sysMsgs.map(function (sysMsg) {
    sysMsg = SystemMessage.reverse(sysMsg);
    if (needMap) {
      sysMsg = mapper(sysMsg);
    }
    return sysMsg;
  });
};

SystemMessage.completeUnread = function (sysMsgUnread) {
  sysMsgUnread = sysMsgUnread || {};
  categories.forEach(function (category) {
    delete sysMsgUnread[category];
  });
  var category;
  Object.keys(type2category).forEach(function (type) {
    sysMsgUnread[type] = sysMsgUnread[type] || 0;
    if (sysMsgUnread[type] < 0) {
      sysMsgUnread[type] = 0;
    }
    category = type2category[type];
    sysMsgUnread[category] = sysMsgUnread[category] || 0;
    sysMsgUnread[category] = sysMsgUnread[category] + sysMsgUnread[type];
  });
  sysMsgUnread.total = 0;
  categories.forEach(function (category) {
    sysMsgUnread.total += sysMsgUnread[category];
  });
  return sysMsgUnread;
};

module.exports = SystemMessage;

/***/ }),

/***/ "./src/im/model/team.js":
/*!******************************!*\
  !*** ./src/im/model/team.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var fillPropertyWithDefault = util.fillPropertyWithDefault;
var objKeys = Object.keys;

var map = {};
var reverseMap = {};
var modeNames = [];
var validMap = {};

/**
 * 群类型
 *
 * - `'normal'` (普通群)
 * - `'advanced'` (高级群)
 *
 * 普通群没有群简介/群公告/群加入方式/群被邀请模式/群邀请模式/群信息修改权限/群信息自定义字段修改权限
 *
 * @memberOf Team
 * @name type
 * @readOnly
 * @enum {String}
 */
var typeMap = {
  normal: 0,
  advanced: 1
};
var typeReverseMap = {
  0: 'normal',
  1: 'advanced'
};
var validTypes = objKeys(typeMap);

/**
 * 群加入方式
 *
 * - `'noVerify'` (不需要验证)
 * - `'needVerify'` (需要验证)
 * - `'rejectAll'` (禁止任何人加入)
 *
 * @memberOf Team
 * @name joinMode
 * @readOnly
 * @enum {String}
 */
var joinModeMap = map.joinMode = {
  noVerify: 0,
  needVerify: 1,
  rejectAll: 2
};
reverseMap.joinMode = {
  0: 'noVerify',
  1: 'needVerify',
  2: 'rejectAll'
};
modeNames.push('join');
validMap.joinMode = objKeys(joinModeMap);

/**
 * 群被邀请模式
 * - `'needVerify'` (需要邀请方同意)
 * - `'noVerify'` (不需要邀请方同意)
 * @memberOf Team
 * @name beInviteMode
 * @readOnly
 * @enum {String}
 */
var beInviteModeMap = map.beInviteMode = {
  needVerify: 0,
  noVerify: 1
};
reverseMap.beInviteMode = {
  0: 'needVerify',
  1: 'noVerify'
};
modeNames.push('beInvite');
validMap.beInviteMode = objKeys(beInviteModeMap);

/**
 * 群邀请模式
 * - `'manager'` (只有管理员/群主可以邀请他人入群)
 * - `'all'` (所有人可以邀请他人入群)
 * @memberOf Team
 * @name  inviteMode
 * @readOnly
 * @enum {String}
 */
var inviteModeMap = map.inviteMode = {
  manager: 0,
  all: 1
};
reverseMap.inviteMode = {
  0: 'manager',
  1: 'all'
};
modeNames.push('invite');
validMap.inviteMode = objKeys(inviteModeMap);

/**
 * 群信息修改权限
 * - `'manager'` (只有管理员/群主可以修改)
 * - `'all'` (所有人可以修改)
 * @memberOf Team
 * @name  updateTeamMode
 * @readOnly
 * @enum {String}
 */
var updateTeamModeMap = map.updateTeamMode = {
  manager: 0,
  all: 1
};
reverseMap.updateTeamMode = {
  0: 'manager',
  1: 'all'
};
modeNames.push('updateTeam');
validMap.updateTeamMode = objKeys(updateTeamModeMap);

/**
 * 群信息自定义字段修改权限
 * - `'manager'` (只有管理员/群主可以修改)
 * - `'all'` (所有人可以修改)
 * @memberOf Team
 * @name  updateCustomMode
 * @readOnly
 * @enum {String}
 */
var updateCustomModeMap = map.updateCustomMode = {
  manager: 0,
  all: 1
};
reverseMap.updateCustomMode = {
  0: 'manager',
  1: 'all'
};
modeNames.push('updateCustom');
validMap.updateCustomMode = objKeys(updateCustomModeMap);

/**
 * 群
 *
 * @constructor
 * @property {String}   teamId                  群Id
 * @property {String}   type                    {@link Team.type|群类型}
 * @property {String}   name                    群名字
 * @property {String}   avatar                  群头像
 * @property {String}   intro                   群简介
 * @property {String}   announcement            群公告
 * @property {String}   joinMode                {@link Team.joinMode|群加入方式}, 仅限高级群
 * @property {String}   beInviteMode            {@link Team.beInviteMode|群被邀请模式}, 仅限高级群
 * @property {String}   inviteMode              {@link Team.inviteMode|群邀请模式}, 仅限高级群
 * @property {String}   updateTeamMode          {@link Team.updateTeamMode|群信息修改权限}, 仅限高级群
 * @property {String}   updateCustomMode        {@link Team.updateCustomMode|群信息自定义字段修改权限}, 仅限高级群
 * @property {String}   owner                   群主
 * @property {Number}   level                   群人数上限
 * @property {Number}   memberNum               群成员数量
 * @property {Number}   memberUpdateTime        群成员最后更新时间
 * @property {Number}   createTime              群创建时间
 * @property {Number}   updateTime              群最后更新时间
 * @property {String}   custom                  第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
 * @property {String}   serverCustom            第三方服务器扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
 * @property {Boolean}  valid                   是否有效, 解散后该群无效
 * @property {Boolean}  validToCurrentUser      该群是否对当前用户有效, 如果无效, 那么说明被踢了
 * @property {Boolean}  mute                    是否禁言, 禁言状态下普通成员不能发送消息, 创建者和管理员可以发送消息
 */
function Team(options) {
  var self = this;
  util.verifyOptions(options, 'action', 'team::Team');
  // 根据不同的action来验证不同的参数
  switch (options.action) {
    case 'create':
      util.verifyOptions(options, 'teamId', false, 'team::Team');
      util.verifyOptions(options, 'type name', 'team::Team');
      util.verifyParamValid('type', options.type, validTypes, 'team::Team');
      if (notundef(options.level)) {
        util.verifyParamType('level', options.level, 'number', 'team::Team');
        self.level = options.level;
      }
      break;
    case 'update':
      util.verifyOptions(options, 'teamId', 'team::Team');
      util.verifyOptions(options, 'type', false, 'team::Team');
      break;
    default:
      break;
  }
  if (notundef(options.teamId)) {
    self.teamId = options.teamId;
  }
  if (notundef(options.type)) {
    self.type = typeMap[options.type];
  }
  if (notundef(options.avatar)) {
    self.avatar = '' + options.avatar;
  }
  if (notundef(options.name)) {
    self.name = '' + options.name;
  }
  if (notundef(options.intro)) {
    self.intro = '' + options.intro;
  }
  if (notundef(options.announcement)) {
    self.announcement = '' + options.announcement;
  }
  modeNames.forEach(self.setMode.bind(self, options));
  if (notundef(options.custom)) {
    self.custom = '' + options.custom;
  }
}

var pro = Team.prototype;

// 设置各种模式, 验证其正确性
pro.setMode = function (options, name) {
  var self = this;
  name = name + 'Mode';
  if (notundef(options[name])) {
    util.verifyParamValid(name, options[name], validMap[name], 'team::Team');
    self[name] = map[name][options[name]];
  }
};

/**
 * 逆转team, 因为可能是更新team信息, 可能只有部分信息, 所以用filter过滤不存在的信息
 *
 * @private
 * @param  {Team} team 群
 * @param  {flag} 不需要填充
 * @return {Object}
 */
Team.reverse = function (team, flag) {
  var obj = util.copy(team);
  if (notundef(obj.teamId)) {
    obj.teamId = '' + obj.teamId;
  }
  if (notundef(obj.type)) {
    obj.type = typeReverseMap[obj.type];
  }
  if (notundef(obj.level)) {
    obj.level = +obj.level;
  }
  if (notundef(obj.valid)) {
    obj.valid = +obj.valid === 1;
  }
  if (notundef(obj.memberNum)) {
    obj.memberNum = +obj.memberNum;
  }
  if (notundef(obj.memberUpdateTime)) {
    obj.memberUpdateTime = +obj.memberUpdateTime;
  }
  if (notundef(obj.createTime)) {
    obj.createTime = +obj.createTime;
  }
  if (notundef(obj.updateTime)) {
    obj.updateTime = +obj.updateTime;
  }
  if (notundef(obj.validToCurrentUser)) {
    obj.validToCurrentUser = obj.validToCurrentUser === '1';
  }
  if (notundef(obj.mute)) {
    obj.mute = obj.mute === '1';
  }
  if (notundef(obj.muteType)) {
    switch (obj.muteType) {
      case '0':
        obj.mute = false;
        obj.muteType = 'none';
        break;
      case '1':
        obj.mute = true;
        obj.muteType = 'normal';
        break;
      case '2':
        obj.mute = true;
        obj.muteType = 'all';
        break;
      default:
        break;
    }
  } else if (notundef(obj.mute)) {
    if (obj.mute === 1) {
      obj.mute = true;
      obj.muteType = 'normal';
    } else {
      obj.mute = false;
      obj.muteType = 'none';
    }
  }
  modeNames.forEach(reverseMode.bind(null, obj));
  delete obj.bits;
  if (!flag) {
    Team.fillProperties(obj);
  }
  return obj;
};

function reverseMode(obj, name) {
  name = name + 'Mode';
  if (notundef(obj[name])) {
    obj[name] = reverseMap[name][obj[name]];
  }
}

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 */
Team.fillProperties = function (team) {
  var fill1 = fillPropertyWithDefault(team, 'beInviteMode', 'needVerify');
  var fill2 = fillPropertyWithDefault(team, 'inviteMode', 'manager');
  var fill3 = fillPropertyWithDefault(team, 'updateTeamMode', 'manager');
  var fill4 = fillPropertyWithDefault(team, 'updateCustomMode', 'manager');
  var fill5 = fillPropertyWithDefault(team, 'avatar', '');
  return fill1 || fill2 || fill3 || fill4 || fill5;
};

module.exports = Team;

/***/ }),

/***/ "./src/im/model/teamMember.js":
/*!************************************!*\
  !*** ./src/im/model/teamMember.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;
var fillPropertyWithDefault = util.fillPropertyWithDefault;

/**
 * 群成员类型
 *
 * - `'normal'` (普通成员)
 * - `'owner'` (群主)
 * - `'manager'` (管理员)
 *
 * @memberOf TeamMember
 * @name type
 * @readOnly
 * @enum {String}
 */
var typeReverseMap = {
    0: 'normal',
    1: 'owner',
    2: 'manager'

    /**
     * 群成员
     *
     * @constructor
     * @property {Number}   teamId          群ID
     * @property {String}   account         帐号
     * @property {String}   type            {@link TeamMember.type|群成员类型}
     * @property {String}   nickInTeam      在群里面的昵称
     * @property {Boolean}  muteTeam        是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定
     * @property {Number}   joinTime        入群时间
     * @property {Number}   updateTime      更新时间
     * @property {Boolean}  active          普通群拉人进来的时候, 被拉的人处于未激活状态, 未激活状态下看不到这个群, 当有人说话后自动转为激活状态, 能看到该群
     * @property {Boolean} mute 是否被禁言
     * @property {String} custom 第三方扩展字段
     */
};function TeamMember(options) {
    var self = this;
    util.verifyOptions(options, 'teamId', 'team::TeamMember');
    util.verifyParamAtLeastPresentOne(options, 'nickInTeam muteTeam muteNotiType custom', 'team::TeamMember');
    self.teamId = options.teamId;
    // 当更新自己的昵称时, 不会传`account`
    if (notundef(options.account)) {
        self.account = options.account;
    }
    if (notundef(options.nickInTeam)) {
        self.nickInTeam = options.nickInTeam;
    }
    if (notundef(options.muteNotiType)) {
        self.bits = options.muteNotiType;
    } else if (notundef(options.muteTeam)) {
        self.bits = 0;
        if (options.muteTeam) {
            self.bits += 1 << 0;
        }
    }
    if (notundef(options.mute)) {
        self.mute = options.mute ? 1 : 0;
    }
    if (notundef(options.custom)) {
        self.custom = '' + options.custom;
    }
}

TeamMember.reverse = function (teamMember) {
    var obj = util.copy(teamMember);
    if (notundef(obj.teamId)) {
        obj.teamId = '' + obj.teamId;
    }
    if (notundef(obj.type)) {
        obj.type = typeReverseMap[obj.type];
    }
    if (notundef(obj.active)) {
        obj.active = +obj.active === 1;
    }
    if (notundef(obj.valid)) {
        obj.valid = +obj.valid === 1;
    }
    if (notundef(obj.mute)) {
        obj.mute = +obj.mute === 1;
    }
    if (notundef(obj.joinTime)) {
        obj.joinTime = +obj.joinTime;
    }
    if (notundef(obj.updateTime)) {
        obj.updateTime = +obj.updateTime;
    }
    if (notundef(obj.bits)) {
        // 需要同时知道其他标志位的值才能正确设置, 目前只有一个标志位所以是没问题
        var bits = obj.bits;
        delete obj.bits;
        obj.muteTeam = !!(bits & 1);
        obj.muteNotiType = bits;
    }
    // 添加 ID
    if (notundef(obj.teamId) && notundef(obj.account)) {
        obj.id = TeamMember.genId(obj.teamId, obj.account);
    }
    return obj;
};

TeamMember.reverseMembers = function (members) {
    return members.map(function (member) {
        return TeamMember.reverse(member);
    });
};

/**
 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
 */
TeamMember.fillProperties = function (teamMember) {
    var fill1 = fillPropertyWithDefault(teamMember, 'mute', false);
    var fill2 = fillPropertyWithDefault(teamMember, 'custom', '');
    return fill1 || fill2;
};

TeamMember.genId = function (teamId, account) {
    return teamId + '-' + account;
};

TeamMember.accounts2ids = function (teamId, accounts) {
    return accounts.map(function (a) {
        return TeamMember.genId(teamId, a);
    });
};

TeamMember.assembleMembers = function (team, accounts) {
    if (!util.isArray(accounts)) {
        accounts = [accounts];
    }
    return accounts.map(function (account) {
        return TeamMember.assembleMember(team, account);
    });
};

TeamMember.assembleMember = function (team, account) {
    return {
        id: TeamMember.genId(team.teamId, account),
        account: account,
        teamId: team.teamId,
        type: 'normal',
        nickInTeam: "",
        muteTeam: false,
        mute: false,
        joinTime: team.memberUpdateTime,
        updateTime: team.memberUpdateTime,
        active: true,
        valid: true,
        invitorAccid: ""
    };
};

TeamMember.assembleOwner = function (team) {
    var owner = TeamMember.assembleMember(team, team.owner);
    owner.type = 'owner';
    return owner;
};

module.exports = TeamMember;

/***/ }),

/***/ "./src/im/model/user.js":
/*!******************************!*\
  !*** ./src/im/model/user.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _url = __webpack_require__(/*! utiljs/url */ "./src/util/url.js");

var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");


/**
 * 性别
 *
 * - `'unknown'` (未知)
 * - `'male'` (男)
 * - `'female'` (女)
 *
 * @memberOf User
 * @name gender
 * @readOnly
 * @enum {String}
 */
var genderMap = {
  unknown: 0,
  male: 1,
  female: 2
};
var genderReverseMap = {
  0: 'unknown',
  1: 'male',
  2: 'female'

  /**
   * @constructor
   *
   * @property {String}   account     账号
   * @property {String}   nick        昵称
   * @property {String}   avatar      头像
   * @property {String}   sign        签名
   * @property {String}   gender      {@link User.gender|性别}
   * @property {String}   email       邮箱
   * @property {String}   birth       生日
   * @property {String}   tel         电话号码
   * @property {String}   custom      扩展字段
   * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
   * @property {Long}     createTime  创建时间
   * @property {Long}     updateTime  更新时间
   */
};function User(options) {
  util.merge(this, options);
  if (util.notundef(this.gender)) {
    util.verifyParamValid('gender', this.gender, User.validGenders, 'user::User');
    this.gender = genderMap[this.gender];
  }
  if (util.notundef(this.email) && this.email !== '') {
    util.verifyEmail('email', this.email, 'user::User');
  }
  if (util.notundef(this.birth) && this.birth !== '') {
    util.verifyBirth('birth', this.birth, 'user::User');
  }
  if (util.notundef(this.tel) && this.tel !== '') {
    util.verifyTel('tel', this.tel, 'user::User');
  }
}

User.reverse = function (user) {
  var obj = util.filterObj(user, 'account nick avatar _avatar_safe sign gender email birth tel custom createTime updateTime');
  if (util.notundef(obj.avatar)) {
    obj.avatar = (0, _url.genPrivateUrl)(obj.avatar);
  }
  if (util.notundef(obj.gender)) {
    obj.gender = genderReverseMap[obj.gender];
  }
  if (util.notundef(obj.createTime)) {
    obj.createTime = +obj.createTime;
  }
  if (util.notundef(obj.updateTime)) {
    obj.updateTime = +obj.updateTime;
  }
  return obj;
};

User.reverseUsers = function (users) {
  return users.map(function (user) {
    return User.reverse(user);
  });
};

User.validGenders = Object.keys(genderMap);

module.exports = User;

/***/ }),

/***/ "./src/im/protocol/base/auth.js":
/*!**************************************!*\
  !*** ./src/im/protocol/base/auth.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/base/index.js").fn;
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var platform = __webpack_require__(/*! platform */ "./src/polyfill/weixin-app/platform.js");
var LoginPort = __webpack_require__(/*! im/model/loginPort */ "./src/im/model/loginPort.js");
var device = __webpack_require__(/*! utiljs/device */ "./src/util/device.js");
var config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var notundef = util.notundef;

ProtocolFn.login = function () {
  var self = this;
  Promise.resolve().then(function () {
    return self.assembleLogin();
  }).then(function (options) {
    self.sendCmd('login', (0, _extends3.default)({}, options), self.onLogin.bind(self));
  });

  // 发送完登录包之后重置状态, 如果是重连, 那么在发包过程中会用到此状态位
  self.autoconnect = false;
};

ProtocolFn.genSessionKey = function () {
  var sessions = {};
  return function () {
    var self = this;
    var key = self.name;
    var session = sessions[key] = sessions[key] || util.guid();
    return session;
  };
}();

ProtocolFn.assembleIMLogin = function () {
  var self = this;
  var options = self.options;
  var account = options.account;
  // 是否是 app 发起的登录, 如果是 SDK 发起的登录, 那么属于自动登录, 优先级低
  // 如果此时是PC+WEB互踢模式，且PC在线状态，WEB端调用自动登录会失败并返回417错误码
  var appLogin = self.autoconnect ? 0 : 1;
  self.sdkSession = self.genSessionKey();
  var infos = {
    appLogin: appLogin,
    appKey: options.appKey,
    account: account,
    token: options.token,
    sdkVersion: config.info.sdkVersion,
    protocolVersion: config.info.protocolVersion,
    os: platform.os.toString(),
    browser: platform.name + ' ' + platform.version,
    clientType: config.CLIENTTYPE || 16,
    session: self.sdkSession,
    deviceId: device.deviceId,
    isReactNative: config.isRN ? 1 : 0,
    customTag: options.customTag || ''
  };
  return infos;
};

// 处理登陆返回
ProtocolFn.onLogin = function (error, obj) {
  var self = this;
  self.loginResult = obj;
  if (!error) {
    self.startHeartbeat();
    self.afterLogin(obj);
  } else {
    self.onAuthError(error, 'link::onLogin');
  }
};

ProtocolFn.afterLogin = util.emptyFunc;

// 通知开发者登录成功
// IM 要在打开数据库之后再通知开发者, 那么在 afterLogin 里面就会有三个地方要通知，
// 不能统一放在 syncData 内进行通知，因为可能会同步失败，就会不断调用同步，既调用多次onconnect
// 聊天室在 afterLogin 之后直接通知即可
ProtocolFn.notifyLogin = function () {
  var self = this;
  var obj = self.loginResult;
  self.logger.info('link::notifyLogin: on connect', obj);
  self.options.onconnect(obj);
  // self.getClientAntispamLexicon({
  //   clientAntispam: {
  //     version: 0 // int 词库版本
  //   }
  // })
};

ProtocolFn.logout = function () {
  var msg = 'done disconnect';
  if (this.doLogout) {
    this.doLogout = false;
    msg = 'done logout';
    this.onAuthError(new NIMError(msg, 'logout'), 'link::logout');
    return;
  }
  if (!this.isConnected()) {
    return;
  }
  var error = new NIMError(msg, 'logout');
  this.onAuthError(error, 'link::logout');
  // 主动调用 disconnect, 不用发送 logout 指令
  // self.sendCmd('logout');
};

ProtocolFn.onKicked = function (packet) {
  var self = this;

  var content = packet.content;
  var from = content.from;
  var reason = content.reason;
  var custom = content.custom;

  var kicked = {
    reason: self.kickedReasons[reason] || 'unknown',
    message: self.kickedMessages[reason] || '未知原因'
    // IM 被踢有 from 字段
  };if (notundef(from)) {
    kicked.from = LoginPort.reverseType(from);
  }
  // 聊天室被踢有 custom 字段
  if (notundef(custom)) {
    kicked.custom = custom;
  }

  if (self.shouldNotifyKicked(kicked)) {
    var error = new NIMError('被踢了', 'kicked');
    util.merge(error, kicked);
    self.onAuthError(error, 'link::onKicked');
  } else {
    self.logger.warn('link::onKicked: silentlyKick');
    // 如果不应该通知被踢(IM悄悄被踢), 那么就不应该重连, 同时也不应该通知连接断开
    self.shouldReconnect = true;
    // 假装已经通知过连接断开
    self.hasNotifyDisconnected = true;
    self.disconnectSocket();
  }
};

ProtocolFn.shouldNotifyKicked = function (kicked) {
  // return true
  return kicked.reason !== 'silentlyKick';
};

/*
 * 认证错误, 不需要重连
 * - 主动登出
 * - 登录错误
 * - 被踢
 */
ProtocolFn.onAuthError = function (error, callFunc) {
  var self = this;
  self.shouldReconnect = false;
  error = error || NIMError.newConnectionError({ callFunc: callFunc });
  error.callFunc = error.callFunc || callFunc || null;
  self.markAllCallbackInvalid(error);
  self.notifyDisconnect(error);
};

/***/ }),

/***/ "./src/im/protocol/base/avSignal.js":
/*!******************************************!*\
  !*** ./src/im/protocol/base/avSignal.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/base/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var avSignalUtil = __webpack_require__(/*! ../../model/avSignal */ "./src/im/model/avSignal.js");

/*
  通用独立音视频信令
*/
ProtocolFn.processAvSignal = function (packet) {
  console.log(packet, 'avSignal...');
  switch (packet.cmd) {
    case 'signalingCreate':
      break;
    case 'signalingDelay':
      break;
    case 'signalingClose':
      break;
    case 'signalingJoin':
      break;
    case 'signalingLeave':
      break;
    case 'signalingInvite':
      break;
    case 'signalingCancel':
      break;
    case 'signalingReject':
      break;
    case 'signalingAccept':
      break;
    case 'signalingControl':
      break;
    case 'signalingSyncMsgRead':
      break;
    case 'signalingGetChannelInfo':
      break;
    case 'signalingNotify':
      this.onSignalingNotify(packet);
      break;
    case 'signalingMutilClientSyncNotify':
      this.onSignalingMutilClientSyncNotify(packet);
      break;
    case 'signalingUnreadMessageSyncNotify':
      this.onSignalingUnreadMessageSyncNotify(packet);
      break;
    case 'signalingChannelsSyncNotify':
      this.onSignalingMembersSyncNotify(packet);
      break;
    default:
      this.logger.log('avSignal::unhandled cmd:', packet.cmd);
    // TODO
    // 处理 9103
    // 处理 9102
    // 处理 417 提示已经创建好频道
  }
};

var parseAvSignal = function parseAvSignal() {
  var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (item.needPush) {
    item.needPush = item.needPush === '1';
  }
  if (item.needBadge) {
    item.needBadge = item.needBadge === '1';
  }
  if (item.channelInValid) {
    item.channelInValid = item.channelInValid === '1';
  }
  if (item.attach) {
    var attach = JSON.parse(item.attach);
    item.eventType = avSignalUtil.parseAvSignalType(attach.type);
  }
  if (item.members) {
    var members = JSON.parse(item.members);
    item.members = members.map(function (member) {
      return avSignalUtil.parseAvSignalMember(member);
    });
  }
  return item;
};
/*
  通用独立音视频信令
*/
ProtocolFn.onSignalingNotify = function (packet) {
  if (!packet.error) {
    if (packet.raw && packet.raw.r && packet.raw.r.length && packet.content && packet.content.avSignalTag) {
      packet.content.avSignalTag.msgid = packet.raw.r[0];
    }
    var avSignalTag = packet.content.avSignalTag;

    if (Array.isArray(avSignalTag)) {
      avSignalTag = avSignalTag.map(function (item) {
        return parseAvSignal(item);
      });
    } else {
      avSignalTag = parseAvSignal(avSignalTag);
    }
    this.emitAPI({
      type: 'signalingNotify',
      obj: avSignalTag
    });
    if (util.isFunction(this.options.onSignalingNotify)) {
      this.options.onSignalingNotify(avSignalTag);
    }
  } else {
    var error = packet.error;
    this.logger.error('protocal::avSignal:onSignalingNotify error', error);
    this.emitAPI({
      type: 'error',
      error: error
    });
    this.options.onerror(error);
  }
};
ProtocolFn.onSignalingMutilClientSyncNotify = function (packet) {
  if (!packet.error) {
    this.emitAPI({
      type: 'signalingMutilClientSyncNotify',
      obj: packet.content
    });
    if (util.isFunction(this.options.onSignalingMutilClientSyncNotify)) {
      this.options.onSignalingMutilClientSyncNotify(packet.content);
    }
  } else {
    var error = packet.error;
    this.logger.error('protocal::avSignal:onSignalingMutilClientSyncNotify error', error);
    this.emitAPI({
      type: 'error',
      error: error
    });
    this.options.onerror(error);
  }
};
ProtocolFn.onSignalingUnreadMessageSyncNotify = function (packet) {
  if (!packet.error) {
    var avSignalTag = packet.content.avSignalTag;

    if (Array.isArray(avSignalTag)) {
      avSignalTag = avSignalTag.map(function (item) {
        return parseAvSignal(item);
      });
    }
    this.emitAPI({
      type: 'signalingUnreadMessageSyncNotify',
      obj: avSignalTag
    });
    if (util.isFunction(this.options.onSignalingUnreadMessageSyncNotify)) {
      this.options.onSignalingUnreadMessageSyncNotify(avSignalTag);
    }
  } else {
    var error = packet.error;
    this.logger.error('protocal::avSignal:onSignalingUnreadMessageSyncNotify error', error);
    this.emitAPI({
      type: 'error',
      error: error
    });
    this.options.onerror(error);
  }
};
ProtocolFn.onSignalingMembersSyncNotify = function (packet) {
  if (!packet.error) {
    // let members = packet.content || []
    // members = members.map(member => avSignalUtil.parseAvSignalMember(member))
    var avSignalTag = packet.content.avSignalTag;

    if (!Array.isArray(avSignalTag)) {
      avSignalTag = [avSignalTag];
    }
    avSignalTag = avSignalTag.map(function (item) {
      return parseAvSignal(item);
    });
    this.emitAPI({
      type: 'signalingChannelsSyncNotify',
      obj: avSignalTag
    });
    if (util.isFunction(this.options.onSignalingMembersSyncNotify)) {
      this.options.onSignalingMembersSyncNotify(avSignalTag);
    }
  } else {
    var error = packet.error;
    this.logger.error('protocal::avSignal:onSignalingMembersSyncNotify error', error);
    this.emitAPI({
      type: 'error',
      error: error
    });
    this.options.onerror(error);
  }
};

/***/ }),

/***/ "./src/im/protocol/base/connect.js":
/*!*****************************************!*\
  !*** ./src/im/protocol/base/connect.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/base/index.js").fn;
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");
var io = __webpack_require__(/*! socketio */ "./external/socketio/socket.io.js");
var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

ProtocolFn.initConnect = function () {
  var self = this;

  self.socket = null;

  // 重试连接的次数
  self.retryCount = 0;
  // 是否正在建立连接, 防止重复调用 connect 方法
  self.connecting = false;
  // 是否是第一没有连接上自动重连中，或第一次连接中
  self.initConnecting = false;
  // 是否应该重新建立连接, onAuthError 时不应该重连
  self.shouldReconnect = true;
  // 是否已经通知过连接断开, 确保只通知一次连接断开
  self.hasNotifyDisconnected = false;
  // 是否执行注销
  self.doLogout = false;
};

ProtocolFn.resetConnect = function () {
  var self = this;
  var options = self.options;
  // self.connecting = false;
  // 是否需要重连, 默认 true
  if (util.notundef(options.needReconnect)) {
    util.verifyParamType('needReconnect', options.needReconnect, 'boolean', 'link::resetConnect');
    self.needReconnect = options.needReconnect;
  } else {
    self.needReconnect = true;
  }
  self.logger.log('link::resetConnect: needReconnect ' + self.needReconnect);
  // 重连的最大次数, 默认 Infinity
  if (util.notundef(options.reconnectionAttempts)) {
    util.verifyParamType('reconnectionAttempts', options.reconnectionAttempts, 'number', 'link::resetConnect');
  }
  if (util.notundef(options.noCacheLinkUrl)) {
    util.verifyParamType('noCacheLinkUrl', options.noCacheLinkUrl, 'boolean', 'link::resetConnect');
  }
  self.reconnectionAttempts = typeof options.reconnectionAttempts === 'number' ? options.reconnectionAttempts : Infinity;
  // 时间退化
  self.backoff = new Backoff({
    // 重连间隔和最大间隔
    min: Config.reconnectionDelay,
    max: Config.reconnectionDelayMax,
    jitter: Config.reconnectionJitter
  });
};

ProtocolFn.connect = function (manualTrigger) {
  var self = this;
  // 如果是用户主动触发连接
  if (manualTrigger) {
    // 如果是用户手动调用connect，并且当前还在进行初始化的重连则提示正在连接
    if (self.initConnecting) {
      self.logger.warn('link::connect: already init connecting');
      return;
    } else {
      // 否则清空自动重连定时器避免重复连接导致悄悄被踢
      clearTimeout(self.reconnectTimer);
    }
  }
  // 防止重复建立连接
  if (self.isConnected()) {
    self.logger.warn('link::connect: already connected');
    return;
  }
  if (self.connecting) {
    self.logger.warn('link::connect: already connecting');
    return;
  }
  self.connecting = true;
  self.hasNotifyDisconnected = false;

  if (!self.socket || !(self.socket && self.socket.socket)) {

    if (self.options.socketUrl && typeof self.options.socketUrl === 'string') {
      self.connectToUrl(self.options.socketUrl);
    } else {
      // 如果有 url, 那么连此 url, 否则刷新 url
      var url = self.getNextSocketUrl();
      if (url && !self.options.noCacheLinkUrl) {
        self.connectToUrl(url);
      } else {
        self.refreshSocketUrl();
      }
    }
  } else {
    self.logger.info('link::connect: try connecting...');
    self.socket.socket.connect();
  }
};

ProtocolFn.getNextSocketUrl = function () {
  return this.socketUrls.shift();
};

ProtocolFn.isConnected = function () {
  var self = this;
  return !!self.socket && !!self.socket.socket && self.socket.socket.connected;
};

ProtocolFn.connectToUrl = function (url) {
  var self = this;
  url = url || '';
  self.logger.log('link::connectToUrl: ' + url);
  // shim code for weixin app, location 对象可能没有
  if (typeof window === 'undefined') {
    var root = util.getGlobal();
    var arr = url.split(':');
    if (root && !root.location && arr.length > 1) {
      root.location = {
        protocol: arr[0],
        hostname: arr[1].slice(2),
        port: arr[2]
      };
    }
    this.options.transports = ['websocket'];
  }
  var transports = this.options.transports || ['websocket', 'xhr-polling'];
  // if (Config.isWeixinApp || Config.isNodejs) {
  //   transports = ['websocket']
  // }
  // !!! 为了支持手动断开连接, 没有自动重连
  // 不要自动重连, 否则主动退出会引起自动重连
  // 在非人为退出时（网络自己断了）, 调用 connect 来模拟自动重连
  self.socket = io.connect(url, {
    // secure: true,                            // secure 会自动设置
    // transports: ["websocket", "xhr-polling", "flashsocket"],
    transports: transports,
    reconnect: false, // 不自动重连, 手动重连
    'force new connection': true, // 当url不变时, 强制重新建立连接
    'connect timeout': Config.connectTimeout // 连接超时时间
  });
  self.logger.info('link::connectToUrl: socket url: ' + url + ', transports: ' + JSON.stringify(transports));
  self.socket.on('connect', self.onConnect.bind(self));
  self.socket.on('handshake_failed', self.onHandshakeFailed.bind(self));
  self.socket.on('connect_failed', self.onConnectFailed.bind(self));
  self.socket.on('error', self.onError.bind(self));
  self.socket.on('message', self.onMessage.bind(self));
  self.socket.on('disconnect', function (obj) {
    self.logger.warn('link::connectToUrl: socket url: ' + url + ', disconnected');
    if (self.doLogout) {
      self.logout();
    } else {
      self.onDisconnect(true, 'link::socketDisconnect');
    }
  });
};

ProtocolFn.disconnect = function (fn) {
  var self = this;
  if (!(fn instanceof Function)) {
    fn = function fn() {};
  }
  clearTimeout(self.connectTimer);
  self.disconnectCallbackTimer = setTimeout(function () {
    fn.call(self, 'mark disconnected due to timeout');
  }, 10000);
  function onDisconnect(err) {
    self.logger.info('link::disconnect: socket finally closed, ', err);
    clearTimeout(self.disconnectCallbackTimer);
    fn(err);
  }
  if (self.socket && self.socket.socket && self.socket.socket.transport) {
    self.socket.socket.transport.onDisconnectDone = function (err) {
      onDisconnect(err);
    };
  } else {
    onDisconnect(null);
  }
  if (self.isConnected()) {
    self.logger.log('link::disconnect: start disconnecting');
    self.logout();
  } else if (self.connecting) {
    self.logger.log('link::disconnect: abort connecting');
    // self.shouldReconnect = false
    // self.needReconnect = false
    // self.connecting = false
    self.disconnectSocket();
  } else {
    self.logger.log('link::disconnect: start otherwise');
    self.connecting = false;
    self.shouldReconnect = false;
    self.needReconnect = false;
    self.options.ondisconnect({
      callFunc: 'link::disconnect',
      message: 'manually disconnect status'
    });
  }
};

// 连接上
ProtocolFn.onConnect = function () {
  var self = this;
  if (self.backoff) {
    self.backoff.reset();
  }
  self.reconnectStatus = self.retryCount > 0 ? 1 : 0;
  self.retryCount = 0;
  self.connecting = false;
  self.initConnecting = false;
  self.shouldReconnect = true;
  self.hasNotifyDisconnected = false;
  self.logger.log('link::onConnect: socket onconnected, start login');
  self.login();

  self.api.reportLogs({
    event: 'ws_connected'
  });
};

// 握手失败, 改造了一下 socketio, 在握手失败的时候触发此回调
// self.publish('handshake_failed');
ProtocolFn.onHandshakeFailed = function () {
  // this.logger.warn(`link::onHandshakeFailed: shandshake failed`)
  this.api.reportLogs({
    event: 'ws_handshake_failed'
  });
  this.onDisconnect(false, 'link::onHandshakeFailed');
};

ProtocolFn.onConnectFailed = function () {
  this.api.reportLogs({
    event: 'ws_connect_failed'
  });
  this.onDisconnect(false, 'link::onConnectFailed');
};

// 错误
ProtocolFn.onError = function () {
  var reason = arguments[0];
  if (reason) {
    this.api.reportLogs({
      event: 'connect_timeout'
    });
    // 华为荣耀9诡异错误
    if (typeof reason.x5ImgDecodeStatus !== 'undefined') {
      return;
    } else if (Object.prototype.toString.call(reason) === '[object Object]' && Object.keys(reason).length <= 0) {
      return;
    }
    this.onMiscError('连接错误', new NIMError(reason, 'LINK_ERROR', {
      callFunc: 'link::onError'
    }));
  }
  this.connecting = false;
};

// 参数 connected 表示是否是连上之后再断开连接的
// 如果是 connected, 那么接下来的自动重连算自动登录, 优先级低
// 而如果不是, 说明一开始就没有连接上, 那么接下来的自动重连不算自动登录, 优先级高
ProtocolFn.onDisconnect = function () {
  var connected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var callFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var self = this;
  self.connected = connected;
  self.connecting = false;
  self.markAllCallbackInvalid(NIMError.newNetworkError({ callFunc: callFunc }));
  self.stopHeartbeat();
  self.reconnect();
};

ProtocolFn.willReconnect = function () {
  var self = this;
  return self.shouldReconnect && self.needReconnect && self.retryCount < self.reconnectionAttempts;
};

/*
 * 重新建立连接
 * - 如果不会再重新建立连接, 那么不再重新连接。
 *     - 主动退出
 *     - 登录错误
 *     - 被踢
 * - 否则
 *     - 如果还有可用地址, 那么尝试下一个地址；
 *     - 如果没有可用地址, 但是lbs重试次数还没达到上限, 那么重试lbs；
 * - 如果既没有可用地址, 重试次数也达到上限, 那么不再重新连接。
 * IE 9/8 只会重连一次, 请参考 https://github.com/Automattic/socket.io/issues/1020#issuecomment-9684494
 */

ProtocolFn.reconnect = function () {
  var self = this;
  if (self.willReconnect()) {
    if (self.socket && self.socket.socket && self.socket.socket.transport && self.socket.socket.transport.websocket) {
      self.logger.info('link::reconnect: on socket closed');
      self.socket.socket.transport.onConnectionOver = function () {
        self.logger.log('link::reconnect: on connectionOver');
        clearTimeout(self.reconnectTimer);
        self.doReconnect();
      };
      try {
        // self.socket.disconnect()
        self.socket.socket.transport.websocket.close();
      } catch (error) {
        self.logger.warn('link::reconnect: force disconnect error:', error);
      }
    } else {
      clearTimeout(self.reconnectTimer);
      self.reconnectTimer = setTimeout(function () {
        self.logger.info('link::reconnect: on socket timeout');
        self.doReconnect();
      }, 30000);
    }
  } else {
    self.notifyDisconnect();
  }
};

// 处理小程序只有一条socket，必须前一条断掉才能重连的问题
ProtocolFn.doReconnect = function () {
  var self = this;
  self.socket = null;
  if (self.connected) {
    self.autoconnect = true;
  }
  self.retryCount++;
  self.appLogin = 1;
  var duration = self.backoff.duration();
  self.logger.info('link::reconnect: will retry after ' + duration + 'ms, retryCount ' + self.retryCount);
  self.options.onwillreconnect({
    retryCount: self.retryCount,
    duration: duration
  });
  clearTimeout(self.connectTimer);
  self.connectTimer = setTimeout(function () {
    self.connect();
  }, duration);
};

ProtocolFn.notifyConnectError = function (message) {
  var self = this;
  var error = NIMError.newConnectError({
    message: message,
    callFunc: 'link::notifyConnectError'
  });
  self.logger.error('link::notifyConnectError:', error);
  self.options.onerror(error);
};

// 通知开发者连接断开
ProtocolFn.notifyDisconnect = function (error) {
  var self = this;
  if (!self.hasNotifyDisconnected) {
    self.hasNotifyDisconnected = true;
    // 保证断开连接
    self.disconnectSocket();
    // 外传对象
    error = error || new NIMError();
    error.retryCount = self.retryCount;
    error.willReconnect = self.willReconnect();
    // 重置
    if (self.backoff) {
      self.backoff.reset();
    }
    self.retryCount = 0;
    // self.connecting = false
    // 通知
    if (self.socket && self.socket.socket && self.socket.socket.transport && self.socket.socket.transport.websocket) {
      self.logger.info('link::notifyDisconnect: ondisconnected', error);
      self.socket.socket.transport.onConnectionOver = function () {
        self.socket = null;
        self.options.ondisconnect(error);
      };
    } else {
      self.logger.info('link::notifyDisconnect: ondisconnected/no transport ws', error);
      self.options.ondisconnect(error);
    }
    // 主动断开连接或者被踢，均需要通知白板或音视频
    if (self.onWbNotifyHangup instanceof Function) {
      self.onWbNotifyHangup({
        content: {
          account: self.account,
          channelId: null,
          timetag: +Date()
        }
      });
    }
    // if (self.onNotifyHangup instanceof Function) {
    //   self.onNotifyHangup({
    //     content: {
    //       account: self.account,
    //       channelId: null,
    //       timetag: +Date()
    //     }
    //   })
    // }
  }
};

// 断开 socket 链接
ProtocolFn.disconnectSocket = function () {
  var self = this;
  if (self.isConnected() || self.connecting) {
    try {
      // 这里将 shouldReconnect置为false，防止切换下一次transport
      self.connecting = false;
      self.shouldReconnect = false;
      self.needReconnect = false;
      self.socket.disconnect();
      // 这里将 socket 置空, 否则下次 connect 的时候会切换下一次 transport
      // self.socket = null
    } catch (error) {
      // ignore error
      self.logger.info('link::disconnectSocket: disconnect failed, error ', error);
    }
  }
};

/***/ }),

/***/ "./src/im/protocol/base/index.js":
/*!***************************************!*\
  !*** ./src/im/protocol/base/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");

function Protocol(options) {
  var self = this;
  if (util.undef(options.secure)) {
    options.secure = true;
  }
  self.options = util.copy(options);
  self.keepNosSafeUrl = self.options.keepNosSafeUrl || false; // 是否保持nos安全短链——sdk拿到nos安全短链数据不做自动替换
  if (util.notundef(options.defaultLinkUrl) && util.isString(options.defaultLinkUrl)) {
    config.optionDefaultLinkUrl = self.options.defaultLinkUrl.trim(); // 当lbs地址取不到link地址的时候，默认连接的link地址
  } else {
    config.optionDefaultLinkUrl = '';
  }
  self.init();
  self.connect();
  self.initConnecting = true;
}

var ProtocolFn = Protocol.fn = Protocol.prototype;

// 只有第一次初始化的时候才会被调用
ProtocolFn.init = function () {
  var self = this;
  self.logger = self.options.logger;
  // 记录初始化的时候，请求NOS源链的次数，用于判断是否可以调用syncDone回调
  self.getNosOriginUrlReqNum = 0;
  // 判断 ”请求NOS源链的次数为0“ 的次数，避免请求超时长时间不回调
  self.checkNosReqNum = 0;
  // 存储所有的命令，会在发送一条命令之后再异步发送下一条命令
  self.cmdTaskArray = [];
  // 存储 cmd 对应的 timer, 收到 ack 之后会从此 map 中删除
  self.timerMap = {};
  // 存储 cmd 对应的 callback, 收到 ack 或 timeout 之后会从此 map 中删除
  self.cmdCallbackMap = {};
  // 存储 cmd 对应的 content, 收到 ack 或 timeout 之后会从此 map 中删除
  self.cmdContentMap = {};

  self.initConnect();

  self.reset();
};

// 后续重复获取同一份实例会调用 setOptions, 最终会调用 reset
// 所有跟 options 相关的参数都要能 reset
ProtocolFn.reset = function () {
  var self = this;
  self.resetConnect();
};

ProtocolFn.setOptions = function (newOptions) {
  var self = this;
  var oldOptions = self.options;
  var keys = Object.keys(oldOptions);
  var index = keys.indexOf('account');
  if (index !== -1) {
    keys.splice(index, 1);
  }
  newOptions = util.filterObj(newOptions, keys);
  self.options = util.merge(oldOptions, newOptions);

  self.reset();
};

/**
 * 发送消息到服务器
 *
 * @private
 * @param  {Object} options 配置参数
 * @property {String}   cmd       命令名称
 * @property {Map}      content   命令内容
 * @property {Function} callback  回调函数
 * @return {Number}         cmd序列号
 */
ProtocolFn.sendCmd = function (cmd) {
  var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var callback = arguments[2];

  var self = this;
  self.heartbeat();
  if (cmd !== 'heartbeat') {
    self.logger.warn('protocol::sendCmd: ' + cmd, content);
  }

  var cmdName = cmd;
  cmd = self.parser.createCmd(cmd, content);

  var ser = cmd.SER;
  var keys;
  // 如果没有content, 那么分配一个, 然后存储content
  content = content || {};
  self.cmdContentMap[ser] = content;
  // 如果只有一个参数
  if (content.single) {
    delete content.single;
    keys = Object.keys(content);
    if (keys.length === 1) {
      self.cmdContentMap[ser] = content[keys[0]];
    }
  }
  // 删掉不存储的参数
  if (content.NOTSTORE) {
    keys = content.NOTSTORE.split(' ');
    keys.forEach(function (key) {
      delete content[key];
    });
    delete content.NOTSTORE;
  }
  // 存储 callback
  callback = callback || content.callback;
  if (callback) {
    self.cmdCallbackMap[ser] = callback;
  }
  // 存储命令
  // console.warn('9999999', JSON.stringify(cmd))
  // iphone 6s/6sp push以后，cmd内会莫名奇妙补数据0:null,7:null...，需要序列号一下
  self.cmdTaskArray.push({
    cmdName: cmdName,
    cmd: JSON.stringify(cmd)
  });
  // console.warn('0000000', JSON.stringify(cmd));
  // 启动命令 timer
  self.startCmdTaskTimer();
};

// 启动任务 timer，异步取出一个任务，执行之，然后再次启动任务 timer
// 异步的目的是为了让出线程执行时间，这样就算外界循环调用，也不会阻塞线程的执行
ProtocolFn.startCmdTaskTimer = function () {
  var self = this;
  if (!self.cmdTaskTimer) {
    self.cmdTaskTimer = setTimeout(function () {
      var cmdTask = self.cmdTaskArray.shift();
      self.cmdTaskTimer = null;
      if (cmdTask) {
        self.executeCmdTask(cmdTask);
      }
      if (self.cmdTaskArray.length) {
        self.startCmdTaskTimer();
      }
    }, 0);
  }
};

// 执行任务
ProtocolFn.executeCmdTask = function (cmdTask) {
  var self = this;
  var cmdName = cmdTask.cmdName;
  var cmd = cmdTask.cmd;
  // console.warn('33333333333', cmd)
  cmd = JSON.parse(cmd);
  var ser = cmd.SER;
  if (self.isFrequencyControlled(cmdName)) {
    self.logger.warn('protocol::executeCmdTask: ' + cmdName + ' hit freq control');
    self.markCallbackInvalid(ser, NIMError.newFrequencyControlError({
      callFunc: 'protocol::executeCmdTask',
      message: cmdName + ' hit freq control'
    }));
  } else if (!self.isConnected()) {
    self.logger.warn('protocol::executeCmdTask: ' + cmdName + ' not connected');
    self.markCallbackInvalid(ser, NIMError.newSocketStateError({
      callFunc: 'protocol::executeCmdTask',
      message: cmdName + ' not connected'
    }));
  } else {
    if (cmdName !== 'heartbeat') {
      self.logger.log('protocol::sendCmd: ' + cmdName + ' ' + JSON.stringify(cmd));
    }
    self.doSendCmd(cmd);
  }
};

// 检查是否被频控了
// 重新登录的话，服务器的频控会重置
ProtocolFn.isFrequencyControlled = function (cmdName) {
  var config = this.frequencyControlMap && this.frequencyControlMap[cmdName];
  if (config) {
    if (Date.now() < config.from + config.duration) {
      return true;
    } else {
      delete this.frequencyControlMap[cmdName];
    }
  }
};

// 调用 socket 发送命令
ProtocolFn.doSendCmd = function (cmd) {
  var self = this;
  var ser = cmd.SER;
  // 存储超时
  self.timerMap[ser] = setTimeout(function () {
    self.markCallbackInvalid(ser, NIMError.newTimeoutError({
      callFunc: 'protocol::doSendCmd',
      message: 'ser ' + ser + ' Timeout Error'
    }));
  }, config.cmdTimeout);
  function sendFailed() {
    self.markCallbackInvalid(ser, NIMError.newSocketStateError({
      callFunc: 'protocol::doSendCmd',
      message: 'ser ' + ser + ' socketSendJson Error'
    }));
    self.onDisconnect(true, 'protocol::doSendCmd:socketSendJson');
  }
  // 发送命令
  try {
    if (self.socket && self.socket.send) {
      self.socket.send(JSON.stringify(cmd));
    } else {
      sendFailed();
    }
  } catch (e) {
    sendFailed();
  }
};

// 获取 ser 对应的 obj
ProtocolFn.getObjWithSer = function (ser) {
  var self = this;
  var obj = self.cmdContentMap[ser];
  // 当是同步数据 syncData 的参数时，因为会有多个同样 ser 的回包，并且 obj 上记录了 isImSyncDataObj 值，所以不做删除 obj 操作
  if (obj && !obj.isImSyncDataObj) {
    delete self.cmdContentMap[ser];
  }
  // 如果 obj 存在, 那么返回其拷贝; 如果不存在, 那么直接返回, 即返回 undefined
  // 请参考 IMProtocolFn.packetFromSync
  return obj && util.copy(obj);
};

// 获取 ser 对应的 callback
ProtocolFn.getCallbackWithSer = function (ser) {
  var self = this;
  var callback = self.cmdCallbackMap[ser];
  // IM sdk 同步需要调用多次回调，此处不做删除，在收到最后一个 ser 对应的 5_1 时删除
  if (callback && !callback.isImSyncDataCb) {
    delete self.cmdCallbackMap[ser];
  }
  return callback;
};

// 获取 ser 对应的 timer
ProtocolFn.getTimerWithSer = function (ser) {
  var self = this;
  var timer = self.timerMap[ser];
  delete self.timerMap[ser];
  return timer;
};

// 清除 ser 对应的 timer
ProtocolFn.clearTimerWithSer = function (ser) {
  var self = this;
  var timer = self.getTimerWithSer(ser);
  if (timer) {
    clearTimeout(timer);
  }
};

// 使 ser 对应的 callback 失效
ProtocolFn.markCallbackInvalid = function (ser, error) {
  var self = this;
  // 删除 obj
  self.getObjWithSer(ser);
  // 清除 timer
  self.clearTimerWithSer(ser);
  var callback = self.getCallbackWithSer(ser);
  if (callback) {
    var content = callback.options;
    // 异步回调
    setTimeout(function () {
      callback(error || NIMError.newUnknownError({ ser: ser }), content);
    }, 0);
  }
};

/**
 * 使所有回调失效
 */
// callFunc 放在error里
ProtocolFn.markAllCallbackInvalid = function (error) {
  var self = this;
  Object.keys(this.cmdCallbackMap).forEach(function (ser) {
    self.markCallbackInvalid(ser, error);
  });
};

// 获取packet关联的content
ProtocolFn.getPacketObj = function (packet) {
  var result = null;
  if (packet) {
    if (packet.raw) {
      var ser = packet.raw.ser;
      if (util.notundef(ser)) {
        result = this.getObjWithSer(ser);
      }
    }
  }
  return result;
};

// 调用回包确认回调函数
ProtocolFn.callPacketAckCallback = function (packet) {
  var self = this;
  if (!!packet && !!packet.raw) {
    var ser = packet.raw.ser;
    if (util.notundef(ser)) {
      self.clearTimerWithSer(ser);
      var callback = self.getCallbackWithSer(ser);
      if (callback) {
        // 处理自己发出的nos短链源链， keepNosSafeUrl 在设置的时候做过校验，此处不必再校验
        if (callback.originUrl && packet.obj && packet.obj.file) {
          packet.obj.file._url_safe = packet.obj.file.url;
          packet.obj.file.url = callback.originUrl;
          if (packet.obj.type === 'audio') {
            packet.obj.file.mp3Url = callback.originUrl + (~callback.originUrl.indexOf('?') ? '&' : '?') + 'audioTrans&type=mp3';
          }
        }
        if (packet.promise) {
          packet.promise.then(function () {
            callback(packet.error, packet.obj);
          }, function (event) {
            event.callFunc = 'protocol::callPacketAckCallback';
            event.message = 'Resp Promoise Error: cmd: ' + packet.cmd + ', ser: ' + ser;
            var error = NIMError.customError('CALLBACK_ACK_ERR', event);
            self.logger.error('protocol::callPacketAckCallback: promise error ' + JSON.stringify(event));
            callback(error, packet.obj, packet.content);
          });
        } else {
          // 第二个参数是自己发的再带回来，第三个参数为服务器发的
          callback(packet.error, packet.obj, packet.content);
        }
      }
    }
  }
};

/**
 * 接收到服务端的消息
 *
 * @private
 * @param {String} data 包数据
 * @return {Void}
 */
ProtocolFn.onMessage = function (data) {
  var self = this;
  self.heartbeat();
  self.parser.parseResponse(data).then(function (packet) {
    // 找不到协议
    if (packet.notFound) {
      self.logger.warn('protocol::onMessage: packet not found ' + JSON.stringify(packet));
    }

    if (packet.error) {
      packet.error.message = packet.cmd + ' error: ' + packet.error.message;
      self.logger.error('protocol::onMessage: packet error ' + JSON.stringify(packet.error));
    } else if (!packet.content && packet.cmd !== 'heartbeat') {
      // 1_2为心跳包
      self.logger.warn('protocol::onMessage: packet.content undefined ' + JSON.stringify(packet));
    }
    // 如果被频控，那么记录当前时间和频控时长
    if (packet.frequencyControlDuration) {
      self.logger.error('protocol::onMessage: server freq control ' + JSON.stringify(packet.cmd));
      self.frequencyControlMap = self.frequencyControlMap || {};
      self.frequencyControlMap[packet.cmd] = {
        from: +new Date(),
        duration: packet.frequencyControlDuration
      };
    }
    // 获取之前存储的对象, by CS
    packet.obj = self.getPacketObj(packet);
    if (packet.cmd !== 'heartbeat' && packet.cmd !== 'getClientAntispam') {
      self.logger.log('protocol::recvCmd: ' + packet.cmd + ' ' + packet.rawStr);
    }
    var method = 'process' + util.capFirstLetter(packet.service);
    // 如果没有找到对应的服务, 那么不作处理直接返回
    if (self[method]) {
      if (packet.cmd !== 'heartbeat') {
        self.logger.warn('protocol::recvCmd: ' + packet.cmd + ' ' + method, packet.content);
      }
      // 有两种同步命令: IM sdk、音视频独立信令; 第一种需要调用 processSync 回调，第二种不需要
      if (packet.cmd === 'syncDone') {
        if (self.cmdCallbackMap[packet.raw.ser] && self.cmdCallbackMap[packet.raw.ser].isImSyncDataCb) {
          // 由于 IM 同步数据回调需要多次使用，有在公共方法判断 isImSyncDataCb 为真时不删除，这里最后一次使用置否后可删除
          self.cmdCallbackMap[packet.raw.ser].isImSyncDataCb = false;
          var checkNosReqDone = function (method, packet) {
            this.checkNosReqNum++;
            // 这里判断 6-22 同步数据的源链替换是否已经全部完成；或者等待时间太长超过3s先同步成功
            if (this.getNosOriginUrlReqNum <= 0 || this.checkNosReqNum >= 10) {
              this[method](packet);
              return;
            }
            setTimeout(checkNosReqDone, 300);
          }.bind(self, method, packet);
          checkNosReqDone.call(self, method, packet);
        }
      } else {
        self[method](packet);
      }
    } else {
      self.logger.warn('protocol::onMessage: ' + method + ' not found');
    }
    self.callPacketAckCallback(packet);
  });
};

/*
 * 各种各样的错误
 * - 同步
 * - 同步群成员
 * - 心跳
 */
// error: { callFunc, message}
ProtocolFn.onMiscError = function (message, error, obj) {
  if (error) {
    this.notifyError(message, error, obj);
  }
};

// 自定义错误通知
ProtocolFn.onCustomError = function (code, event) {
  var error = NIMError.customError(code, event);
  var message = event.message || '未知错误';
  this.onMiscError(message, error);
};

// 只有当建立连接之后才通知错误, 断开连接之后不通知错误
ProtocolFn.notifyError = function (message, error, obj) {
  var self = this;
  if (self.isConnected()) {
    self.logger.error((message || '') + ' ' + self.name, error, obj);
    self.options.onerror(error, obj);
  }
};

ProtocolFn.emitAPI = function (_ref) {
  var type = _ref.type,
      obj = _ref.obj;

  this.api.emit(type, obj);
};

module.exports = Protocol;

__webpack_require__(/*! ./connect */ "./src/im/protocol/base/connect.js");
__webpack_require__(/*! ./auth */ "./src/im/protocol/base/auth.js");
__webpack_require__(/*! ./link */ "./src/im/protocol/base/link.js");
__webpack_require__(/*! ./misc */ "./src/im/protocol/base/misc.js");
__webpack_require__(/*! ./avSignal */ "./src/im/protocol/base/avSignal.js");

/***/ }),

/***/ "./src/im/protocol/base/link.js":
/*!**************************************!*\
  !*** ./src/im/protocol/base/link.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/base/index.js").fn;
var config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");

ProtocolFn.processLink = function (packet) {
  switch (packet.cmd) {
    case 'heartbeat':
      break;
    default:
      break;
  }
};

// // 登录成功之后开始心跳
// ProtocolFn.startHeartbeat = function() {
//     this.shouldHeartbeat = true
// };
//
// // 断开链接后停止心跳
// ProtocolFn.stopHeartbeat = function() {
//     this.shouldHeartbeat = false
// };
//
// // 在收到消息之后和发出指令之后, 调用此方法来在 heartbeatInterval 之后发送心跳包发送心跳包
// ProtocolFn.heartbeat = function () {
//     var self = this;
//     // 清除上一次的计时器
//     if (!!self.heartbeatTimer) {
//         clearTimeout(self.heartbeatTimer);
//     }
//     // 设置新的计时器
//     self.heartbeatTimer = setTimeout(function() {
//         if (self.shouldHeartbeat) {
//             self.sendCmd('heartbeat', null, self.onHeartbeat.bind(self));
//         }
//     }, config.heartbeatInterval);
// }

// WTF: 服务器只认心跳包, 所以必须一直发, 那么还是改成每隔一段时间发一个心跳包
ProtocolFn.startHeartbeat = function () {
  var self = this;
  self.stopHeartbeat();
  self.heartbeatTimer = setTimeout(function () {
    self.sendCmd('heartbeat', null, self.onHeartbeat.bind(self));
  }, config.heartbeatInterval);
};

ProtocolFn.stopHeartbeat = function () {
  var self = this;
  if (self.heartbeatTimer) {
    clearTimeout(self.heartbeatTimer);
    self.heartbeatTimer = null;
  }
};

ProtocolFn.onHeartbeat = function (error, obj) {
  var self = this;
  if (!error) {
    self.startHeartbeat();
  } else {
    error.callFunc = 'link::onHeartbeat';
    self.api.reportLogs({
      event: 'ping_timeout'
    });
    self.onCustomError('heartbeat error', 'HEARTBEAT_ERROR', error);
  }
};

ProtocolFn.heartbeat = function () {};

/***/ }),

/***/ "./src/im/protocol/base/misc.js":
/*!**************************************!*\
  !*** ./src/im/protocol/base/misc.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/base/index.js").fn;
var ImageOp = __webpack_require__(/*! im/model/ImageOp */ "./src/im/model/ImageOp.js");

ProtocolFn.processMisc = function (packet) {
  switch (packet.cmd) {
    // 获取nos上传凭证
    case 'getSimpleNosToken':
      if (!packet.error) {
        packet.obj = packet.content.nosTokens[0];
      }
      break;
    case 'getNosToken':
      if (!packet.error) {
        packet.obj = packet.content.nosToken;
      }
      break;
    case 'notifyUploadLog':
      if (!packet.error) {
        this.emitAPI({
          type: 'notifyUploadLog'
        });
      }
      break;
    case 'audioToText':
      if (!packet.error) {
        packet.obj.text = packet.content.text;
      }
      break;
    case 'processImage':
      packet.obj.imageOps = ImageOp.reverseImageOps(packet.obj.imageOps);
      if (!packet.error) {
        packet.obj = {
          url: packet.content.url
        };
      }
      break;
    case 'getNosTokenTrans':
      if (!packet.error) {
        packet.obj = {
          nosToken: packet.content.nosToken,
          docId: packet.content.docId
        };
      }
      break;
    case 'getNosOriginUrl':
      if (!packet.error) {
        packet.obj = packet.content.nosFileUrlTag.originUrl;
      }
      break;
    case 'notifyTransLog':
      if (!packet.error) {
        this.emitAPI({
          type: 'notifyTransLog',
          obj: packet.content.transInfo
        });
      }
      break;
    case 'fetchFile':
      if (!packet.error) {
        packet.obj = packet.content;
      }
      break;
    case 'fetchFileList':
      if (!packet.error) {
        packet.obj = packet.content;
      }
      break;
    case 'removeFile':
      if (!packet.error) {
        packet.obj = packet.content;
      }
      break;
    default:
      break;
  }
};

// // 获取反垃圾词库 http://doc.hz.netease.com/pages/viewpage.action?pageId=107203234
// // getClientAntispamLexicon({
// //   clientAntispam: {
// //     version: 0, // int 词库版本
// //   }
// // })

// // version(1),     //int 词库版本
// // md5(2),         //string 词库文件的md5
// // nosurl(3),      //string 词库文件的下载地址
// // thesaurus(4),   //string 词库内容，解决web sdk跨域问题

// ProtocolFn.getClientAntispamLexicon = function (options) {
//   var self = this
//   return this.sendCmd('getClientAntispam', options, (error, obj, content) => {
//     if (error) {
//       self.logger.error('misc::getClientAntispamLexicon:', error)
//     } else {
//       self.antispamLexicon = content.clientAntispam || {}
//     }
//   })
// }

// // 客户端反垃圾，词库获取函数为 getClientAntispamLexicon，在auth完成后执行
// ProtocolFn.filterClientAntispam = function (msg) {
//   let thesaurus = this.antispamLexicon && this.antispamLexicon.thesaurus
//   if (!thesaurus) {
//     return
//   }
//   try {
//     thesaurus = JSON.parse(thesaurus).thesaurus
//   } catch (error) {
//     this.logger.error('misc::filterClientAntispam: parse thesaurus error')
//     return
//   }
//   const body = msg.text
//   if (!body) {
//     return
//   }
//   let cnt = body
//   for (let i = 0; i < thesaurus.length; i++) {
//     cnt = filterContent.call(this, cnt, thesaurus[i])
//     if (typeof cnt === 'object') {
//       if (cnt.code === 2) {
//         // 拒绝发送
//         msg.status = 'fail'
//         msg.failReason = 'sensitive words'
//         return
//       } else if (cnt.code === 3) {
//         // 服务器处理（命中客户端反垃圾，交给服务器处理）,消息Property需要带上TalkMsgTag.clientAntiSpam
//         msg.clientAntiSpam = 1
//         return
//       }
//     } else {
//     }
//   }
//   msg.text = cnt
// }

// function matchContent (cnt, keyword, matchType, operateType) {
//   let isMatched = false
//   let regWord = ''
//   if (matchType === 1) {
//     // 1: 关键词匹配
//     if (cnt.indexOf(keyword) >= 0) {
//       isMatched = true
//       regWord = keyword
//     }
//   } else if (matchType === 2) {
//     // 2: 正则表达式匹配
//     regWord = new RegExp(keyword, 'g')
//     if (regWord.test(cnt)) {
//       isMatched = true
//     }
//   }
//   if (isMatched && regWord !== '') {
//     switch (operateType) {
//       // 1：替换
//       case 1:
//         return cnt.replace(regWord, '*')
//       // 2：拒绝发送
//       case 2:
//         return { code: 2 }
//       // 3：服务器处理（命中客户端反垃圾，交给服务器处理）,消息Property需要带上TalkMsgTag.clientAntiSpam
//       case 3:
//         return { code: 3 }
//     }
//   }
//   return cnt
// }

// function filterContent (body, thesaurus) {
//   var self = this
//   const match = thesaurus.match
//   const operate = thesaurus.operate
//   let cnt = body
//   for (let i = 0; i < thesaurus.keys.length; i++) {
//     const item = thesaurus.keys[i]
//     const matchType = item.match || match
//     const operateType = item.operate || operate
//     try {
//       cnt = matchContent(cnt, item.key, matchType, operateType)
//       if (typeof cnt === 'object') {
//         return cnt
//       }
//     } catch (error) {
//       // 有些正则表达式web不支持
//       self.logger.warn(
//         'misc::filterContent: js cannot parse this regexp ',
//         error
//       )
//     }
//   }
//   return cnt
// }

/***/ }),

/***/ "./src/im/protocol/im/auth.js":
/*!************************************!*\
  !*** ./src/im/protocol/im/auth.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var LoginPort = __webpack_require__(/*! im/model/loginPort */ "./src/im/model/loginPort.js");

IMProtocolFn.assembleLogin = function () {
  var self = this;
  var login = self.assembleIMLogin();
  if (self.addPushInfo instanceof Function) {
    return self.addPushInfo(login);
  } else {
    return Promise.resolve({ login: login });
  }
};

// 登录之后打开数据库
IMProtocolFn.afterLogin = function () {
  var _this = this;

  if (this.initPush instanceof Function) {
    this.initPush();
  }
  var db = this.db;
  if (db.enable) {
    var name = this.account;
    if (this.options.appendAppKeyForDBName) {
      name += '-' + this.options.appKey;
    }
    this.db.init(name).then(function () {
      _this.notifyLogin();
      _this.syncData();
    }, function (error) {
      _this.logger.warn('link::afterLogin: no db', error);
      db.reset(false);
      _this.notifyLogin();
      _this.syncData();
    });
  } else {
    this.logger.info('link::afterLogin: no db');
    this.notifyLogin();
    this.syncData();
  }
};

// 处理认证协议
IMProtocolFn.processAuth = function (packet) {
  var self = this;
  switch (packet.cmd) {
    // 登录回报
    case 'login':
      if (!packet.error) {
        packet.content = packet.content || {};
        self.loginAndroidPush && self.loginAndroidPush(packet.content.aosPushInfo || {});
        packet.obj = packet.content.loginRes;
        self.connectionId = packet.content.loginRes.connectionId;
        self.onLoginPortsChange(packet, 2);
      }
      break;
    // 被踢通知
    case 'kicked':
      self.onKicked(packet);
      return;
    // 多端登陆通知
    case 'multiPortLogin':
      self.onLoginPortsChange(packet, packet.content.state);
      break;
    // 踢其它端
    case 'kick':
      if (!packet.error) {
        packet.obj.deviceIds = packet.content.deviceIds;
      }
      break;
    default:
      break;
  }
};

IMProtocolFn.onLoginPortsChange = function (packet, state) {
  var self = this;
  var loginPorts = packet.content.loginPorts;
  if (!!loginPorts && !!loginPorts.length) {
    var online = true;
    switch (state) {
      // 在线
      case 2:
        online = true;
        break;
      // 离线
      case 3:
        online = false;
        break;
      default:
        break;
    }
    loginPorts.forEach(function (p) {
      p.type = LoginPort.reverseType(p.type);
      p.time = +p.time;
      p.online = online;
    });
    // 后端返回的结果有时候会带上当前的连接号对应的端, 那么进行去重
    loginPorts = loginPorts.filter(function (p) {
      return p.connectionId !== self.connectionId;
    });
    if (loginPorts.length) {
      self.logger.info('link::onLoginPortsChange:', loginPorts);
      self.options.onloginportschange(loginPorts);
    }
  }
};

IMProtocolFn.kickedReasons = ['', 'samePlatformKick', 'serverKick', 'otherPlatformKick', 'silentlyKick'];

IMProtocolFn.kickedMessages = ['', '不允许同一个帐号在多个地方同时登录', '被服务器踢了', '被其它端踢了', '悄悄被踢'];

/***/ }),

/***/ "./src/im/protocol/im/chatroom.js":
/*!****************************************!*\
  !*** ./src/im/protocol/im/chatroom.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;

IMProtocolFn.processChatroom = function (packet) {
  var self = this;
  switch (packet.cmd) {
    case 'getChatroomAddress':
      self.onChatroomAddress(packet);
      break;
  }
};

IMProtocolFn.onChatroomAddress = function (packet) {
  if (!packet.error) {
    packet.obj.address = packet.content.address;
  }
};

/***/ }),

/***/ "./src/im/protocol/im/connect.js":
/*!***************************************!*\
  !*** ./src/im/protocol/im/connect.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
// var xhr = require('xhr')
var config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var ajax = __webpack_require__(/*! utiljs/ajax */ "./src/util/ajax/index.js");

IMProtocolFn.refreshSocketUrl = function () {
  var self = this;
  var options = self.options;
  var info = config.info;
  var lbsUrl = options.lbsUrl;
  lbsUrl = lbsUrl + util.genUrlSep(lbsUrl) + 'k=' + options.appKey + '&id=' + options.account + '&sv=' + info.sdkVersion + '&pv=' + info.protocolVersion;
  self.logger.info('link::refreshSocketUrl: ajax ' + lbsUrl);
  function onload(body) {
    self.socketUrls = [];
    if (config.isWeixinApp) {
      body = body.data;
    } else {
      body = JSON.parse(body);
    }
    body.common.link.forEach(function (url) {
      self.socketUrls.push(config.formatSocketUrl({
        url: url,
        secure: self.options.secure
      }));
    });
    body.common['link.default'].forEach(function (url) {
      url = config.formatSocketUrl({
        url: url,
        secure: self.options.secure
      });
      if (self.socketUrls.indexOf(url) === -1) {
        self.socketUrls.push(url);
      }
    });
    // 4.6.0 lbs下发nos上传地址（然并软，聊天室还要写死的see util/config）
    try {
      config.uploadUrl = body.nosup[0];
    } catch (e) {}
    // 6.2.0 增加 nos 直传地址，纯聊天室时也会请求 webconf.jsp
    config.chunkUploadUrl = config.chunkUploadUrl || body['nos-chunk'] || '';
    self.logger.info('link::refreshSocketUrl: ajax load, got socket urls ', self.socketUrls);
    self.connectToUrl(self.getNextSocketUrl());
  }

  function onerror(err) {
    self.logger.error('link::refreshSocketUrl: ajax lbs error', err);
    self.api.reportLogs({
      event: 'nimlb',
      code: 3001
    });
    var url = config.getDefaultLinkUrl(self.options.secure);
    if (url) {
      self.logger.info('link::refreshSocketUrl: use default link url', url);
      self.connectToUrl(url);
    } else {
      self.onDisconnect(false, 'link::refreshSocketUrl');
    }
  }
  if (config.isWeixinApp) {
    lbsUrl = lbsUrl.replace(/:\d+/, '');
    wx.request({
      url: lbsUrl,
      success: onload,
      fail: onerror
    });
  } else {
    ajax(lbsUrl, {
      proxyUrl: util.url2origin(lbsUrl) + '/lbs/res/cors/nej_proxy_frame.html',
      timeout: config.xhrTimeout,
      onload: onload,
      onerror: onerror
    });
  }

  // xhr({
  //   method: 'GET',
  //   cors: true,
  //   url: lbsUrl,
  //   timeout: config.xhrTimeout
  // }, function (error, response, body) {
  //   if (!error) {
  //     onload(body)
  //   } else {
  //     onerror(error)
  //   }
  // })
};

/***/ }),

/***/ "./src/im/protocol/im/eventService.js":
/*!********************************************!*\
  !*** ./src/im/protocol/im/eventService.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _device = __webpack_require__(/*! utiljs/device */ "./src/util/device.js");

var _device2 = _interopRequireDefault(_device);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

var clientTypeMap = _device2.default.clientTypeMap;

function formatMsgEvent(msgEvent) {
  msgEvent = msgEvent || {};
  var result = util.copy(msgEvent);
  if (result.clientType) {
    result.clientType = clientTypeMap[result.clientType] || '';
  }
  if (result.serverCustom) {
    result.custom = JSON.parse(result.serverCustom);
    if (typeof result.custom[0] === 'string') {
      result.custom = result.custom[0];
    }
    delete result.serverCustom;
  }
  return result;
}

IMProtocolFn.processEventService = function (packet) {
  var self = this;
  var content = packet.content;
  var error = packet.error;
  var options = self.options || {};

  if (error) {
    error.callFunc = 'events::processEventService';
    self.onCustomError('事件服务解包失败', 'EVENT_SERVICE_ERROR', error);
  }

  switch (packet.cmd) {
    // 服务器下推事件，在线记录
    case 'pushEvent':
      if (util.isFunction(options.onpushevents)) {
        var msgEvents = { msgEvents: [formatMsgEvent(content.msgEvent)] };
        options.onpushevents(msgEvents);
      }
      break;
    // 服务器批量下推事件，离线记录
    case 'pushEvents':
      if (util.isFunction(options.onpushevents)) {
        var _msgEvents = content.msgEvents;
        var result = _msgEvents.map(function (item) {
          return formatMsgEvent(item);
        });
        _msgEvents = { msgEvents: result };
        options.onpushevents(_msgEvents);
      }
      break;
  }
};

/***/ }),

/***/ "./src/im/protocol/im/filter.js":
/*!**************************************!*\
  !*** ./src/im/protocol/im/filter.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;

/**
 * 目前用于云商服的特殊协议, 服务器端会拦截相关的消息, 然后将这些消息转发到第三方服务器上
 * 第三方服务器进行处理后, 可以选择回传给服务器处理后的消息（也有可能是重新生成的新的消息）, 服务器会下发这些消息
 */
IMProtocolFn.processFilter = function (packet) {
    // filter表示此消息是过滤消息, 目前这个字段只用于云商服, 不用在文档中列出
    var self = this;
    switch (packet.cmd) {
        // 发送过滤消息
        case 'sendFilterMsg':
            self.onSendMsg(packet, true);
            break;
        // 过滤消息通知
        case 'filterMsg':
            self.onMsg(packet, true);
            break;
        // 过滤系统通知通知
        case 'filterSysMsg':
            self.onSysMsg(packet, true);
            break;
        // 发送过滤自定义系统通知
        case 'sendFilterCustomSysMsg':
            self.onSendSysMsg(packet, true);
            break;
    }
};

/***/ }),

/***/ "./src/im/protocol/im/friend.js":
/*!**************************************!*\
  !*** ./src/im/protocol/im/friend.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var objs2accounts = util.objs2accounts;
var Friend = __webpack_require__(/*! im/model/friend */ "./src/im/model/friend.js");
var User = __webpack_require__(/*! im/model/user */ "./src/im/model/user.js");

/**
 * 处理好友协议回包
 */
IMProtocolFn.processFriend = function (packet) {
  var self = this,
      obj = packet.obj,
      content = packet.content,
      error = packet.error;
  switch (packet.cmd) {
    // 添加好友
    case 'friendRequest':
      self.updateFriendSysMsg(packet);
      if (!error) {
        self.onFriendRequest(obj);
      }
      break;
    // 添加好友多端同步
    case 'syncFriendRequest':
      self.onFriendRequest(content, true);
      break;
    // 删除好友
    case 'deleteFriend':
      if (!error) {
        self.onDeleteFriend(obj);
      }
      break;
    // 删除好友多端同步
    case 'syncDeleteFriend':
      self.onDeleteFriend(content, true);
      break;
    // 更新好友
    case 'updateFriend':
      if (!error) {
        self.onUpdateFriend(obj);
      }
      break;
    // 更新好友多端同步
    case 'syncUpdateFriend':
      self.onUpdateFriend(content.friend, true);
      break;
    // 获取好友列表
    case 'getFriends':
      self.onFriends(packet);
      break;
    // 同步好友列表
    case 'syncFriends':
      self.onFriends(packet);
      break;
    case 'syncFriendUsers':
      self.onFriendUsers(packet);
      break;
    default:
      break;
  }
};

/*
 * 处理好友, 同步和主动获取都会走这个逻辑
 */
IMProtocolFn.onFriends = function (packet) {
  var self = this,
      db = self.db,
      error = packet.error,

  // 有同步和主动获取两种情况
  isSync = self.packetFromSync(packet),
      rawFriends = packet.content.friends,
      hasChange = true,
      timetag,
      friends = [],
      invalidFriends = [];

  // 用于同步的Promise
  var promise = new Promise(function (resolve, reject) {
    if (!error) {
      // 处理数据
      parseData();
      // 如果支持数据库, 那么合并数据, 否则直接 bingo
      if (db.enable) {
        mergeData(resolve, reject);
      } else {
        bingo();
        resolve();
      }
    } else if (isSync) {
      // 同步时应该没有error, 所以这里应该走不到
      reject(error);
    }
  }).catch(function (error) {
    self.logger.error('friend::onFriends: ', error);
    return Promise.reject(error);
  });
  if (isSync) {
    promise.cmd = 'friends';
    self.syncPromiseArray.push(promise);
  }

  function parseData() {
    if (hasChange) {
      rawFriends.forEach(function (friend) {
        friend = Friend.reverse(friend);
        if (friend.valid) {
          friends.push(friend);
        } else {
          invalidFriends.push(friend);
        }
      });
    }
    self.logger.info('friend::onFriends: parse friends', objs2accounts(friends), friends, 'delete', objs2accounts(invalidFriends), invalidFriends);
    if (!rawFriends.length) {
      hasChange = false;
    } else {
      hasChange = true;
      timetag = packet.content.timetag;
    }
  }

  function mergeData(resolveSync, rejectSync) {
    // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
    packet.promise = new Promise(function (resolve, reject) {
      if (hasChange) {
        // 增量更新数据库
        db.mergeFriends(friends, invalidFriends, timetag).then(function () {
          afterMergeData();
        }).then(undefined, function (event) {
          event._msg = 'merge friends error';
          reject(event);
          rejectSync(event);
        });
      } else {
        self.logger.info('friend::onFriends: no merge friends');
        afterMergeData();
      }
      function afterMergeData() {
        // 如果不是同步, 那么需要获取完整的列表
        if (!isSync) {
          db.getFriends().then(function (records) {
            friends = records;
            bingo();
            resolve();
            resolveSync();
          }).then(undefined, function (event) {
            event._msg = 'get friends error';
            reject(event);
            rejectSync(event);
          });
        } else {
          bingo();
          resolve();
          resolveSync();
        }
      }
    }).then(undefined, function (event) {
      event._msg = 'merge friends data error';
      rejectSync(event);
      throw event;
    });
  }

  function bingo() {
    self.timetags.friends = timetag;
    friends.invalid = invalidFriends;
    // 返回数据
    if (isSync) {
      // 如果是同步, 那么统一在 onSyncDone 里面通知开发者
      self.syncResult.friends = friends;
      self.syncResult.invalidFriends = invalidFriends;
    } else {
      self.logger.info('friend::onFriends: get friends bingo', objs2accounts(friends), friends);
      packet.obj = friends;
    }
  }
};

/**
 * 处理好友请求
 * - 主动发起的好友请求
 * - 多端同步添加好友
 * - 收到相关的系统通知
 * @private
 * @param  {Object}  obj      请求对象
 * @param  {Boolean} isSynced 是否是多端同步
 * @return {Void}
 */
IMProtocolFn.onFriendRequest = function (obj, isSynced) {
  var promise = Promise.resolve();
  var self = this;
  var db = self.db;
  var type = obj.type;
  type = obj.type = Friend.getTypeFromByte(type) || type;
  var isAdd = type === 'addFriend' || type === 'passFriendApply';
  if (isAdd) {
    // 如果是加好友, 将拼好的对象传给开发者
    var friend = obj.friend = Friend.assembleFriend(obj.account);
    // 那么存数据库
    if (db.enable) {
      promise = db.putFriend(friend);
    }
  }
  // 如果是多端同步, 那么通知开发者
  if (isSynced) {
    self.onSyncFriendAction(obj);
  }
  return promise;
};

IMProtocolFn.onSyncFriendAction = function (obj) {
  var self = this;
  self.logger.info('friend::onSyncFriendActionon:', obj);
  self.options.onsyncfriendaction(obj);
};

/**
 * 删除好友
 * - 主动删除
 * - 多端同步删除
 * - 被删除, 收到系统通知
 * @private
 * @param  {Object}  obj      请求对象
 * @param  {Boolean} isSynced 是否是多端同步
 * @return {Void}
 */
IMProtocolFn.onDeleteFriend = function (obj, isSynced) {
  var promise = Promise.resolve();
  var self = this;
  var db = self.db;
  if (db.enable) {
    promise = db.deleteFriend(obj.account);
  }
  // 如果是多端同步, 那么通知开发者
  if (isSynced) {
    obj.type = 'deleteFriend';
    self.onSyncFriendAction(obj);
  }
  return promise;
};

/**
 * 更新好友
 * @private
 * @param  {Object}  obj      请求对象
 * @param  {Boolean} isSynced 是否是多端同步
 * @return {Void}
 */
IMProtocolFn.onUpdateFriend = function (obj, isSynced) {
  var self = this;
  var db = self.db;
  var friend = Friend.reverse(obj);
  if (db.enable) {
    db.updateFriend(friend);
  }
  // 如果是多端同步, 那么通知开发者
  if (isSynced) {
    self.onSyncFriendAction({
      type: 'updateFriend',
      friend: friend
    });
  }
};

// 只有在启用数据库的时候才同步好友对应的用户名片
IMProtocolFn.onFriendUsers = function (packet) {
  var self = this;
  var db = self.db;
  var content = packet.content;
  var users = content.users.map(function (user) {
    return User.reverse(user);
  });
  self.logger.warn('friend::onFriendUsers: parse users', objs2accounts(users), users);
  var timetag = content.timetag;
  var promise = Promise.resolve();
  if (db.enable) {
    promise = db.mergeFriendUsers(users, timetag);
  }
  self.timetags.friendUsers = timetag;
  promise.cmd = 'friendUsers';
  self.syncPromiseArray.push(promise);
  self.syncResult.users = users;
  if (!self.syncing) {
    // 如果数据比同步完成命令后收到也会通知
    self.onSyncDone();
  }
};

/*
 * 更新系统通知状态
 */
IMProtocolFn.updateFriendSysMsg = function (packet) {
  var obj = packet.obj;
  var state;
  var error = packet.error;
  var sysMsg;

  if (!packet.obj.idServer) {
    return;
  }

  if (!error) {
    var type = obj.type;
    type = Friend.getTypeFromByte(type) || type;
    switch (type) {
      case 'passFriendApply':
        state = 'passed';
        break;
      case 'rejectFriendApply':
        state = 'rejected';
        break;
    }
  } else {
    state = 'error';
    error = util.filterObj(error, 'code message');
  }

  sysMsg = {
    idServer: obj.idServer,
    state: state
  };
  if (error) {
    sysMsg.error = error;
  }
  this.updateSysMsg(sysMsg);
};

/***/ }),

/***/ "./src/im/protocol/im/index.js":
/*!*************************************!*\
  !*** ./src/im/protocol/im/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var DB = __webpack_require__(/*! im/db */ "./src/im/db/index.js");
var Protocol = __webpack_require__(/*! im/protocol/base */ "./src/im/protocol/base/index.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var PushNotificationMultiportConfig = __webpack_require__(/*! im/model/pushNotificationMultiportConfig */ "./src/im/model/pushNotificationMultiportConfig.js");
var parser = __webpack_require__(/*! im/protocol/parser */ "./src/im/protocol/parser/index.js");
var SystemMessage = __webpack_require__(/*! im/model/systemMessage */ "./src/im/model/systemMessage.js");

function IMProtocol(options) {
  var self = this;
  util.verifyOptions(options, 'appKey account token', 'protocol::IMProtocol');
  // 所有通知回调在用 Promise 的地方使用 setTimeout 来模拟异步线程, 否则, 如果抛出错误会被 Promise catch 到, 控制台就不会报错
  util.verifyCallback(options, ['onconnect', 'onerror', 'onwillreconnect', 'ondisconnect', 'onloginportschange', 'onmyinfo', 'onblacklist', 'onmutelist', 'onfriends', 'onusers', 'onrobots', 'onteams', 'onSuperTeams', 'onsessions', 'onroamingmsgs', 'onofflinemsgs', 'onofflinefiltermsgs', 'onroamingsysmsgs', 'onofflinesysmsgs', 'onofflinefiltersysmsgs', 'onofflinecustomsysmsgs', 'onofflinefiltercustomsysmsgs', 'onbroadcastmsg', 'onbroadcastmsgs', 'onsysmsgunread', 'onsyncdone', 'onteammembers', 'onsyncteammembersdone', 'onmsg', 'onsysmsg', 'oncustomsysmsg', 'onupdatemyinfo', 'onupdateuser', 'onUpdateSuperTeamMember', 'onCreateSuperTeam', 'onUpdateSuperTeam', 'onAddSuperTeamMembers', 'onRemoveSuperTeamMembers', 'onUpdateSuperTeamManagers', 'onupdateteammember', 'onCreateTeam', 'onUpdateTeam', 'onAddTeamMembers', 'onRemoveTeamMembers', 'onUpdateTeamManagers', 'onDismissTeam', 'onTransferTeam', 'onUpdateTeamMembersMute', 'onTeamMsgReceipt', 'onupdatesession', 'onupdatesysmsgunread', 'onupdatesysmsg', 'onsynccreateteam', 'onsyncsupercreateteam', 'onsyncmarkinblacklist', 'onsyncmarkinmutelist', 'onsyncfriendaction',
  // 只想过滤部分通知，所以是函数
  'shouldIgnoreNotification', 'shouldCountNotifyUnread', 'onPushNotificationMultiportConfig', 'onPushNotificationMultiportConfigUpdate', 'onpushevents'], 'protocol::IMProtocol');
  // 初始化数据库
  self.db = options.api.db = new DB({
    logger: options.logger
  });
  // 调用父类初始化
  Protocol.call(self, options);
}

var ProtocolFn = Protocol.fn;
var IMProtocolFn = IMProtocol.fn = IMProtocol.prototype = Object.create(ProtocolFn);

IMProtocolFn.init = function () {
  var self = this;
  ProtocolFn.init.call(self);
  // 协议解释器，parser里需要sendCmd取nos短链对应的源链，所以在此处绑定self
  parser.IM.setProtocol(self);
  self.parser = parser.IM;
  self.sendCmd.bind(self);
  // socket 地址
  self.socketUrls = [];
  // 是否正在同步中, 初始化时为 true 表示正在同步中
  // syncData 时会置为 true 表示正在同步中
  // onSyncDone 时会置为 false 表示同步完成
  self.syncing = true;
  // 是否已经进行过同步, 如果已经进行过, 那么后续的同步均为增量同步
  self.hasSynced = false;
  // 是否已经进行过同步群成员, 如果已经进行过, 那么后续的同步均为增量同步
  self.hasSyncedTeamMembers = false;
  // 存储同步 Promise 数组, 监视什么时候完成同步
  self.syncPromiseArray = [];
  // 在同步过程中, 会存入同步到的数据
  self.syncResult = {};
  // 存储同步群成员 Promise 数组, 监视什么时候完成同步群成员
  self.syncTeamMembersPromiseArray = [];
  self.syncSuperTeamMembersPromiseArray = [];
  // 在同步群成员过程中, 会存入同步到的数据
  self.syncTeamMembersResult = {};
  // 同步时间戳, 当没有数据库时从此对象读取同步时间戳, 从而进行增量同步
  self.timetags = {};

  // 系统通知未读数
  self.sysMsgUnread = SystemMessage.completeUnread({});

  self.resetUnsettledMsgs();
  self.resetUnsettledSysMsgs();

  // 使收消息和发消息按照顺序来处理
  self.msgPromise = Promise.resolve();

  // 收到系统通知的时候按顺序来存储
  self.sysMsgPromise = Promise.resolve();

  /*
   * 会话集合
   * - key 为 sessionId, value 为 session
   * 数据来源为
   * - 同步后得到的会话 (onSyncDone)
   * - 更新会话 (onUpdateSession)
   * - 从本地获取会话 (getLocalSessions)
   * - 同步后得到的消息回执 (onOfflineMsgReceipts onSyncDone)
   * - 发送消息回执 (onSendMsgReceipt)
   * - 收到消息回执 (onMsgReceipt)
   * 用法
   * - 如果设置一个不存在的会话为当前会话或者重置一个不存在的会话的未读数, 会直接返回
   */
  self.sessionSet = {};

  self.msgReceiptTasks = {};

  // 用户集合
  // key 为 account, value 为 user
  // 数据来源为同步后得到的用户 (onSyncDone) 以及主动拉到的用户 (getUsers)
  // 如果收到消息之后发现用户名片被更新了, 那么需要从服务器拉取新的用户名片
  self.userSet = {};

  // 多端推送配置项
  self.pushNotificationMultiportConfig = PushNotificationMultiportConfig.getDefaultConfig();
};

IMProtocolFn.reset = function () {
  var self = this;
  ProtocolFn.reset.call(self);

  var options = self.options;
  // 重置数据库
  self.db.reset(options.db);
  // lbsUrl
  if (undef(options.lbsUrl)) {
    options.lbsUrl = Config.lbsUrl;
  }
  self.resetAutoMarkRead();
};

IMProtocolFn.resetAutoMarkRead = function () {
  var options = this.options;
  util.verifyBooleanWithDefault(options, 'autoMarkRead', true, '', 'protocol::resetAutoMarkRead');
  // 目前使用一个通用的开关, 下面的代码是各个子开关, 先注释掉
  // 将options.autoMarkRead处理成false或者{}
  // if (util.notundef(options.autoMarkRead)) {
  //     if (!util.isObject(options.autoMarkRead)) {
  //         // 如果该不是一个对象, 那么它必须是Boolean
  //         util.verifyParamType('autoMarkRead', options.autoMarkRead, 'boolean', 'protocol::resetAutoMarkRead');
  //         // 如果是true, 那么变为{}
  //         if (options.autoMarkRead === true) {
  //             options.autoMarkRead = {};
  //         }
  //     }
  // } else {
  //     options.autoMarkRead = {};
  // }
  // var auto = true;
  // if (options.autoMarkRead === false) {
  //     options.autoMarkRead = {};
  //     auto = false;
  // }
  // // filter开头的开关用于控制云商服专用消息的标记已读
  // util.verifyBooleanWithDefault(options.autoMarkRead, 'p2p team sys customSys filterP2p filterTeam filterSys filterCustomSys', auto, 'autoMarkRead.', 'protocol::resetAutoMarkRead');
};

/*
 * 如果同步过程中发生以下情况
 * - 收到消息 (需要调用 handleMsg)
 * - 发消息之前 (需要调用 putMsg)
 * - 发消息失败 (需要调用 updateMsg)
 * - 发消息成功 (需要调用 updateMsg)
 * 需要将消息缓存起来, 在同步完成之后再更新数据库, 这样才能保证消息在数据库中的顺序
 * - processUnsettledMsgs
 */
IMProtocolFn.resetUnsettledMsgs = function () {
  var self = this;
  /*
     * 未处理的消息, 包括
     * - 收到消息
     * - 发消息之前
     */
  self.unhandledMsgs = [];
  /*
     * 未更新的消息, 包括
     * - 发消息失败
     * - 发消息成功
     */
  self.unupdatedMsgs = [];
};

/*
 * 如果同步过程中发生以下情况
 * - 收到离线消息 (需要调用 handleSysMsg)
 * 需要将系统通知缓存起来, 在同步完成之后再更新数据库, 这样才能保证系统通知在数据库中的顺序
 * - processUnsettledSysMsgs
 */
IMProtocolFn.resetUnsettledSysMsgs = function () {
  var self = this;
  self.unhandledSysMsgs = [];
  self.unupdatedSysMsgs = [];
};

/**
 * 判断packet是否是同步的回包
 * 因为同步可能有多个回包, 所以第一个回包会获取到 packet.obj.sync, 后面的回包都获取不到 packet.obj
 * @private
 */
IMProtocolFn.packetFromSync = function (packet) {
  return !packet.obj || !!packet.obj.sync;
};

// // 数据库错误
// IMProtocolFn.onDBError = function (logMsg, event) {
//   var error = NIMError.newDBError()
//   error.event = event
//   this.onMiscError(logMsg, error)
// }

module.exports = IMProtocol;

__webpack_require__(/*! ./connect */ "./src/im/protocol/im/connect.js");
__webpack_require__(/*! ./auth */ "./src/im/protocol/im/auth.js");
__webpack_require__(/*! ./sync */ "./src/im/protocol/im/sync.js");
__webpack_require__(/*! ./user */ "./src/im/protocol/im/user.js");
__webpack_require__(/*! ./friend */ "./src/im/protocol/im/friend.js");
__webpack_require__(/*! ./robot */ "./src/im/protocol/im/robot.js");
__webpack_require__(/*! ./team */ "./src/im/protocol/im/team.js");
__webpack_require__(/*! ./superTeam */ "./src/im/protocol/im/superTeam.js");
__webpack_require__(/*! ./notify */ "./src/im/protocol/im/notify.js");
__webpack_require__(/*! ./msg */ "./src/im/protocol/im/msg.js");
__webpack_require__(/*! ./msgReceipt */ "./src/im/protocol/im/msgReceipt.js");
__webpack_require__(/*! ./msgDelete */ "./src/im/protocol/im/msgDelete.js");
__webpack_require__(/*! ./sysMsg */ "./src/im/protocol/im/sysMsg.js");
__webpack_require__(/*! ./session */ "./src/im/protocol/im/session.js");
__webpack_require__(/*! ./sessionAck */ "./src/im/protocol/im/sessionAck.js");
__webpack_require__(/*! ./chatroom */ "./src/im/protocol/im/chatroom.js");
__webpack_require__(/*! ./filter */ "./src/im/protocol/im/filter.js");
__webpack_require__(/*! ./eventService */ "./src/im/protocol/im/eventService.js");

/***/ }),

/***/ "./src/im/protocol/im/msg.js":
/*!***********************************!*\
  !*** ./src/im/protocol/im/msg.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var undef = util.undef;
var device = __webpack_require__(/*! utiljs/device */ "./src/util/device.js");
var TeamMember = __webpack_require__(/*! im/model/teamMember */ "./src/im/model/teamMember.js");
var SuperTeamMember = __webpack_require__(/*! im/model/superTeamMember */ "./src/im/model/superTeamMember.js");
var Session = __webpack_require__(/*! im/model/session */ "./src/im/model/session.js");
var configMap = __webpack_require__(/*! im/protocol/map/configIM */ "./src/im/protocol/map/configIM.js");

/**
 * 处理消息协议
 */
IMProtocolFn.processMsg = function (packet) {
  var self = this;
  switch (packet.cmd) {
    // 发送消息
    case 'sendMsg':
      self.onSendMsg(packet);
      break;
    // 消息通知
    case 'msg':
      self.onMsg(packet);
      break;
    // 系统通知通知（包括自定义系统通知）
    case 'sysMsg':
      self.onSysMsg(packet);
      break;
    case 'broadcastMsg':
      self.onBroadcastMsg(packet);
      break;
    // 发送自定义系统通知
    case 'sendCustomSysMsg':
      self.onSendSysMsg(packet);
      break;
    // 获取单人历史消息
    case 'getHistoryMsgs':
    case 'searchHistoryMsgs':
      self.onHistoryMsgs(packet);
      break;
    // 发送消息后发送方的多端同步通知
    case 'syncSendMsg':
      self.onMsg(packet);
      break;
    case 'deleteSessions':
      self.onDeleteSessions(packet);
      break;
    case 'sendMsgReceipt':
      self.onSendMsgReceipt(packet);
      break;
    case 'msgReceipt':
      self.onMsgReceipt(packet);
      break;
    case 'onDeleteMsg':
      self.onDeleteMsg(packet);
      break;
    case 'onMsgDeleted':
      self.onMsgDeleted(packet);
      break;
    case 'onDeleteMsgOfflineRoaming':
      self.onDeleteMsgOfflineRoaming(packet);
      break;
    case 'onMarkSessionAck':
      self.onMarkSessionAck(packet);
      break;
    case 'syncMarkSessionAck':
      self.syncMarkSessionAck(packet);
      break;
    default:
      break;
  }
};

IMProtocolFn.checkIgnore = function (msgs) {
  var self = this;
  // 询问开发者, 是否要忽略某条通知消息, 如果忽略, 那么不会将其存储到数据库, 并且不会通知给开发者
  msgs.forEach(function (msg) {
    if (msg.type === 'notification' && !msg.ignore && self.options.shouldIgnoreNotification(msg)) {
      msg.ignore = true;
    }
  });
};

IMProtocolFn.filterIgnore = function (msgs) {
  return msgs.filter(function (msg) {
    return !msg.ignore;
  });
};

IMProtocolFn.genSessionByMsgs = function (msgs) {
  var self = this;
  self.checkIgnore(msgs);
  return Session.genSessionByMsgs(self.message.Message, msgs);
};

// 收到漫游消息, 需去重
IMProtocolFn.onRoamingMsgs = function (packet) {
  var self = this;
  var message = self.message;
  var Message = message.Message;
  var getMaxTimetag = Message.getMaxTimetag;
  var msgs = message.reverseMsgs(packet.content.msgs);
  var timetag = getMaxTimetag(msgs);
  // 服务器返回的数据是按照时间从晚到早排序的, 但是一般UI上都是按照时间从早到晚排序的
  msgs = Message.sortMsgs(msgs);
  msgs = Message.deduplication(msgs);
  var msg = msgs[0];
  var sessionId = msg.sessionId;
  // 缓存对应的会话, 这样在同步已读回执时保证内存有数据
  var session = self.genSessionByMsgs(msgs);
  self.cacheSyncedSession(session);
  // 存储漫游消息
  var promise = self.putMsg(msgs, 'roamingMsgs').then(function (records) {
    // debugger;
    // 这里返回的是过滤后的消息, 有可能为空数组
    msgs = records;
    // 过滤掉被忽略的消息, 如果没有消息, 那么直接返回
    msgs = self.filterIgnore(msgs);
    if (!msgs.length) {
      return;
    }
    // 记录同步结果
    self.logger.info('msg::onRoamingMsgs: putRoamingMsgs', sessionId, msgs.length, msgs);
    self.syncResult.roamingMsgs = self.syncResult.roamingMsgs || [];
    self.syncResult.roamingMsgs.push({
      sessionId: sessionId,
      scene: msg.scene,
      to: msg.target,
      msgs: msgs,
      timetag: timetag
    });
    if (!self.syncing) {
      // 如果数据比同步完成命令后收到也会通知
      self.onSyncDone();
    }
  }).catch(function (error) {
    self.logger.error('msg::onRoamingMsgs: ', error);
    return Promise.reject(error);
  });
  promise.cmd = 'roamingMsgs-' + sessionId;
  self.syncPromiseArray.push(promise);
};

// 收到离线消息, 需去重
// 不用调用 handleMsg, 因为同步的时候已经同步到这些变更了
IMProtocolFn.onOfflineMsgs = function (packet, isFilter) {
  var self = this;
  var message = self.message;
  var Message = message.Message;
  // 处理过滤消息
  var modifyObj = null;
  if (isFilter) {
    modifyObj = {
      filter: true
    };
  }
  var msgs = message.reverseMsgs(packet.content.msgs, {
    modifyObj: modifyObj
  });
  // 将离线消息按会话分开, 一个会话一个回包
  var currMsgs = [];
  var currSessionId = '';
  var sessionId;
  var promise;
  var property = isFilter ? 'offlineFilterMsgs' : 'offlineMsgs';

  msgs.forEach(function (msg) {
    sessionId = msg.sessionId;
    // 如果是新的会话
    if (sessionId !== currSessionId) {
      // 存储上一个会话
      storeLastSession(currSessionId);
      // 开始新的会话
      currMsgs = [];
      currMsgs.push(msg);
      currSessionId = sessionId;
    } else {
      currMsgs.push(msg);
    }
  });
  storeLastSession(currSessionId);
  // currSessionId 在闭包中被使用，需要分离出来
  function storeLastSession(currSessionId) {
    // 第一次 currMsgs 为空
    if (currMsgs.length) {
      var timetag = Message.getMaxTimetag(currMsgs);
      var scene = currMsgs[0].scene;
      var to = currMsgs[0].target;
      // 标记消息已读, 要标记所有的消息
      self.markMsgRead(currMsgs);
      // 服务器返回的数据是按照时间从晚到早排序的, 但是一般UI上都是按照时间从早到晚排序的
      currMsgs = Message.sortMsgs(currMsgs);
      // 去重
      currMsgs = Message.deduplication(currMsgs);
      // 缓存对应的会话, 这样在同步已读回执时保证内存有数据
      var session = self.genSessionByMsgs(currMsgs);
      self.cacheSyncedSession(session);
      // 存储离线消息
      // 存储离线消息的时候会存储会话
      promise = self.putMsg(currMsgs, 'offlineMsgs').then(function (records) {
        // debugger;
        // 这里返回的是过滤后的消息, 有可能为空数组
        currMsgs = records;
        // 过滤掉被忽略的消息, 如果没有消息, 那么直接返回
        currMsgs = self.filterIgnore(currMsgs);
        if (!currMsgs.length) {
          return;
        }
        // 记录同步结果
        self.logger.info('msg::onOfflineMsgs： toreLastSession', property, currSessionId, currMsgs.length, currMsgs);
        self.syncResult[property] = self.syncResult[property] || [];
        self.syncResult[property].push({
          sessionId: currSessionId,
          scene: scene,
          to: to,
          msgs: currMsgs,
          timetag: timetag
        });
      }).catch(function (error) {
        self.logger.error('msg::onOfflineMsgs: ', error);
        return Promise.reject(error);
      });
      promise.cmd = 'offlineMsgs-' + currSessionId;
      self.syncPromiseArray.push(promise);
    }
  }
};

// 用于离线消息及漫游消息同步会话未读数
IMProtocolFn.markUnreadByMsgsPromise = function (sessionId) {
  var self = this;
  var db = self.db;
  if (db.enable) {
    db.getSession(sessionId).then(function (record) {
      if (record.ack) {
        self.markUnreadBySessionAck({ sessionId: sessionId, ack: record.ack });
      }
    });
  }
};

/*
 * 补全消息, 加上某些字段
 */
IMProtocolFn.completeMsg = function (msg) {
  var self = this;
  msg.from = self.account;
  msg.fromNick = self.myInfo && self.myInfo.nick;
  msg.fromClientType = 'Web';
  msg.fromDeviceId = device.deviceId;
  if (!msg.time) {
    msg.time = +new Date();
  }
  return msg;
};

/*
 * 收到多条群消息
 * - 普通群被拉进群并且有人在群里说话了
 */
IMProtocolFn.onMsgs = function (packet) {
  var self = this;
  self.message.reverseMsgs(packet.content.msgs, {
    mapper: function mapper(msg) {
      self.handleMsg(msg);
    }
  });
};

/*
 * 收到消息
 * - 收到一条点对点消息
 * - 收到一条在其它端发送的点对点消息
 * - 收到一条群消息
 * - 收到一条超大群消息
 * - 收到一条在其它端发送的群消息
 * - 收到一条过滤消息
 */
IMProtocolFn.onMsg = function (packet, isFilter) {
  var self = this;
  var msg = self.message.reverse(packet.content.msg);
  if (isFilter) {
    msg.filter = true;
  }
  // 如果正在同步中, 那么先不处理消息, 等到同步完成之后再处理消息
  if (self.syncing) {
    self.logger.log('msg::onMsg:is in syncing ...');
    self.unhandledMsgs.push({
      type: 'onMsg',
      msg: msg
    });
  } else {
    self.handleMsg(msg);
  }
};

IMProtocolFn.onBroadcastMsgs = function (packet) {
  var self = this;
  var broadcastMsgs = packet.content.broadcastMsgs;
  broadcastMsgs = broadcastMsgs.sort(function (a, b) {
    return a.broadcastId - b.broadcastId;
  });
  self.putBroadcastMsgs(broadcastMsgs);
};

IMProtocolFn.onBroadcastMsg = function (packet) {
  var self = this;
  var broadcastMsg = packet.content.broadcastMsg;
  broadcastMsg.time = broadcastMsg.timestamp;
  if (self.syncing) {
    self.unhandledMsgs.push({
      type: 'onBroadcastMsg',
      msg: broadcastMsg
    });
  } else if (broadcastMsg) {
    self.putBroadcastMsg(broadcastMsg);
  }
};

IMProtocolFn.pushMsgTask = function (task) {
  var self = this;
  self.msgPromise = self.msgPromise.then(function () {
    return task();
  });
};

/*
 * - 存储并过滤消息
 * - 更新漫游消息时间戳
 * - 分类型处理消息
 * - 通知消息
 */
IMProtocolFn.handleMsg = function (msg) {
  var self = this;
  var db = self.db;
  var timetag = msg.time;
  // 标记已读
  self.markMsgRead(msg);
  // 处理消息
  self.msgPromise = self.msgPromise.then(function () {
    // 存储消息
    return self.putMsg(msg, 'onMsg');
  }).then(function (records) {
    self.logger.log('msg::handleMsg:putMsg: ', msg);
    // 这里返回的是过滤后的消息, 有可能为空数组
    // 就算过滤后的消息数组为空, 时间戳还是要更新, 防止下次再同步下来

    if (!db.enable) return Promise.resolve();
    var p1 = db.updateRoamingMsgTimetag(timetag);
    var p2 = Promise.resolve();
    if (msg.scene === 'superTeam') {
      p2 = db.updateSuperTeamRoamingMsgTimetag(timetag);
    }
    return Promise.all([p1, p2]);
  }).then(function () {
    // 检查用户信息是否更新了
    self.logger.log('msg::handleMsg:updateRoamingMsgTimetag: ', timetag, msg);
    if (!msg) {
      return;
    }
    return self.checkUserUpdate(msg);
  }).then(function () {
    // debugger;
    // 分类型处理消息
    if (!msg) {
      return;
    }
    var type = msg.type;
    self.logger.log('msg::handleMsg:checkUserUpdate: ' + msg.scene + ' ' + type + ' msg' + (type === 'notification' ? ' ' + msg.attach.type : ''), msg);
    switch (type) {
      case 'notification':
        return self.onTeamNotificationMsg(msg);
    }
  }).then(function () {
    // debugger;
    // 通知消息, 但是要先过滤掉被忽略的消息
    if (!msg || msg.ignore) {
      return;
    }
    self.logger.info('msg::handleMsg:onmsg: ', msg);
    setTimeout(function () {
      self.options.onmsg(util.copy(msg));
    }, 0);
  }).then(undefined, function (event) {
    event.callFunc = 'msg::handleMsg';
    self.onCustomError('消息处理错误', event);
  });
};

/*
 * 更新消息, 以下情况会更新消息
 * - 收到漫游消息
 * - 收到离线消息
 * - 发消息
 * - 收到在线消息
 * 策略
 * - 更新消息之后要更新对应的会话对象
 * - 如果是收到离线消息、或者收到不是当前会话的在线消息, 那么需要更新未读数
 * - 如果是收到在线消息, 通知会话
 * 多 tab 页
 * - 当支持多个 tab 同时登录时, 收到消息时, 只会在一个 tab 页里面存储这些消息, 其它 tab 页会存储失败
 * - 存储成功的 tab 负责存储会话和更新未读数, 其它 tab 页也要计算自己的未读数(但是不能更新到数据库), 同时也要将消息推给开发者
 * type
 * - `'roamingMsgs'`
 * - `'offlineMsgs'`
 * - `'sendMsg'`
 * - `'onMsg'`
 */
IMProtocolFn.putMsg = function (msgs, type) {
  // debugger;
  if (!util.isArray(msgs)) {
    msgs = [msgs];
  }
  // 如果是过滤（云商服专用）, 直接返回
  if (msgs[0].filter) {
    return Promise.resolve(msgs);
  }
  var self = this;
  var db = self.db;
  var supportDb = db.enable;
  var promise = Promise.resolve();
  var Message = self.message.Message;
  var lastMsg = Message.getLastMsg(msgs);
  var flow = lastMsg.flow;
  var notCurrSession = lastMsg.sessionId !== self.currSessionId;
  // 后面存储会话函数又调用了一次，可以优化
  var session = self.genSessionByMsgs(msgs);
  cacheSession(session);

  // 落后了, 其它 tab 已经存过了
  var backward = false;
  // 未计入未读数的消息
  var uncountMsgs = [];
  // 过滤并存储, 存储之前要先标记被忽略的消息
  self.checkIgnore(msgs);
  self.logger.log('start');
  promise = promise.then(function () {
    // 没有设置自动标记已读，需要缓存消息，用于重置会话未读数resetSessionUnread时，markMsgRead
    if (!supportDb && !self.options.autoMarkRead && type !== 'roamingMsgs' && session) {
      self.sessionUnreadMsgs = self.sessionUnreadMsgs || {};
      self.sessionUnreadMsgs[session.id] = self.sessionUnreadMsgs[session.id] || [];
      self.sessionUnreadMsgs[session.id] = self.sessionUnreadMsgs[session.id].concat(msgs.filter(function (msg) {
        var notifySignal = self.options.shouldCountNotifyUnread(msg);
        return notifySignal;
      }));
    }
    // 如果是漫游和离线消息, 那么等同步完成后统一存
    if (supportDb && type !== 'roamingMsgs' && type !== 'offlineMsgs') {
      self.logger.log('msg::putMsg:db.putMsg: ', session);
      return db.putMsg(msgs);
    } else {
      return msgs;
    }
  }).then(function (records) {
    // debugger;
    // 过滤出最终回传给用户的消息
    var arr = [];
    msgs.forEach(function (msg) {
      if (self.checkMsgUnique(msg)) {
        arr.push(msg);
      }
    });
    msgs = arr;
    if (supportDb) {
      // records 为存储到数据库的消息数组, 需要根据此数组来更新未读数
      uncountMsgs = records;
    } else {
      uncountMsgs = msgs;
    }
    return Promise.resolve(msgs);
  });
  // 存储会话
  // todo 重复回调逻辑（后期存储会话调整 wj）
  promise = promise.then(function (msgs) {
    // debugger;
    // 如果过滤后的消息为空数组, 则不作处理
    if (msgs.length) {
      // 计算 session
      session = self.genSessionByMsgs(msgs);
      cacheSession(session);
      // 忽略通知类消息，可能session为null
      if (supportDb && session) {
        return new Promise(function (resolve, reject) {
          // 比较发来的消息与数据库所存储的消息的时间戳
          db.getSessions({
            sessionId: session.id
          }).then(function (record) {
            if (record && record.lastMsg) {
              var currLastMsg = record.lastMsg;
              if (session.lastMsg) {
                if (session.lastMsg.time < currLastMsg.time) {
                  session.lastMsg = currLastMsg;
                }
              }
            }
            self.logger.log('msg::putMsg:db.getSessions: ', session);
            // 如果未计入未读数的消息不为空数组, 说明此 tab 页负责存储消息, 那么需要存储会话
            // 如果未计入未读数的消息为空数组, 则说明其它 tab 页已经存储过消息了, 那么不需要存储会话, 但是依然需要重新计算未读数, 只是不能存储这个未读数
            if (uncountMsgs.length) {
              if (session) {
                db.putSession(session).then(function (recordNew) {
                  resolve(recordNew);
                });
              } else {
                resolve(record);
              }
            } else {
              backward = true;
              uncountMsgs = msgs;
              // 将记录传递给后一个promise
              // 后一个promise仅仅只涉及未读数，且针对漫游消息
              resolve(record);
            }
          });
        }); // end return new Promise
      } // end supportDb
    }
    // 没有数据库记录
    return Promise.resolve(session);
  });

  // 更新未读数, 必须是
  // - 离线消息
  // - 启用了 syncSessionUnread 之后的比 session.ack 晚的漫游消息
  // - 收到非当前会话的在线消息
  // - 此时才将会话存储到数据库，session是内存里的，record是数据库里的
  promise = promise.then(function (record) {
    // 如果没有会话, 说明所有的消息都被忽略了, 那么直接返回
    if (!session) {
      return;
    }
    // 如果未读数没有变化, 直接返回
    if (!uncountMsgs.length) {
      return;
    }
    var isRoaming = type === 'roamingMsgs';
    var syncSessionUnread = self.options.syncSessionUnread;
    var sessionId = session.id;
    var sessionInMemory = self.findSession(sessionId) || {};
    var sessionAck = sessionInMemory.ack || 0;
    var shouldUpdateUnread = type === 'offlineMsgs' || isRoaming && syncSessionUnread || type === 'onMsg' && flow === 'in' && notCurrSession;
    if (shouldUpdateUnread) {
      // 如果没有从数据库拿到会话记录, 那么从数据源获取会话记录的未读数
      if (supportDb && !!record) {
        session = record;
        // 如果内存里面没有 session.ack 那么使用数据库里的数据
        sessionAck = sessionAck || session.ack || 0;
      } else {
        record = sessionInMemory;
        if (record) {
          session.unread = record.unread || 0;
        }
      }
      cacheSession(session);
      // 计算未读数
      session.unread = session.unread || 0;
      var unread = 0;
      uncountMsgs.forEach(function (msg) {
        // 群通知消息不计入未读数
        // isUnreadable 字段不存在, 或者为 true, 计入未读数
        var countNotifyUnread = self.options.shouldCountNotifyUnread(msg);
        var isUnreadable = (msg.type !== 'notification' || msg.type === 'notification' && countNotifyUnread) && (undef(msg.isUnreadable) || msg.isUnreadable);
        // 如果要同步会话未读数, 那么必须还要满足:
        // - 消息比 session.ack 晚
        // - 不是自己发的消息
        if (isUnreadable && syncSessionUnread) {
          isUnreadable = msg.time > sessionAck && msg.flow !== 'out';
        }
        if (isUnreadable) {
          unread++;
          // 如果需要 syncSessionUnread 并且不支持数据库, 那么需要将所有的未读消息记录下来以便在 markSessionAck 的时候计算未读数
          if (syncSessionUnread && !supportDb) {
            var unreadMsgs = sessionInMemory.unreadMsgs || [];
            unreadMsgs.push(msg);
            session.unreadMsgs = unreadMsgs;
          }
        }
      });
      console.log(session);
      session.unread += unread;
      self.logger.log('msg::putMsg:updateSession: ', session);
      cacheSession(session);
      // 更新未读数, 如果落后, 那么不能存储未读数
      if (supportDb && !backward) {
        // return db.putSession(session)
        return db.updateSession({ id: session.id, unread: session.unread });
      }
    }
  });

  // 通知会话
  if (type === 'onMsg') {
    promise = promise.then(function () {
      // debugger;
      // 如果过滤后的消息为空数组, 则不作处理
      // 如果没有会话, 说明都是被忽略的消息, 那么也不作处理
      if (!!msgs.length && !!session) {
        self.onUpdateSession(session);
        // 如果接收消息，且为当前会话，且设置了同步会话未读数，重置未读数，发消息在onSendMsg中重置
        if (self.options.syncSessionUnread && !notCurrSession) {
          self.api.resetSessionUnread(self.currSessionId);
        }
      }
    });
  } else if (type === 'sendMsg' && !notCurrSession && session && session.lastMsg && session.lastMsg.isLocal) {
    self.onUpdateSession(session);
    self.api.resetSessionUnread(self.currSessionId);
  }
  function cacheSession(session) {
    if (type === 'roamingMsgs' || type === 'offlineMsgs') {
      self.cacheSyncedSession(session);
    }
  }
  return promise.then(function () {
    // 把过滤后的消息返回出去
    return Promise.resolve(msgs);
  });
};

IMProtocolFn.putBroadcastMsgs = function (msgs) {
  var self = this;
  var db = self.db;
  var len = msgs.length;
  if (len > 0) {
    self.doMarkBroadcastMsgsRead(msgs);
    if (db.enable) {
      var timetag = msgs[len - 1].broadcastId;
      db.updateBroadcastMsgTimetag(timetag);
      return db.putBroadcastMsg(msgs).then(function () {
        setTimeout(function () {
          self.doMarkMsgsRead();
          self.options.onbroadcastmsgs(util.copy(msgs));
        }, 0);
        return Promise.resolve(msgs);
      });
    } else {
      setTimeout(function () {
        self.options.onbroadcastmsgs(util.copy(msgs));
      }, 0);
    }
  }
  return msgs;
};

IMProtocolFn.putBroadcastMsg = function (msg) {
  var self = this;
  var db = self.db;
  self.doMarkBroadcastMsgsRead([msg]);
  if (db.enable) {
    if (msg.broadcastId) {
      db.updateBroadcastMsgTimetag(msg.broadcastId);
    }
    return db.putBroadcastMsg(msg).then(function () {
      setTimeout(function () {
        self.options.onbroadcastmsg(util.copy(msg));
      }, 0);
      return Promise.resolve(msg);
    });
  } else {
    setTimeout(function () {
      self.options.onbroadcastmsg(util.copy(msg));
    }, 0);
    return msg;
  }
};

IMProtocolFn.doMarkBroadcastMsgsRead = function (msgs) {
  var sid = 7;
  var cid = 17;
  msgs = msgs.map(function (msg) {
    return msg.broadcastId;
  });
  this.sendCmd('batchMarkRead', {
    sid: sid,
    cid: cid,
    ids: msgs
  });
};

IMProtocolFn.cacheSyncedSession = function (session) {
  // 特殊情况下，会出现还没有初始化，但cacheSyncedSession，导致syncResult未定义
  var self = this;
  if (session && self.syncResult) {
    session = util.merge({}, session);
    // session.unread = session.unread || 0
    self.syncResult.sessions = self.syncResult.sessions || {};
    var sessionId = session.id;
    self.syncResult.sessions[sessionId] = util.merge(self.syncResult.sessions[sessionId], session);
    if (undef(self.syncResult.sessions[sessionId].unread)) {
      self.syncResult.sessions[sessionId].unread = 0;
    }
    self.mergeSession(self.syncResult.sessions[sessionId]);
  }
};

IMProtocolFn.checkMsgUnique = util.genCheckUniqueFunc('idClient');

// 发消息之前要存储该消息
IMProtocolFn.storeSendMsg = function (msg) {
  var self = this;
  // 如果正在同步中, 那么先不存储消息, 等到同步完成之后再存储消息
  if (self.syncing) {
    self.unhandledMsgs.push({
      type: 'sendMsg',
      msg: msg
    });
  } else {
    var promise = self.putMsg(msg, 'sendMsg');
    self.msgPromise = self.msgPromise.then(function () {
      return promise;
    });
    return promise;
  }
};

// 更新发送失败的消息
IMProtocolFn.updateSendMsgError = function (msg) {
  var self = this;
  // 如果正在同步中, 那么先不更新消息, 等到同步完成之后再更新消息
  if (self.syncing) {
    self.unupdatedMsgs.push(msg);
  } else {
    var promise = self.updateMsg(msg);
    self.msgPromise = self.msgPromise.then(function () {
      return promise;
    });
    return promise;
  }
};

// 发了一条消息
IMProtocolFn.onSendMsg = function (packet, isFilter) {
  var self = this;
  var msg = packet.obj && packet.obj.msg || packet.content.msg;
  if (!packet.obj) {
    var db = self.db;
    if (db && db.enable) {
      db.getMsgByIdClient(msg.idClient).then(function (record) {
        if (record) {
          msg = record;
          dealMsg();
        }
      }, function (event) {
        dealMsg();
      });
    }
  } else {
    dealMsg();
  }
  function dealMsg() {
    self.completeMsg(msg);
    // 被对方加入了黑名单
    var blacked = packet.error && packet.error.code === 7101;
    // 如果没有错误或者错误是被拉黑, 服务器端会返回额外的字段
    if (!packet.error || blacked) {
      msg.idServer = packet.content.msg.idServer;
      msg.time = +packet.content.msg.time;
    }
    // 如果有错误，那么重置 status
    if (packet.error) {
      msg.status = 'fail';
    } else {
      msg.status = 'success';
    }
    // 返回给开发者的信息
    msg = self.message.reverse(msg);
    if (isFilter) {
      msg.filter = true;
    }
    packet.obj = msg;
    // 如果正在同步中, 那么先不更新消息, 等到同步完成之后再更新消息
    if (self.syncing) {
      self.unupdatedMsgs.push(msg);
    } else {
      // 发送消息时会存储消息, 那么需要等这个操作结束后再更新消息状态
      self.msgPromise = Promise.all([self.msgPromise, packet.obj.promise]).then(function (records) {
        // 这里返回的是过滤后的消息, 有可能为空数组
        // 为空时表明是重发的消息, 所以依然需要更新到数据库
        if (!records.length) {
          msg.resend = true;
        }
        return self.updateMsg(msg).then(function () {
          // 如果发送或接收消息，且为当前会话，且设置了同步会话未读数
          if (self.options.syncSessionUnread && self.currSessionId === msg.sessionId) {
            self.api.resetSessionUnread(self.currSessionId);
          }
          self.resolveMsgReceiptTask(msg);
          return msg;
        });
      });
    }
  }
};

// 更新本地消息
IMProtocolFn.updateLocalMsg = function (msg) {
  var self = this;
  var promise = self.updateMsg(msg);
  self.msgPromise = self.msgPromise.then(function () {
    return promise;
  });
  return promise;
};

/**
 * 发消息收到回包
 * - 通知开发者, 会话更新了
 * - 如果支持数据库, 更新消息状态
 *     - 更新对应会话, 并通知开发者
 *     - 如果是成功, 那么更新漫游消息时间戳
 * - 如果不支持数据库, 那么更新记录漫游消息时间戳
 * @private
 * @param  {Object} msg 消息对象
 * @return {Void}
 */
IMProtocolFn.updateMsg = function (msg) {
  // debugger;
  // 如果是过滤（云商服专用）, 直接返回
  if (msg.filter) {
    return Promise.resolve(msg);
  }
  var self = this;
  var db = self.db;
  var success = msg.status === 'success';
  var session = Session.genSessionByMsg(msg);
  var isLocal = !!msg.isLocal;
  // 通知开发者, 会话更新了
  // self.onUpdateSession(session)
  if (db.enable) {
    // 更新消息、会话和时间戳
    return db.updateMsg(msg).then(function (record) {
      var p1 = db.updateSession(session);
      var p2 = Promise.resolve();
      var p3 = Promise.resolve();
      // 如果是本地消息, 那么不要更新时间戳
      // 因为是异步的, 所以 record 有可能被删掉了, 所以额外检查一次
      if (success && record && !isLocal) {
        p2 = db.updateRoamingMsgTimetag(record.time);
        if (msg.scene === 'superTeam') {
          p3 = db.updateSuperTeamRoamingMsgTimetag(record.time);
        }
      }
      self.onUpdateSession(session);
      return Promise.all([p1, p2, p3]);
    });
  } else {
    // 如果是本地消息, 那么不要更新时间戳
    if (success && !isLocal) {
      self.timetags.roamingMsgs = msg.time;
    }
    self.onUpdateSession(session);
    return Promise.resolve(msg);
  }
};

// updateMsg 之后也要更新漫游消息时间戳，但是并没有调用此方法，是因为逻辑不太一致，代码略有冗余，但是便于理解
IMProtocolFn.updateRoamingMsgTimetag = function (timetag) {
  var self = this;
  var db = self.db;
  if (db.enable) {
    return db.updateRoamingMsgTimetag(timetag);
  } else {
    self.timetags.roamingMsgs = timetag;
    return Promise.resolve(timetag);
  }
};

/**
 * 检查用户信息是否更新了
 * - 如果不是自己发的消息, 那么检查发消息的人的信息是否被更新了
 * @private
 * @param  {String} account 被检查的用户账号
 * @return {Void}
 */
IMProtocolFn.checkUserUpdate = function (msg) {
  var self = this;
  var account = msg.from;
  if (account === self.account) {
    return Promise.resolve();
  }
  return new Promise(function (resolve) {
    var user = self.userSet[account];
    // 如果没有此用户信息或者用户信息过时了, 那么更新之
    if (!user) {
      refreshUser();
    } else {
      var updateTime = +user.updateTime;
      var userUpdateTime = +msg.userUpdateTime;
      if (!isNaN(updateTime) && !isNaN(userUpdateTime) && util.isNumber(updateTime) && util.isNumber(userUpdateTime) && updateTime < userUpdateTime) {
        refreshUser();
      } else {
        // 没有更新, 算完成
        resolve();
      }
    }

    function refreshUser() {
      self.api.getUser({
        account: account,
        sync: true,
        done: function done(error, user) {
          // debugger;
          if (!error) {
            setTimeout(function () {
              self.logger.log('user::checkUserUpdate: onupdateuser', user.account, user);
              self.options.onupdateuser(user);
            }, 0);
          }
          // 不管有没有错, 都算完成
          resolve();
        }
      });
    }
  });
};

// 在同步过程中, 收发消息都不进行数据库操作, 等到同步完成之后再处理消息
IMProtocolFn.processUnsettledMsgs = function () {
  var self = this;
  // 先处理 unhandledMsgs (包括收到的消息和发送之前的消息)
  // 再处理 unupdatedMsgs (包括发送成功的消息和发送失败的消息)
  self.unhandledMsgs.forEach(function (obj) {
    var msg = obj.msg;
    switch (obj.type) {
      case 'onMsg':
        self.handleMsg(msg);
        break;
      case 'sendMsg':
        // 在现有的 msgPromise 执行完成之后再执行
        self.msgPromise = self.msgPromise.then(function () {
          return self.putMsg(msg);
        });
        break;
      case 'onBroadcastMsg':
        self.msgPromise = self.msgPromise.then(function () {
          return self.putBroadcastMsg(msg);
        });
    }
  });
  self.unupdatedMsgs.forEach(function (msg) {
    // 在现有的 msgPromise 执行完成之后再执行
    self.msgPromise = self.msgPromise.then(function () {
      return self.updateMsg(msg);
    });
  });
  self.resetUnsettledMsgs();
};

IMProtocolFn.onTeamNotificationMsg = function (msg) {
  var self = this;
  var db = self.db;
  var attach = msg.attach;
  var type = attach.type;
  var from = msg.from;
  var teamId = msg.to;
  var timetag = msg.time;
  var team = attach.team;
  var account = attach.account;
  var accounts = attach.accounts;
  switch (type) {
    case 'updateTeam':
      team.updateTime = timetag;
      return self.onUpdateTeam(team);
    case 'addTeamMembers':
      return self.onAddTeamMembers(msg, team, accounts);
    case 'removeTeamMembers':
      return self.onRemoveTeamMembers(team, teamId, accounts);
    case 'acceptTeamInvite':
      return self.onAddTeamMembers(msg, team, [from]);
    case 'passTeamApply':
      return self.onAddTeamMembers(msg, team, [account]);
    case 'addTeamManagers':
      return self.updateTeamManagers(msg, teamId, accounts, true, timetag);
    case 'removeTeamManagers':
      return self.updateTeamManagers(msg, teamId, accounts, false, timetag);
    case 'leaveTeam':
      return self.onRemoveTeamMembers(team, teamId, [from]);
    case 'dismissTeam':
      return self.onDismissTeam(teamId, timetag);
    case 'transferTeam':
      return self.transferTeam(msg, team, from, account);
    case 'updateTeamMute':
      return self.onUpdateTeamMembersMute(msg, team, [account], attach.mute);
    // 超大群相关的：
    case 'updateSuperTeam':
      team.updateTime = timetag;
      return self.onUpdateSuperTeam(team);
    case 'addSuperTeamMembers':
      return self.onAddSuperTeamMembers(msg, team, accounts);
    case 'removeSuperTeamMembers':
      return self.onRemoveSuperTeamMembers(team, teamId, accounts);
    case 'leaveSuperTeam':
      return self.onRemoveSuperTeamMembers(team, teamId, [from]);
    case 'dismissSuperTeam':
      return self.onDismissSuperTeam(teamId, timetag);
  }
};

/* 超大群拉人 */
IMProtocolFn.onAddSuperTeamMembers = function (msg, team, accounts) {
  var self = this;
  var db = self.db;
  var teamId = team.teamId;
  var members = SuperTeamMember.assembleMembers(team, accounts);
  msg.attach.members = members;
  var obj = {
    team: team,
    accounts: accounts,
    members: members
  };
  self.logger.info('team::onAddSuperTeamMembers: ', obj);
  self.options.onAddSuperTeamMembers(util.simpleClone(obj));

  if (!db.enable) return;
  /*
   * 直接merge群成员
   */
  var p1 = db.putSuperTeamMembers(members);
  var p2 = Promise.resolve();
  if (accounts.indexOf(self.account) > -1 && team) {
    p2 = db.putSuperTeam(team);
  }
  return Promise.all([p1, p2]);
};
/*
 * 超大群移出群成员
 * 主动退出超大群
 */
IMProtocolFn.onRemoveSuperTeamMembers = function (team, teamId, accounts) {
  var self = this;
  var db = self.db;
  var obj = {
    team: team,
    accounts: accounts
  };
  self.logger.info('team::onRemoveSuperTeamMembers:', obj);
  self.options.onRemoveSuperTeamMembers(util.simpleClone(obj));
  if (!db.enable) {
    return;
  }
  /*
     * 如果是别人被踢了, 那么移除群成员
     * 如果是自己被踢了, 那么离开该群
     */
  if (accounts.indexOf(self.account) === -1) {
    var p1 = db.removeSuperTeamMembersByAccounts(teamId, accounts);
    var p2 = Promise.resolve();
    if (team) {
      p2 = db.putSuperTeam(team);
    }
    return Promise.all([p1, p2]);
  } else {
    return db.leaveSuperTeam(teamId);
  }
};

IMProtocolFn.onDismissSuperTeam = function (teamId, timetag) {
  var self = this;
  var db = self.db;
  var obj = {
    teamId: teamId
  };
  self.logger.info('team::onDismissSuperTeam:', obj);
  self.options.onDismissSuperTeam(obj);
  if (!db.enable) {
    return;
  }
  return db.dismissSuperTeam(teamId, timetag);
};
/*
 * 普通群拉人
 * 高级群接受入群邀请
 */
IMProtocolFn.onAddTeamMembers = function (msg, team, accounts) {
  var self = this;
  var db = self.db;
  var teamId = team.teamId;
  var members = TeamMember.assembleMembers(team, accounts);
  msg.attach.members = members;
  var obj = {
    team: team,
    accounts: accounts,
    members: members
  };
  self.logger.info('team::onAddTeamMembers: ', obj);
  self.options.onAddTeamMembers(util.simpleClone(obj));
  if (!db.enable) {
    return;
  }
  var p1;
  var p2 = db.putTeam(team);
  /*
     * 如果是别人被拉进来了, 那么拼接群成员列表
     * 如果是自己被拉进来了, 那么同步一次群成员列表
     */
  var oldTeam = accounts.indexOf(self.account) === -1;
  if (oldTeam) {
    p1 = db.putTeamMembers(members);
  } else {
    self.logger.warn('team::onAddTeamMembers: user join team', teamId);
    p2 = new Promise(function (resolve) {
      self.api.getTeamMembers({
        teamId: teamId,
        sync: true,
        done: function done() {
          resolve();
        }
      });
    });
  }
  return Promise.all([p1, p2]);
};

/*
 * 移出群成员
 * 主动退群
 */
IMProtocolFn.onRemoveTeamMembers = function (team, teamId, accounts) {
  var self = this;
  var db = self.db;
  var obj = {
    team: team,
    accounts: accounts
  };
  self.logger.info('team::onRemoveTeamMembers:', obj);
  self.options.onRemoveTeamMembers(util.simpleClone(obj));
  if (!db.enable) {
    return;
  }
  /*
     * 如果是别人被踢了, 那么移除群成员
     * 如果是自己被踢了, 那么离开该群
     */
  if (accounts.indexOf(self.account) === -1) {
    var p1 = db.removeTeamMembersByAccounts(teamId, accounts);
    var p2 = Promise.resolve();
    if (team) {
      p2 = db.putTeam(team);
    }
    return Promise.all([p1, p2]);
  } else {
    return db.leaveTeam(teamId);
  }
};

IMProtocolFn.updateTeamManagers = function (msg, teamId, accounts, isManager, timetag) {
  var self = this;
  var db = self.db;
  var members = msg.attach.members = accounts.map(function (account) {
    return {
      id: TeamMember.genId(teamId, account),
      type: isManager ? 'manager' : 'normal',
      updateTime: timetag
    };
  });
  var team = {
    teamId: '' + teamId,
    memberUpdateTime: timetag
  };
  msg.attach.team = team;

  var obj = {
    team: team,
    accounts: accounts,
    isManager: isManager,
    members: members
  };
  self.logger.info('team::updateTeamManagers:', obj);
  self.options.onUpdateTeamManagers(util.simpleClone(obj));

  if (!db.enable) {
    return;
  }
  var p1 = db.updateTeam(team);
  var p2 = db.updateTeamManagers(teamId, accounts, isManager, timetag);
  return Promise.all([p1, p2]);
};

IMProtocolFn.onDismissTeam = function (teamId, timetag) {
  var self = this;
  var db = self.db;
  var obj = {
    teamId: teamId
  };
  self.logger.info('team::onDismissTeam:', obj);
  self.options.onDismissTeam(obj);
  if (!db.enable) {
    return;
  }
  return db.dismissTeam(teamId, timetag);
};

IMProtocolFn.transferTeam = function (msg, team, from, account) {
  var self = this;
  var db = self.db;
  var teamId = team.teamId;
  var memberUpdateTime = team.memberUpdateTime;
  var oldOwner = {
    id: TeamMember.genId(teamId, from),
    type: 'normal',
    updateTime: memberUpdateTime
  };
  var newOwner = {
    id: TeamMember.genId(teamId, account),
    type: 'owner',
    updateTime: memberUpdateTime
  };
  msg.attach.members = [oldOwner, newOwner];

  var obj = {
    team: team,
    from: oldOwner,
    to: newOwner
  };
  self.logger.info('team::transferTeam:', obj);
  self.options.onTransferTeam(util.simpleClone(obj));

  if (!db.enable) {
    return;
  }
  return db.transferTeam(team, from, account);
};

IMProtocolFn.onUpdateTeamMembersMute = function (msg, team, accounts, mute) {
  var self = this;
  var db = self.db;
  var teamId = teamId;
  var members = accounts.map(function (account) {
    return {
      id: TeamMember.genId(team.teamId, account),
      account: account,
      teamId: team.teamId,
      mute: mute,
      updateTime: team.memberUpdateTime
    };
  });
  msg.attach.members = members;

  var obj = {
    team: team,
    accounts: accounts,
    members: members,
    mute: mute
  };
  self.logger.info('team::onUpdateTeamMembersMute:', obj);
  self.options.onUpdateTeamMembersMute(util.simpleClone(obj));

  if (!db.enable) {
    return;
  }
  var p1 = db.updateTeamMembers(members);
  var p2 = db.putTeam(team);
  return Promise.all([p1, p2]);
};

IMProtocolFn.onHistoryMsgs = function (packet) {
  if (!packet.error) {
    packet.obj.msgs = this.message.reverseMsgs(packet.content.msgs);
  }
};

IMProtocolFn.isFilterMsgs = function (msgs) {
  return !!msgs[0].filter;
};

// 分割消息, 将消息分为点对点消息、群消息和过滤消息
IMProtocolFn.splitMsgs = function (msgs, p2pMsgs, teamMsgs, filterMsgs) {
  msgs.forEach(function (msg) {
    if (!msg.filter) {
      switch (msg.scene) {
        case 'p2p':
          p2pMsgs.push(msg);
          break;
        case 'team':
          teamMsgs.push(msg);
          break;
      }
    } else {
      filterMsgs.push(msg);
    }
  });
};

/*
 * 标记消息已读
 * - 当收到离线消息和在线消息时
 *     - 如果支持数据库, 那么会存储消息和未读数, 所以标记消息已读
 *     - 如果不支持数据库, 但是自动标记已读(默认配置), 那么会标记消息
 *     - 如果不支持数据库, 也不自动标记消息已读, 用户可以主动标记消息已读
 */
IMProtocolFn.markMsgRead = function (msgs, force) {
  if (!util.isArray(msgs)) {
    msgs = [msgs];
  }
  var self = this;
  var db = self.db;
  if (db.enable || self.options.autoMarkRead || force) {
    // 消息分为点对点消息、群消息、过滤消息
    var p2pMsgs = [];
    var teamMsgs = [];
    var filterMsgs = [];
    self.splitMsgs(msgs, p2pMsgs, teamMsgs, filterMsgs);
    self.markP2pMsgsRead(p2pMsgs);
    self.markTeamMsgsRead(teamMsgs);
    self.markFilterMsgsRead(filterMsgs);
  }
};
IMProtocolFn.markP2pMsgsRead = function (msgs) {
  if (msgs.length) {
    var sid = configMap.idMap.msg.id;
    var cid = configMap.idMap.msg.msg;
    this.doMarkMsgsRead(sid, cid, msgs);
  }
};
IMProtocolFn.markTeamMsgsRead = function (msgs) {
  if (msgs.length) {
    var sid = configMap.idMap.team.id;
    var cid = configMap.idMap.team.teamMsg;
    this.doMarkMsgsRead(sid, cid, msgs);
  }
};
IMProtocolFn.markFilterMsgsRead = function (msgs) {
  if (msgs.length) {
    var sid = configMap.idMap.filter.id;
    var cid = configMap.idMap.filter.filterMsg;
    this.doMarkMsgsRead(sid, cid, msgs);
  }
};

/*
 * 标记系统通知已收到
 * - 当收到离线系统通知和在线系统通知时
 *     - 如果支持数据库, 那么会存储系统通知和未读数, 所以标记系统通知已读
 *     - 如果不支持数据库, 那么不存储系统通知和未读数, 所以不标记系统通知已读
 * - 当用户主动标记某条系统通知已读
 */
IMProtocolFn.markSysMsgRead = function (sysMsgs, force) {
  if (!util.isArray(sysMsgs)) {
    sysMsgs = [sysMsgs];
  }
  var self = this;
  var db = self.db;
  if (db.enable || self.options.autoMarkRead || force) {
    var sid, cid;
    if (self.isFilterMsgs(sysMsgs)) {
      sid = configMap.idMap.filter.id;
      cid = configMap.idMap.filter.filterSysMsg;
    } else {
      sid = configMap.idMap.msg.id;
      cid = configMap.idMap.msg.sysMsg;
    }
    self.doMarkMsgsRead(sid, cid, sysMsgs);
  }
};

IMProtocolFn.doMarkMsgsRead = function (sid, cid, msgs) {
  if (msgs && msgs.length) {
    if (msgs[0].attach && (msgs[0].attach.type === 'netcallBill' || msgs[0].attach.type === 'netcallMiss')) {
      sid = 9;
      cid = 11;
    }
    this.sendCmd('batchMarkRead', {
      sid: sid,
      cid: cid,
      ids: msgs.map(function (msg) {
        return msg.idServer;
      })
    });
  }
};

/***/ }),

/***/ "./src/im/protocol/im/msgDelete.js":
/*!*****************************************!*\
  !*** ./src/im/protocol/im/msgDelete.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var SystemMessage = __webpack_require__(/*! im/model/systemMessage */ "./src/im/model/systemMessage.js");
var Session = __webpack_require__(/*! im/model/session */ "./src/im/model/session.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
// 撤回消息，发起撤回操作方的回调
IMProtocolFn.onDeleteMsg = function (packet) {
  var db = this.db;
  delete packet.obj.sysMsg;
  if (!packet.error) {
    packet.promise = this.deleteLocalMsg(packet.obj.msg).then(function () {
      var deletedMsg = packet.obj.msg;
      if (db.enable) {
        // 后端的时间戳临界判断有问题, 手动 +1
        db.getTimetag('deleteMsg').then(function (timetag) {
          timetag = timetag || 0;
          if (deletedMsg.time >= timetag) {
            db.updateDeleteMsgTimetag(new Date().getTime());
          }
        });
      }
    });
  }
};
// 撤回消息通知，被撤回方的回调
IMProtocolFn.onMsgDeleted = function (packet) {
  if (!packet.error) {
    var self = this;
    var db = self.db;
    var sysMsg = SystemMessage.reverse(packet.content.sysMsg);
    sysMsg = self.processDeleteMsgSysMsg(sysMsg);
    self.markSysMsgRead(sysMsg);
    // 删除对应的消息后通知开发者
    self.deleteLocalMsg(sysMsg.msg).then(function () {
      if (db.enable) {
        // 后端的时间戳临界判断有问题, 手动 +1
        db.updateDeleteMsgTimetag(sysMsg.time + 1);
      }
      self.handleSysMsg(sysMsg);
    });
  }
};

IMProtocolFn.processDeleteMsgSysMsg = function (sysMsg) {
  var self = this;
  sysMsg.msg = {};['scene', 'from', 'to'].forEach(function (key) {
    sysMsg.msg[key] = sysMsg[key];
  });
  sysMsg.msg.idClient = sysMsg.deletedIdClient;
  sysMsg.msg.idServer = sysMsg.deletedIdServer;
  sysMsg.msg.time = sysMsg.deletedMsgTime;
  sysMsg.msg.fromNick = sysMsg.deletedMsgFromNick;
  sysMsg.opeAccount = sysMsg.opeAccount || sysMsg.from;
  sysMsg.msg.opeAccount = sysMsg.opeAccount;
  self.message.Message.setExtra(sysMsg.msg, self.account);
  return sysMsg;
};

// 同步到离线或者漫游撤回消息的通知
IMProtocolFn.onDeleteMsgOfflineRoaming = function (packet) {
  if (!packet.error) {
    var self = this;
    var type = +packet.content.type === 1 ? 'offline' : 'roaming';
    var sysMsgs = SystemMessage.reverseSysMsgs(packet.content.sysMsgs, {
      mapper: function mapper(sysMsg) {
        return self.processDeleteMsgSysMsg(sysMsg);
      }
    });
    self.logger.info('msg::onDeleteMsgOfflineRoaming: on delete ' + type, sysMsgs);
    // 如果是离线, 那么需要标记已收到
    if (type === 'offline') {
      self.markSysMsgRead(sysMsgs);
    }
    // 存储时间戳
    var timetag = packet.content.timetag;
    self.timetags.deleteMsg = timetag;
    self.syncResult.deleteMsgTimetag = timetag;
    // 存储系统通知
    var promise = self.putSysMsg(sysMsgs, 'offlineSysMsgs').catch(function (error) {
      self.logger.error('msgDelete::onDeleteMsgOfflineRoaming: ', error);
      return Promise.reject(error);
    });
    promise.cmd = 'deleteMsgSysMsgs ' + type;
    self.syncPromiseArray.push(promise);
    self.syncResult.deleteMsgSysMsgs = self.syncResult.deleteMsgSysMsgs || [];
    self.syncResult.deleteMsgSysMsgs.push({
      type: type,
      sysMsgs: sysMsgs
    });
  }
};

// 根据离线和漫游的撤回消息系统通知来撤回消息, 同时修改回传给用户的会话
// 最后再存储时间戳
IMProtocolFn.deleteMsgOfflineRoaming = function (deleteMsgSysMsgs, sessions) {
  if (!deleteMsgSysMsgs) {
    return Promise.resolve();
  }
  var self = this;
  self.logger.info('msg::deleteMsgOfflineRoaming: ', deleteMsgSysMsgs, sessions);
  var db = self.db;
  var array = [];
  deleteMsgSysMsgs.forEach(function (obj) {
    obj.sysMsgs.forEach(function (sysMsg) {
      var p = self.deleteLocalMsg(sysMsg.msg, {
        // 这里不走 updateLocalSession, 是因为它会通知会话被更新了, 但是同步过程中不需要这个更新
        cbUpdateSession: function cbUpdateSession(session) {
          // 修正内存里的会话
          session = self.mergeSession(session);
          session = util.simpleClone(session);
          Session.trim(session);
          // 修正返回给用户的会话
          var index = util.findObjIndexInArray(sessions, {
            value: session.id
          });
          if (index !== -1) {
            sessions[index] = util.merge({}, sessions[index], session);
          }
          // 修改数据库里的会话
          if (db.enable) {
            return db.updateSession(session);
          }
        }
      });
      array.push(p);
    });
  });
  return Promise.all(array).then(function () {
    if (db.enable) {
      return db.updateDeleteMsgTimetag(self.syncResult.deleteMsgTimetag);
    }
  });
};

IMProtocolFn.deleteLocalMsg = function (msg, options) {
  var self = this;
  var db = self.db;
  options = options || {};
  var cbUpdateSession = options.cbUpdateSession || self.updateLocalSession.bind(self);
  if (db.enable && msg) {
    // 如果删除的是最后一条消息, 那么需要更新会话，如果初始化时设置了“被撤回消息时回滚未读数”则需要处理会话未读数
    var isLast = false; // 是否是最后一条消息
    var lastMsg = null; // 存储新的最后一条消息
    var delMsg = null; // 存储将要被删除的消息
    var sessionId = msg.sessionId;
    return db.getMsgs({
      sessionId: sessionId,
      limit: 1
    }).then(function (msgs) {
      if (msgs && msgs[0] && msgs[0].idClient === msg.idClient) {
        isLast = true;
      }
    }).then(function () {
      return db.getMsgByIdClient(msg.idClient);
    }).then(function (resMsg) {
      delMsg = resMsg;
      return db.deleteMsg(msg.idClient);
    }).then(function () {
      if (isLast) {
        return db.getMsgs({
          sessionId: sessionId,
          limit: 1
        });
      }
    }).then(function (msgs) {
      if (isLast) {
        if (msgs && msgs[0]) {
          lastMsg = msgs[0];
        }
      }
    }).then(function () {
      // 撤回消息是否同时撤销此消息影响的未读数，需要则查询
      if (self.options.rollbackDelMsgUnread) {
        return db.getSessions({
          sessionId: sessionId
        });
      }
    }).then(function (record) {
      var updateSession = {
        id: sessionId,
        lastMsg: lastMsg
        // 当标记已读时间戳 msgReceiptTime 大于等于 被删除消息时间戳 time 则表示已经读过了，不需要减去回滚未读数；当 to 是自己收到的消息，才需要减少未读数
      };var msgReceiptTime = record && record.msgReceiptTime || 0;
      if (record && delMsg && msgReceiptTime < delMsg.time && self.options.account === delMsg.to && record.unread) {
        self.logger.log('msgDelete::deleteLocalMsg:db.getSessions: ', record);
        updateSession.unread = record.unread - 1;
      }
      return cbUpdateSession(updateSession);
    });
  } else {
    // 无数据库时处理删除消息后的未读数
    if (self.options.rollbackDelMsgUnread && msg && msg.sessionId) {
      var record = self.findSession(msg.sessionId);
      var msgReceiptTime = record.msgReceiptTime || 0;
      if (record && msgReceiptTime < msg.time && self.options.account === msg.to && record.unread) {
        self.logger.log('msgDelete::deleteLocalMsg:getSessions: ', record);
        record.unread = record.unread - 1;
        self.onUpdateSession(record);
      }
    }
    return Promise.resolve();
  }
};

/***/ }),

/***/ "./src/im/protocol/im/msgReceipt.js":
/*!******************************************!*\
  !*** ./src/im/protocol/im/msgReceipt.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

IMProtocolFn.onOfflineMsgReceipts = function (packet) {
  var self = this;
  var db = self.db;
  var rawMsgReceipts = packet.content.msgReceipts;
  var msgReceipts = self.syncResult.msgReceipts = [];
  // 首先要检查, 如果存在此会话, 那么才会存储对应的已读回执时间戳
  var promiseArray = [];
  var promise;
  var cmd = 'msgReceipts';
  var sessions = self.syncResult.sessions || {};
  rawMsgReceipts.forEach(function (msgReceipt) {
    msgReceipt.time = +msgReceipt.time;
    var sessionId = msgReceipt.sessionId = 'p2p-' + msgReceipt.from;
    cmd += '-' + sessionId;
    promise = Promise.resolve();
    // 只有数据库里面有对应的会话或者同步到该回话, 才存储已读回执时间戳
    var sessionSynced = sessions[sessionId];
    if (db.enable) {
      promise = db.getSession(sessionId).then(function (session) {
        session = session || sessionSynced;
        if (session && self.shouldUpdateSessionFromMsgReceipt(session, msgReceipt)) {
          var update = self.genSessionFromMsgReceipt(session, msgReceipt);
          // 同步的时候会出现并发存会话的情况，lastMsg会不准，需要从内存数据中取做比较
          var tempSession = self.syncResult.sessions;
          if (tempSession && tempSession[sessionId]) {
            tempSession = tempSession[sessionId];
            if (tempSession.lastMsg && update.lastMsg && tempSession.lastMsg.time > update.lastMsg.time) {
              update.lastMsg = tempSession.lastMsg;
            }
          }
          return db.putSession(update).then(function (session) {
            // debugger;
            if (session) {
              self.cacheSyncedSession(session);
            }
          });
        }
      }).catch(function (error) {
        self.logger.error('msgReceipt::onOfflineMsgReceipt: ', error);
        return Promise.reject(error);
      });
    } else if (sessionSynced) {
      msgReceipts.push(msgReceipt);
    }
    promiseArray.push(promise);
  });
  promise = Promise.all(promiseArray).then(function () {
    if (db.enable) {
      return db.updateMsgReceiptsTimetag(packet.content.timetag);
    }
  });
  promise.cmd = cmd;
  self.syncPromiseArray.push(promise);
};

// 将 msgReceipts 数据 merge 到 sessionSet 里面
IMProtocolFn.mergeSessionAndMsgReceipts = function (sessions, msgReceipts) {
  var self = this;
  var sessionMap = {};
  sessions = sessions || [];
  msgReceipts = msgReceipts || [];
  sessions.forEach(function (session) {
    sessionMap[session.id] = session;
  });
  msgReceipts.forEach(function (msgReceipt) {
    // debugger;
    var session = sessionMap[msgReceipt.sessionId];
    if (self.shouldUpdateSessionFromMsgReceipt(session, msgReceipt)) {
      var update = self.genSessionFromMsgReceipt(session, msgReceipt);
      sessions = self.api.mergeSessions(sessions, update);
    }
  });
  return sessions;
};

IMProtocolFn.shouldUpdateSessionFromMsgReceipt = function (session, msgReceipt) {
  // debugger;
  // 如果没有会话, 或者会话没有消息回执时间服务器时间, 或者同步到的时间戳大于会话的上次服务器时间戳
  // 用同步到的时间戳覆盖消息回执时间戳和消息回执服务器时间戳
  return !session || !session.msgReceiptServerTime || msgReceipt.time > session.msgReceiptServerTime;
};

IMProtocolFn.genSessionFromMsgReceipt = function (session, msgReceipt) {
  var time = msgReceipt.time;
  var update = {
    id: msgReceipt.sessionId,
    msgReceiptTime: time,
    msgReceiptServerTime: time
  };
  if (session && session.id === msgReceipt.sessionId) {
    update = util.merge({}, session, update);
  }
  if (!session || !session.updateTime) {
    update.updateTime = time;
  }
  return update;
};

IMProtocolFn.onMsgReceipt = function (packet) {
  var self = this;
  var db = self.db;
  var msgReceipt = packet.content.msgReceipt;
  msgReceipt.time = +msgReceipt.time;
  var idClient = msgReceipt.idClient;
  var promise = Promise.resolve();
  if (db.enable && idClient) {
    promise = db.getMsgByIdClient(idClient);
  }
  promise.then(function (msg) {
    // debugger;
    // 如果能拿到 idClient 对应的消息, 那么将消息的时间作为消息回执时间
    // 否则将服务器返回的时间戳作为消息回执时间
    // 消息回执时间表示此时间及其之前的所有消息, 对方均已读
    var msgReceiptTime;
    if (msg) {
      // 只有当消息发送到服务器的时候（不论成功还是失败，比如说由于被拉黑而造成服务器认为发送失败）
      // 才更新消息回执时间戳，否则等消息成功发送后再更新
      // 模拟的时候可以执行到此，修改 delete idServer, 同时修改 status 为 fail，然后再重新发送该条消息即可
      // delete msg.idServer
      // data.msgMap[msg.idClient].status = 'fail';
      if (msg.idServer) {
        msgReceiptTime = msg.time;
      } else {
        self.msgReceiptTasks[idClient] = msgReceipt;
        return;
      }
    } else {
      msgReceiptTime = msgReceipt.time;
    }
    msgReceipt.msgReceiptTime = msgReceiptTime;
    self.updateSessionMsgReceiptTime(msgReceipt);
  });
};

IMProtocolFn.resolveMsgReceiptTask = function (msg) {
  // debugger;
  var self = this;
  var msgReceipt = self.msgReceiptTasks[msg.idClient];
  if (msgReceipt) {
    msgReceipt.msgReceiptTime = msg.time;
    this.updateSessionMsgReceiptTime(msgReceipt);
  }
};

IMProtocolFn.updateSessionMsgReceiptTime = function (msgReceipt) {
  // debugger;
  var self = this;
  var db = self.db;
  var session = {
    id: 'p2p-' + msgReceipt.from,
    msgReceiptTime: msgReceipt.msgReceiptTime,
    msgReceiptServerTime: msgReceipt.time
  };
  if (db.enable) {
    db.putSession(session);
  }
  self.onUpdateSession(session);
};

IMProtocolFn.onSendMsgReceipt = function (packet) {
  var self = this;
  if (!packet.error) {
    var msgReceiptRequest = packet.obj.msgReceipt;
    // 发送的时间
    var time1 = +msgReceiptRequest.time;
    // 服务器回包时间
    var time2 = +packet.content.msgReceipt.time;
    var session = self.sessionSet['p2p-' + msgReceiptRequest.to];
    // 取较小的时间作为上次发送已读回执的时间
    // 控制发送已读回执的频率
    // 如果下次发送已读回执时的消息时间小于此值, 那么忽略之
    session.msgReceiptSendTime = Math.min(time1, time2);
  }
};

// 是否应该发送已读回执
IMProtocolFn.shouldSendMsgReceipt = function (msg) {
  // 只有 'p2p' 消息才应该发送已读回执
  if (msg && msg.scene === 'p2p' && msg.status === 'success') {
    var session = this.sessionSet[msg.sessionId];
    // 只有有会话才应该发送已读回执
    if (session) {
      var msgReceiptSendTime = session.msgReceiptSendTime;
      // 如果没有发送过已读回执或者
      // 发送过已读回执的时间戳小于消息时间戳
      // 则应该发送已读回执
      return !msgReceiptSendTime || msgReceiptSendTime < msg.time;
    }
  }
  return false;
};

// 该条消息是否被对方读过
IMProtocolFn.isMsgRemoteRead = function (msg) {
  var self = this;
  // 只有 'p2p' 并且成功发送的消息才进行判断
  if (msg && msg.scene === 'p2p' && msg.flow === 'out' && msg.status === 'success') {
    var session = self.sessionSet[msg.sessionId];
    // 只有有已读回执时间戳的会话才进行判断
    if (session && session.msgReceiptTime) {
      // 当消息时间戳不大于已读回执时间戳时, 表示已被对方读过了
      return msg.time <= session.msgReceiptTime;
    }
  }
  return false;
};

/***/ }),

/***/ "./src/im/protocol/im/notify.js":
/*!**************************************!*\
  !*** ./src/im/protocol/im/notify.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var PushNotificationMultiportConfig = __webpack_require__(/*! im/model/pushNotificationMultiportConfig */ "./src/im/model/pushNotificationMultiportConfig.js");

IMProtocolFn.processNotify = function (packet) {
  var self = this;
  switch (packet.cmd) {
    // 离线session+team消息同步通知
    case 'syncOfflineMsgs':
      self.onOfflineMsgs(packet);
      break;
    // 批量标记协议已读
    case 'batchMarkRead':
      break;
    // 离线sysMsg通知
    case 'syncOfflineSysMsgs':
      self.onOfflineSysMsgs(packet);
      break;
    // 漫游消息同步通知
    // 每个会话返回一个包
    // 不需要标记已读
    case 'syncRoamingMsgs':
    case 'syncSuperTeamRoamingMsgs':
      self.onRoamingMsgs(packet);
      break;
    // 离线过滤的消息通知
    case 'syncOfflineFilterMsgs':
      self.onOfflineMsgs(packet, true);
      break;
    // 离线过滤的sysMsg通知
    case 'syncOfflineFilterSysMsgs':
      self.onOfflineSysMsgs(packet, true);
      break;
    case 'syncMsgReceipts':
      self.onOfflineMsgReceipts(packet);
      break;
    case 'syncDonnop':
      self.onDonnop(packet, true);
      break;
    case 'syncSessionAck':
      self.syncSessionAck(packet);
      break;
    case 'syncRobots':
      self.onRobots(packet);
      break;
    case 'syncBroadcastMsgs':
      self.onBroadcastMsgs(packet);
      break;
    default:
      break;
  }
};

/*
 * 收到多端推送配置项
 * - 同步 syncDonnop
 * - 多端操作同步 syncUpdateDonnop
 */
IMProtocolFn.onDonnop = function (packet, isSync) {
  if (!packet.error) {
    var self = this;
    var db = self.db;
    // 解析配置
    var donnop = PushNotificationMultiportConfig.reverse(packet.content.donnop);
    self.mergeDonnop(donnop);
    var promise = self.dbDonnop();
    if (isSync) {
      // 存储时间戳
      var timetag = packet.content.timetag;
      self.timetags.donnop = timetag;
      if (db.enable) {
        promise = promise.then(function () {
          return self.db.updateDonnopTimetag(timetag);
        }).catch(function (error) {
          self.logger.error('notify::onDonnop: ', error);
          return Promise.reject(error);
        });
      }
      promise.cmd = 'donnop';
      self.syncPromiseArray.push(promise);
    } else {
      self.onPushNotificationMultiportConfigUpdate();
    }
  }
};

IMProtocolFn.onUpdateDonnop = function (packet) {
  var self = this;
  if (!packet.error) {
    var obj = packet.obj;
    if (obj) {
      self.mergeDonnop(util.filterObj(obj, ['shouldPushNotificationWhenPCOnline']));
      self.dbDonnop();
      self.onPushNotificationMultiportConfigUpdate();
    }
  }
};

IMProtocolFn.getPushNotificationMultiportConfig = function () {
  var self = this;
  return util.merge({}, self.pushNotificationMultiportConfig);
};

IMProtocolFn.mergeDonnop = function (donnop) {
  var self = this;
  self.pushNotificationMultiportConfig = util.merge({}, self.pushNotificationMultiportConfig, donnop);
};

IMProtocolFn.dbDonnop = function () {
  var self = this;
  var db = self.db;
  if (db.enable) {
    return self.db.setDonnop(self.pushNotificationMultiportConfig);
  } else {
    return Promise.resolve();
  }
};

IMProtocolFn.onPushNotificationMultiportConfigUpdate = function () {
  var self = this;
  setTimeout(function () {
    var config = self.getPushNotificationMultiportConfig();
    self.logger.info('link::onPushNotificationMultiportConfigUpdate:', config);
    self.options.onPushNotificationMultiportConfigUpdate(config);
  });
};

/***/ }),

/***/ "./src/im/protocol/im/robot.js":
/*!*************************************!*\
  !*** ./src/im/protocol/im/robot.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

// 收到机器人列表消息
IMProtocolFn.onRobots = function (packet) {
  var self = this;
  var content = packet.content;

  if (util.isFunction(self.options.onrobots)) {
    if (Array.isArray(content.robots)) {
      var robots = content.robots.filter(function (item) {
        if (!item.botid) {
          return false;
        }
        return true;
      });
      if (robots.length > 0) {
        self.options.onrobots(robots || []);
      }
    }
  }
};

/***/ }),

/***/ "./src/im/protocol/im/session.js":
/*!***************************************!*\
  !*** ./src/im/protocol/im/session.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var Session = __webpack_require__(/*! im/model/session */ "./src/im/model/session.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");

IMProtocolFn.mergeSession = function (session) {
  session = util.copyWithNull(session);
  var sessionSet = this.sessionSet;
  var sessionId = session.id;
  var oldSession = sessionSet[sessionId];
  // 如果最后一条消息的时间戳比当前最后一条消息的小, 那么不更新 lastMsg 字段(适用于本地消息)
  if (oldSession && oldSession.lastMsg && session && session.lastMsg && session.lastMsg.isLocal) {
    var t1 = oldSession.lastMsg.time || 0;
    var t2 = session.lastMsg.time || 0;
    if (t2 < t1) {
      return oldSession;
    }
  }
  sessionSet[sessionId] = util.merge(oldSession, session);
  session = sessionSet[sessionId];
  if (util.undef(session.unread)) {
    session.unread = 0;
  }
  return session;
};

IMProtocolFn.mergeSessions = function (sessions) {
  var self = this;
  sessions = sessions || [];
  sessions.forEach(function (session) {
    self.mergeSession(session);
  });
};

// 删除内存里的会话记录
IMProtocolFn.deleteLocalSession = function (sessionIds) {
  var self = this;
  if (!util.isArray(sessionIds)) {
    sessionIds = [sessionIds];
  }
  sessionIds.forEach(function (sessionId) {
    delete self.sessionSet[sessionId];
  });
};

IMProtocolFn.onDeleteSessions = function (packet) {
  packet.obj = packet.obj.sessions.map(function (session) {
    return Session.parse(session);
  });
};

// 更新会话的通知，触发条件有：
// 1.新增一条消息，并且无论本地是否存在该消息所属的会话
// 2.所属会话未读数清零
// 3.所说会话的最后一条消息的内容发送变化（比如，发送成功状态、发送时间更新为服务器时间）
// 4.删除消息，并且该消息是当前会话的最后一条消息
IMProtocolFn.onUpdateSession = function (session) {
  var self = this;
  return new Promise(function (resolve) {
    if (session) {
      session = self.mergeSession(session);
      session = util.simpleClone(session);
      Session.trim(session);
      if (Session.isComplete(session)) {
        // setTimeout(function () {
        self.logger.info('session::onUpdateSession:', session.id, util.simpleClone(session));
        self.options.onupdatesession(session);
        resolve(session);
        // }, 0)
      }
    } else {
      resolve(session);
    }
  });
};

/*
 * 设置当前会话, 并重置它的未读数
 */
IMProtocolFn.setCurrSession = function (sessionId) {
  var self = this;
  sessionId = '' + sessionId;
  self.currSessionId = sessionId;
  self.logger.info('session::setCurrSession:', sessionId);
};

IMProtocolFn.findSession = function (sessionId) {
  return this.sessionSet[sessionId];
};

/*
 * 重置某个会话未读数
 *
 * - 如果没有该会话, 那么直接返回
 */
IMProtocolFn.resetSessionUnread = function (sessionId) {
  sessionId = '' + sessionId;
  var self = this;
  var db = self.db;
  var session;
  if (!self.findSession(sessionId)) {
    self.logger.warn('session::resetSessionUnread: no session ' + sessionId);
    return;
  }
  if (db.enable) {
    db.resetSessionUnread(sessionId);
  }
  // 如果没有设置自动标记会话已读
  if (!self.options.autoMarkRead && self.sessionUnreadMsgs && self.sessionUnreadMsgs[sessionId]) {
    var currMsgs = self.sessionUnreadMsgs[sessionId];
    self.markMsgRead(currMsgs, true);
    self.sessionUnreadMsgs[sessionId] = [];
  }
  updateSession();
  function updateSession() {
    session = {
      id: sessionId,
      unread: 0
    };
    self.onUpdateSession(session);
  }
};

// 插入一条本地回话记录, 如果已存在则报错
IMProtocolFn.insertLocalSession = function (options) {
  var self = this;
  var db = self.db;
  var sessionSet = self.sessionSet;
  return new Promise(function (resolve, reject) {
    var scene = options.scene;
    var to = options.to;
    var sessionId = scene + '-' + to;
    var session = self.findSession(sessionId);
    if (!session) {
      // 会话更新的时间, 如果不填, SDK 会设置一个比当前所有会话更新时间大的一个时间
      var updateTime;
      if (util.isNumber(options.updateTime)) {
        updateTime = options.updateTime;
      } else {
        var times = [];
        var s;
        for (var key in sessionSet) {
          if (sessionSet.hasOwnProperty(key)) {
            s = sessionSet[key];
            if (util.isNumber(s.updateTime)) {
              times.push(s.updateTime);
            }
          }
        }
        updateTime = Math.max.apply(Math, times) + 1;
        updateTime = Math.max(updateTime, +new Date());
      }
      // 找一下会话的最后一条历史消息
      var p = Promise.resolve();
      if (db.enable) {
        p = db.getMsgs({
          sessionId: sessionId,
          limit: 1
        });
      }
      p.then(function (msgs) {
        // 如果有最后一条消息, 那么根据它来生成会话并更新 updateTime
        if (util.isArray(msgs) && msgs.length === 1) {
          var msg = msgs[0];
          session = Session.genSessionByMsg(msg);
          session.updateTime = updateTime;
        } else {
          // 如果没有, 手动构造会话
          session = {
            id: sessionId,
            scene: scene,
            to: to,
            updateTime: updateTime,
            lastMsg: null
          };
        }
        if (db.enable) {
          db.putSession(session).then(resolve, reject);
        } else {
          resolve(session);
        }
        self.onUpdateSession(session);
      });
    } else {
      // self.logger.warn('session::insertLocalSession: session already exist', session)
      reject(NIMError.sessionExist({
        callFunc: 'session::insertLocalSession',
        session: session
      }));
    }
  });
};
/**
 * options
 * flag 是否删除最后条消息
 */

IMProtocolFn.updateLocalSession = function (options, flag) {
  var self = this;
  return new Promise(function (resolve, reject) {
    var db = self.db;
    var session = self.findSession(options.id);
    if (session) {
      var p = Promise.resolve();
      // 只有在撤回消息同时撤销此消息影响的未读数时会传unread(rollbackDelMsgUnread)
      var obj = util.filterObj(options, 'id lastMsg localCustom unread');
      if (db.enable) {
        p = db.updateSession(obj);
      }
      p.then(function (record) {
        return self.onUpdateSession(record, flag);
      }).then(resolve, function (error) {
        reject({
          callFunc: 'session::updateLocalSession',
          event: error
        });
      });
    } else {
      // self.logger.warn('session::updateLocalSession: no session ', options.id)
      reject(NIMError.sessionNotExist({
        sessionId: options.id,
        callFunc: 'session::updateLocalSession'
      }));
    }
  });
};

/***/ }),

/***/ "./src/im/protocol/im/sessionAck.js":
/*!******************************************!*\
  !*** ./src/im/protocol/im/sessionAck.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;

// 同步到 session ack
IMProtocolFn.syncSessionAck = function (packet) {
  var self = this;
  var db = self.db;
  // 将 session ack 存储于内存和数据库
  var promise = Promise.resolve();[[packet.content.p2p, 'p2p'], [packet.content.team.m_map, 'team']].forEach(function (arr) {
    var map = arr[0];
    var scene = arr[1];
    Object.keys(map).forEach(function (to) {
      var id = scene + '-' + to;
      var session = {
        id: id,
        ack: map[to]
      };
      if (db.enable) {
        promise = promise.then(function () {
          return db.putSession(session);
        }).then(function () {
          self.markUnreadBySessionAck({ sessionId: id, ack: map[to] });
        });
      }
      self.mergeSession(session);
    });
  });
  self.logger.warn('session::syncSessionAck: parse offline session ack', self.sessionSet);
  // 存储同步时间戳
  var timetag = packet.content.timetag;
  if (db.enable) {
    promise = promise.then(function () {
      return self.db.updateSessionAck(timetag);
    }).catch(function (error) {
      self.logger.error('sessionAck::syncSessionAck: ', error);
      return Promise.reject(error);
    });
  }
  promise.cmd = 'sessionAck';
  self.syncPromiseArray.push(promise);
};

// mark session ack 的回包
IMProtocolFn.onMarkSessionAck = function (packet) {
  if (!packet.error) {
    this.storeSessionAck(packet.obj);
  }
};

// mark session ack 的多端同步包
IMProtocolFn.syncMarkSessionAck = function (packet) {
  this.storeSessionAck(packet.content);
};

// 在 onMarkSessionAck 和 syncMarkSessionAck 之后
// - 存储 session ack
// - 并更新会话未读数, 凡是比 ack 早的消息均为已读, 凡是比 ack 晚的消息均为未读
IMProtocolFn.storeSessionAck = function (obj) {
  var self = this;
  var syncSessionUnread = self.options.syncSessionUnread;
  // 如果没有开启同步, 那么直接返回
  if (!syncSessionUnread) {
    return;
  }
  var db = self.db;
  var scene = obj.scene === 0 ? 'p2p' : 'team';
  var sessionId = scene + '-' + obj.to;
  var ack = obj.timetag;
  // 如果 ack 比现有的小, 那么这个包无效, 直接返回
  var sessionInMemory = self.findSession(sessionId) || {};
  var ackInMemory = sessionInMemory.ack || 0;
  if (ack <= ackInMemory) {
    self.logger.warn('session::storeSessionAck: ack <= ackInMemory', ack);
    return;
  }
  // 存储 ack
  var session = {
    id: sessionId,
    ack: ack
  };
  self.mergeSession(session);
  if (db.enable) {
    db.updateSession(session);
  }
  self.logger.info('session::storeSessionAck:', session);
  // update session unread
  self.markUnreadBySessionAck({ sessionId: sessionId, ack: session.ack });
};

// update session unread
// param {sessionId, ack}
IMProtocolFn.markUnreadBySessionAck = function (_ref) {
  var sessionId = _ref.sessionId,
      ack = _ref.ack;

  var self = this;
  var db = self.db;
  if (db.enable) {
    self.pushMsgTask(function () {
      return db.getMsgCountAfterAck({
        shouldCountNotifyUnread: self.options.shouldCountNotifyUnread,
        sessionId: sessionId,
        ack: ack
      }).then(function (unread) {
        var s = {
          id: sessionId,
          unread: unread
          // if (self.currSessionId === sessionId) {
          //   // 如果是当前会话，会话未读数强制为0
          //   s.unread = 0
          // }
        };self.logger.log('session::markUnreadBySessionAck: db.getMsgCountAfterAck done');
        // 通知和更新数据库同时进行, 数据库操作会有一定延时
        if (self.syncing) {
          self.cacheSyncedSession(s);
        }
        self.onUpdateSession(s);
        return db.updateSession(s);
      });
    });
  } else {
    var s = self.findSession(sessionId);
    if (s) {
      var unreadMsgs = s.unreadMsgs;
      if (unreadMsgs && unreadMsgs.length) {
        var unread = 0;
        var arr = [];
        // 找到所有比 ack 晚的消息, 这些都算未读的
        for (var i = unreadMsgs.length - 1; i >= 0; i--) {
          var msg = unreadMsgs[i];
          if (msg.time > ack) {
            unread++;
            arr.push(msg);
          } else {
            break;
          }
        }
        s.unreadMsgs = arr;
        s.unread = unread;
        self.logger.info('session::markUnreadBySessionAck: unread ' + unread);
        self.onUpdateSession(s);
      }
    }
  }
};

/***/ }),

/***/ "./src/im/protocol/im/superTeam.js":
/*!*****************************************!*\
  !*** ./src/im/protocol/im/superTeam.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var objs2accounts = util.objs2accounts;
var teams2ids = util.teams2ids;
var SuperTeam = __webpack_require__(/*! im/model/superTeam */ "./src/im/model/superTeam.js");
var SuperTeamMember = __webpack_require__(/*! im/model/superTeamMember */ "./src/im/model/superTeamMember.js");

IMProtocolFn.processSuperTeam = function (packet) {
  var self = this;
  var error = packet.error;
  var team, member, owner;
  if ((0, _typeof3.default)(packet.obj) === undefined) {
    packet.obj = {};
  }
  switch (packet.cmd) {
    case 'sendSuperTeamMsg':
      self.onSendMsg(packet);
      break;
    case 'superTeamMsg':
      // 超大群通知消息
      self.onMsg(packet);
      break;
    case 'syncSuperTeams':
      self.onSuperTeams(packet);
      break;
    case 'syncSuperTeamMembers':
      self.onSuperTeamMembers(packet);
      break;
    case 'syncCreateSuperTeam':
      team = SuperTeam.reverse(packet.content.team);
      owner = SuperTeamMember.assembleOwner(team);
      self.logger.info('team::processTeam: sync createTeam', team, owner);
      self.options.onSyncCreateSuperTeam(team, owner);
      self.onCreateSuperTeam(team, owner);
      break;
    case 'getSuperTeamHistoryMsgs':
    case 'searchSuperTeamHistoryMsgs':
      self.onHistoryMsgs(packet);
      break;
    case 'addSuperTeamMembers':
    case 'removeSuperTeamMembers':
    case 'leaveSuperTeam':
      break;
    case 'updateInfoInSuperTeam':
      if (!error) {
        member = packet.obj;
        member.account = self.account;
        member.id = SuperTeamMember.genId(member.teamId, member.account);
        member = SuperTeamMember.reverse(member);
        packet.obj = member;
        self.onUpdateSuperTeamMember(member);
        // self.mergeMySuperTeamMembers()
      }
      break;
    // 其他端更新了自己的群信息
    case 'syncUpdateSuperTeamMember':
      member = SuperTeamMember.reverse(packet.content.teamMember);
      self.onUpdateSuperTeamMember(member);
      break;
    case 'updateSuperTeam':
      packet.obj = SuperTeam.reverse(packet.obj, true);
      break;
    case 'getSuperTeam':
      if (!packet.error) {
        packet.obj = SuperTeam.reverse(packet.content.team);
      }
      break;
    case 'getSuperTeams':
      self.onSuperTeams(packet);
      break;
    case 'getSuperTeamMembers':
      self.onSuperTeamMembers(packet);
      break;
    default:
      break;
  }
};
/**
 * 处理超大群，同步和get群信息时都会走这里
 * 处理了错误码
 * 
 * 同步时 更新了sync array, 和 本地team
 * 
 */
IMProtocolFn.onSuperTeams = function (packet) {
  packet.content = packet.content || {};
  var self = this;
  var db = self.db;
  // 有同步和主动获取两种情况
  var isSync = self.packetFromSync(packet);
  var rawTeams = packet.content.teams || [];
  var hasChange = true;
  var timetag;
  var teams = [];
  var invalidTeams = [];

  if (packet.error) {
    switch (packet.error.code) {
      // 没有更新
      case 803:
        packet.error = null;
        hasChange = false;
        break;
      default:
        break;
    }
  }

  // 用于同步的Promise
  var promise = new Promise(function (resolve, reject) {
    if (!packet.error) {
      // 处理数据
      parseData();
      // 如果支持数据库, 那么合并数据, 否则直接 bingo
      if (db.enable) {
        mergeData(resolve, reject);
      } else {
        bingo();
        resolve();
      }
    } else if (isSync) {
      // 同步时应该没有error, 所以这里应该走不到
      // packet error 带了相应信息
      reject(packet.error);
    }
  }).catch(function (error) {
    self.logger.error('superTeam::onSuperTeams: ', error);
    return Promise.reject(error);
  });

  if (isSync) {
    promise.cmd = 'superteams';
    self.syncPromiseArray.push(promise);
  }

  function parseData() {
    if (hasChange) {
      rawTeams.forEach(function (team) {
        team = SuperTeam.reverse(team);
        if (team.validToCurrentUser) {
          teams.push(team);
        } else {
          invalidTeams.push(team);
        }
      });
    }
    self.logger.info('superTeam::onSuperTeams: parseData', teams2ids(teams), teams, 'invalid', teams2ids(invalidTeams), invalidTeams);
    if (!rawTeams.length) {
      hasChange = false;
    } else {
      hasChange = true;
      timetag = packet.content.timetag;
    }
  }

  function mergeData(resolveSync, rejectSync) {
    // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
    packet.promise = new Promise(function (resolve, reject) {
      if (hasChange) {
        // 增量更新数据库
        db.mergeSuperTeams(teams, invalidTeams, timetag).then(function () {
          afterMergeData();
        }).then(undefined, function (event) {
          // self.logger.warn('superTeam::onSuperTeams:mergeData: db.mergeSuperTeams error', event)
          var error = {
            callFunc: 'superTeam::onSuperTeams:mergeData',
            message: 'db.mergeSuperTeams error',
            event: event
          };
          reject(error);
          rejectSync(error);
        });
      } else {
        self.logger.warn('superTeam::onSuperTeams:mergeData: no teams need merge');
        afterMergeData();
      }
      function afterMergeData() {
        if (!isSync) {
          db.getSuperTeams().then(function (records) {
            teams = records;
            bingo();
            resolve();
            resolveSync();
          }).then(undefined, function (event) {
            event.message = 'db.getSuperTeams error';
            event.callFunc = 'superTeam::afterMergeData';
            reject(event);
            rejectSync(event);
          });
        } else {
          bingo();
          resolve();
          resolveSync();
        }
      }
    }).then(undefined, function (event) {
      event.message = 'merge teams data error';
      event.callFunc = 'superTeam::mergeData';
      rejectSync(event);
      throw event;
    });
  }

  function bingo() {
    self.timetags.superTeams = timetag;
    teams.invalid = invalidTeams;
    // 返回数据
    if (isSync) {
      // 如果是同步, 那么统一在 onSyncDone 里面通知开发者
      self.syncResult.superTeams = teams;
      self.syncResult.invalidSuperTeams = invalidTeams;
    } else {
      self.logger.info('superTeam::onSuperTeams: not in syncing, get teams', teams2ids(teams), teams);
      packet.obj = teams;
    }
  }
};

IMProtocolFn.onCreateSuperTeam = function (team, owner) {
  var db = this.db;
  if (db.enable) {
    db.putSuperTeam(team);
    db.putSuperTeamMembers(owner);
  }
};
IMProtocolFn.onSuperTeamMembers = function (packet) {
  packet.content = packet.content || {};
  var self = this;
  var db = self.db;
  var rawMembers = packet.content.members || [];
  var hasChange = true;
  var timetag;
  var teamId;
  var members = [];
  var invalidMembers = [];
  var isAll = packet.content && packet.content.isAll;
  var needPaging, size, current;
  // 获取 teamId
  if (packet.obj) {
    teamId = packet.obj.teamId;
    needPaging = packet.obj.needPaging;
    if (needPaging) {
      size = packet.obj.pagingParams.size;
      current = packet.obj.pagingParams.current;
    }
  }

  if (!teamId) {
    teamId = packet.content.teamId;
  }
  teamId = '' + teamId;

  if (packet.error) {
    switch (packet.error.code) {
      // 没有获取到增量更新
      case 406:
        packet.error = null;
        hasChange = false;
        break;
    }
  }
  if (packet.error) return;

  parseData();
  if (db.enable) {
    packet.promise = new Promise(function (resolve, reject) {
      if (!hasChange) {
        console.log(resolve, reject);
        afterMergeData();
        return;
      }
      var pre = Promise.resolve();
      if (isAll) {
        pre = db.deleteSuperTeamMembers(teamId);
      }
      pre.then(function () {
        db.mergeSuperTeamMembers(teamId, members, invalidMembers, timetag).then(function () {
          afterMergeData();
        }).catch(function (e) {
          reject(e);
        });
      }).catch(function (e) {
        self.logger.error('onSuperTeamMembers::db.mergeSuperTeamMembers:: error', e);
      });
      function afterMergeData() {
        db.getSuperTeamMembers(teamId).then(function (res) {
          var result = {
            teamId: teamId
          };
          if (needPaging) {
            result.size = size;
            result.current = current;
            result.total = res.length;
            result.members = res.slice(size * current, (current + 1) * size);
          } else {
            result.members = res;
          }
          result.members.invalid = invalidMembers;
          packet.obj = result;
          resolve();
        }).catch(function (e) {
          reject(e);
        });
      }
    });
  } else if (isAll) {
    // 不支持db 直接bingo
    bingo();
  }

  function parseData() {
    if (hasChange) {
      rawMembers.forEach(function (member) {
        member = SuperTeamMember.reverse(member);
        if (member.valid) {
          members.push(member);
        } else {
          invalidMembers.push(member);
        }
      });
    }
    self.logger.warn('team::onSuperTeamMembers: parseData', teamId, objs2accounts(members), members, 'invalid', objs2accounts(invalidMembers), invalidMembers);
    if (!rawMembers.length) {
      hasChange = false;
    } else {
      hasChange = true;
      timetag = packet.content.timetag;
    }
  }

  function bingo() {
    self.logger.info('team::onSuperTeamMembers', teamId, objs2accounts(members), members);
    var result = {
      teamId: teamId
    };
    if (needPaging) {
      result.size = size;
      result.current = current;
      result.total = members.length;
      result.members = members.slice(size * current, (current + 1) * size);
    } else {
      result.members = members;
    }

    result.members.invalid = invalidMembers;
    // 返回数据
    packet.obj = result;
  }
};
IMProtocolFn.onUpdateSuperTeamMember = function (member) {
  var self = this;
  if (!member.updateTime) {
    member.updateTime = +new Date();
  }
  self.logger.warn('superTeam::onUpdateSuperTeamMember: ', member);
  self.options.onUpdateSuperTeamMember(util.simpleClone(member));
  var team = {
    teamId: member.teamId,
    memberUpdateTime: member.updateTime
  };
  self.onUpdateSuperTeam(team);
  var db = this.db;
  if (db.enable) {
    db.updateSuperTeamMember(member);
  }
};

IMProtocolFn.onUpdateSuperTeam = function (team) {
  var self = this;
  self.logger.info('superteam::onUpdateSuperTeam:', team);
  self.options.onUpdateSuperTeam(util.simpleClone(team));
  var db = self.db;
  if (db.enable) {
    db.updateSuperTeam(team);
  }
};

/***/ }),

/***/ "./src/im/protocol/im/sync.js":
/*!************************************!*\
  !*** ./src/im/protocol/im/sync.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var undef = util.undef;
var objs2ids = util.objs2ids;
var objs2accounts = util.objs2accounts;
var teams2ids = util.teams2ids;
var Session = __webpack_require__(/*! im/model/session */ "./src/im/model/session.js");
var root = util.getGlobal();

/*
 * 同步数据前得操作
 */
IMProtocolFn.beforeSync = function () {
  var _this = this;
  var db = _this.db;
  // 标记发送中的消息失败
  if (db.enable) {
    return db.clearSendingMsgs();
  }
  return Promise.resolve();
};

/*
 * 同步数据, 强制同步离线消息, 其它同步做成可选的
 * 所有的同步时间戳在同步完成之后才更新, 在单个更新的回包之后不更新, 这样就不会因为回包顺序问题导致时间戳记录有问题
 */
IMProtocolFn.syncData = function () {
  var _this = this;
  var db = _this.db;
  var options = _this.options;
  var supportDb = db.enable;
  _this.syncing = true;
  if (supportDb) {
    _this.beforeSync().then(function () {
      return _this.db.getTimetags();
    }).then(function (timetags) {
      bingo(timetags);
    }, function () {
      bingo();
    });
  } else {
    bingo(_this.timetags);
  }
  function bingo(timetags) {
    _this.syncPromiseArray = [];
    _this.syncResult = {};
    _this.syncTeamMembersPromiseArray = [];
    _this.syncSuperTeamMembersPromiseArray = [];
    _this.syncTeamMembersResult = {};
    _this.checkNosReqNum = 0;
    _this.getNosOriginUrlReqNum = 0;
    // 默认同步
    util.verifyBooleanWithDefault(options, 'syncRelations syncFriends syncFriendUsers syncTeams syncSuperTeams syncRoamingMsgs syncSuperTeamRoamingMsgs syncMsgReceipts syncExtraTeamInfo', true, '', 'sync::syncData');
    // 默认不同步
    // 过滤的消息（目前只有云商服用到过滤消息）
    util.verifyBooleanWithDefault(options, 'syncFilter syncTeamMembers syncSuperTeamMembers', false, '', 'sync::syncData');

    var sync = {};
    timetags = timetags || {};
    if (root._nimForceSyncIM) {
      _this.logger.warn('sync::syncData: nimForceSyncIM');
      delete timetags.teams;
      root._nimForceSyncIM = false;
    }
    // 强制同步 我的信息、离线消息
    sync.myInfo = timetags.myInfo || 0;
    sync.offlineMsgs = 0;
    // 可选同步
    if (options.syncRelations) {
      sync.relations = timetags.relations || 0;
    }
    if (options.syncFriends) {
      sync.friends = timetags.friends || 0;
    }
    if (options.syncFriendUsers) {
      sync.friendUsers = timetags.friendUsers || 0;
    }
    if (options.syncRobots) {
      sync.robots = timetags.robots || 0;
    }
    if (options.syncTeams) {
      sync.teams = timetags.teams || 0;
    }
    if (options.syncSuperTeams) {
      sync.superTeams = timetags.superTeams || 0;
    }
    if (options.syncRoamingMsgs) {
      sync.roamingMsgs = timetags.roamingMsgs || 0;
    }
    if (options.syncSuperTeamRoamingMsgs) {
      sync.superTeamRoamingMsgs = timetags.superTeamRoamingMsgs || 0;
    }
    if (options.syncMsgReceipts) {
      sync.msgReceipts = timetags.msgReceipts || 0;
    }
    // 不同步最近会话列表, 从漫游消息和离线消息构造最近会话列表
    // 所以如果没有漫游消息和离线消息, 那么就没有最近会话列表
    // if (false) { sync.sessions = 0; }
    // 有四种情况, 无数据库不同步群成员, 无数据库同步群成员, 有数据库不同步群成员, 有数据库同步群成员
    // 但是因为群和群成员是分开同步的, 所以还是用时间戳 0 来同步所有我的群成员
    if (options.syncExtraTeamInfo) {
      sync.myTeamMembers = timetags.myTeamMembers || 0;
    }
    // 同步会话 ack 位置
    if (options.syncSessionUnread) {
      sync.sessionAck = timetags.sessionAck || 0;
    }
    if (options.syncBroadcastMsgs) {
      sync.broadcastMsgs = timetags.broadcastMsg || 0;
    }
    sync.donnop = timetags.donnop || 0;
    sync.deleteMsg = timetags.deleteMsg || 0;
    // 目前只有云商服用到这个配置, 未在文档上列出
    if (options.syncFilter) {
      sync.filterMsgs = 0;
    }
    var callback = _this.onSyncData.bind(_this);
    // 记录这是 im sdk 同步命令回调
    callback.isImSyncDataCb = true;
    _this.sendCmd('sync', {
      sync: sync,
      isImSyncDataObj: true
    }, callback);
  }
};

IMProtocolFn.onSyncData = function (error, obj) {
  if (error && this.syncRetryTimes > 3) {
    this.syncRetryTimes = 0;
    error.callFunc = 'sync::onSyncData';
    this.onCustomError('SYNC_DATA_ERROR', error);
  }
};

IMProtocolFn.processSync = function (packet) {
  var self = this;
  self.syncRetryTimes = self.syncRetryTimes || 0;
  self.syncRetryTimes++;
  switch (packet.cmd) {
    // 同步
    case 'syncDone':
      if (packet.error) {
        if (self.syncRetryTimes > 3) {
          // throw new NIMError('同步消息错误-code: ' + packet.error)
          // self.onError(`同步消息错误-code: ${packet.error}`)
        } else {
          // 重新同步
          self.syncData();
        }
      } else {
        self.timetags.sync = packet.content.timetag;
        self.onSyncDone();
      }
      // setTimeout(self.onSyncDone.bind(self), 10000);
      break;
    // 同步群成员
    case 'syncTeamMembersDone':
      self.onSyncTeamMembersDone();
      break;
    default:
      break;
  }
};

IMProtocolFn.onSyncDone = function (syncError) {
  var self = this;
  var db = self.db;
  var supportDb = db.enable;
  var options = self.options;
  // self.syncPromiseArray 用于同步msg/roamingMsgs/friend等需要存db的操作
  var promiseArray = self.syncPromiseArray;
  // syncResult里的session可以从roamingMsgs里塞，也可以从数据库里取
  var result = self.syncResult;
  var promise;
  var blacklist;
  var invalidBlacklist;
  var mutelist;
  var invalidMutelist;
  var friends;
  var invalidFriends;
  var myInfo;
  var users;
  var teams;
  var superTeams;
  var invalidTeams;
  var invalidSuperTeams;
  var sessions;
  var msgReceipts;
  var roamingMsgs;
  var offlineMsgs;
  var offlineFilterMsgs;
  var roamingSysMsgs;
  var offlineSysMsgs;
  var offlineCustomSysMsgs;
  var offlineFilterSysMsgs;
  var offlineFilterCustomSysMsgs;
  var broadcastMsgs;
  var sysMsgUnread;

  afterSync();

  function afterSync() {
    if (!promiseArray) {
      // 允许单独同步部分字段，允许非初始化时同步
      self.logger.warn('sync::onSyncDone: after sync --no promiseArray');
      return;
    }
    self.logger.info('sync::onSyncDone: after sync', util.promises2cmds(promiseArray));
    promiseArray = [];

    blacklist = result.blacklist || [];
    invalidBlacklist = result.invalidBlacklist || [];
    mutelist = result.mutelist || [];
    invalidMutelist = result.invalidMutelist || [];
    friends = result.friends;
    invalidFriends = result.invalidFriends || [];
    myInfo = result.myInfo;
    users = result.users;
    superTeams = result.superTeams;
    invalidSuperTeams = result.invalidSuperTeams;
    teams = result.teams;
    invalidTeams = result.invalidTeams || [];
    sessions = result.sessions;
    msgReceipts = result.msgReceipts;
    roamingMsgs = result.roamingMsgs;
    offlineMsgs = result.offlineMsgs;
    offlineFilterMsgs = result.offlineFilterMsgs;
    offlineSysMsgs = result.offlineSysMsgs;
    offlineCustomSysMsgs = result.offlineCustomSysMsgs;
    offlineFilterSysMsgs = result.offlineFilterSysMsgs;
    offlineFilterCustomSysMsgs = result.offlineFilterCustomSysMsgs;
    broadcastMsgs = result.broadcastMsgs;
    sysMsgUnread = result.sysMsgUnread;

    if (sessions) {
      var arr = [];
      Object.keys(sessions).forEach(function (key) {
        arr.push(sessions[key]);
      });
      sessions = arr.sort(function (s1, s2) {
        return s2.updateTime - s1.updateTime;
      });
    }

    var p = Promise.resolve();
    if (supportDb) {
      p = storeRoamingOfflineData().then(function (records) {
        var tempSessionMap = {};
        records.forEach(function (msg) {
          var sessionId = msg.sessionId;
          if (!tempSessionMap[sessionId]) {
            tempSessionMap[sessionId] = true;
            self.markUnreadByMsgsPromise(sessionId);
          }
        });
      });
    }

    p.then(function () {
      // 如果启用了数据库, 并且还没有同步过, 那么从数据库获取全量数据
      if (supportDb && !self.hasSynced) {
        self.hasSynced = true;
        // 从数据库拉数据，并把同步结果的promise push 到 promiseArray
        pullFullData();
      }
      // 从服务器同步到的数据的promise
      var syncPromiseArray = self.syncPromiseArray;
      // 在 pullFullData 中 push promiseArray
      var sessionAckPromise = syncPromiseArray.filter(function (item) {
        return item.cmd === 'sessionAck';
      });
      if (sessionAckPromise.length === 0) {
        sessionAckPromise.push(Promise.resolve());
      }
      var normalPromise = syncPromiseArray.filter(function (item) {
        return item.cmd !== 'sessionAck';
      });
      if (normalPromise.length === 0) {
        normalPromise.push(Promise.resolve());
      }
      // 先处理普通 session 等数据，再处理 session ack 数据
      // 由于 sdk 使用 indexDB 对同一个表进行了多个读写事务
      // 导致 30ms 内的 2次 先后查询/写同一个key的数据丢失其中一个 (后者覆盖前者)
      // TODO 以后可以优化数据库的写操作——同一时间同一个 objectStorage 只存在一个写事务，改动较多
      Promise.all(normalPromise).then(function () {
        return Promise.all(sessionAckPromise);
      }, function (e) {
        e.callFunc = 'sync::onSyncDone';
        e.message = 'afterSync syncNormalPromise 出错';
        self.onCustomError('SYNC_NORMAL_ERROR', e);
      }).then(taskAfterSync, function (e) {
        e.callFunc = 'sync::onSyncDone';
        e.message = 'afterSync syncSessionAckPromise 出错';
        self.onCustomError('SYNC_SESSION_ACK_ERROR', e);
      }).then(function () {
        return Promise.all(promiseArray);
      }, function (e) {
        e.callFunc = 'sync::onSyncDone';
        e.message = 'afterSync taskAfterSync 出错';
        self.onCustomError('SYNC_NORMAL_ERROR', e);
      }).then(notifyData, function (e) {
        e.callFunc = 'sync::onSyncDone';
        e.message = 'taskAfterSync syncDBDataPromise 出错';
        self.onCustomError('SYNC_SESSION_ACK_ERROR', e);
      }).catch(function (e) {
        self.syncData();
      });
    });
  }
  // 此处仅仅存储离线消息和漫游消息
  function storeRoamingOfflineData() {
    var arr = [];
    var p;
    // 存储漫游消息和离线消息
    var msgs = [];
    if (roamingMsgs) {
      roamingMsgs.forEach(function (i) {
        msgs = [].concat((0, _toConsumableArray3.default)(msgs), (0, _toConsumableArray3.default)(i.msgs));
      });
    }

    if (offlineMsgs) {
      offlineMsgs.forEach(function (i) {
        msgs = [].concat((0, _toConsumableArray3.default)(msgs), (0, _toConsumableArray3.default)(i.msgs));
      });
    }
    p = db.putMsg(msgs);
    arr.push(p);
    return Promise.all(arr).then(function () {
      return msgs;
    });
  }

  function pullFullData() {
    // 关系
    if (options.syncRelations) {
      promise = db.getRelations().then(function (result) {
        blacklist = result[0];
        mutelist = result[1];
        blacklist.invalid = invalidBlacklist;
        mutelist.invalid = invalidMutelist;
      }, function (event) {
        event._msg = 'on relations error';
        return event;
      }).catch(function (error) {
        self.logger.error('sync::syncRelation: ', error);
        return Promise.reject(error);
      });
      promiseArray.push(promise);
    }
    // 好友
    if (options.syncFriends) {
      promise = db.getFriends().then(function (records) {
        friends = records;
        friends.invalid = invalidFriends;
      }, function (event) {
        event._msg = 'on friends error';
        return event;
      }).catch(function (error) {
        self.logger.error('sync::syncFriends: ', error);
        return Promise.reject(error);
      });
      promiseArray.push(promise);
    }
    // 我的名片
    if (undef(myInfo)) {
      promise = db.getUser(self.account).then(function (record) {
        myInfo = record;
      }, function (event) {
        event._msg = 'on myInfo error';
        return event;
      }).catch(function (error) {
        self.logger.error('sync::syncMyInfo: ', error);
        return Promise.reject(error);
      });
      promiseArray.push(promise);
    }
    // 好友名片
    if (options.syncFriendUsers) {
      promise = db.getFriends().then(function (records) {
        return records.map(function (friend) {
          return friend.account;
        });
      }).then(function (accounts) {
        return db.getUsers(accounts);
      }).then(function (records) {
        users = records;
      }, function (event) {
        event._msg = 'on users error';
        return event;
      }).catch(function (error) {
        self.logger.error('sync::syncFriendUser: ', error);
        return Promise.reject(error);
      });
      promiseArray.push(promise);
    }
    // 群
    if (options.syncTeams) {
      promise = db.getTeams().then(function (records) {
        teams = records;
        teams.invalid = invalidTeams;
      }, function (event) {
        event._msg = 'on teams error';
        return event;
      }).catch(function (error) {
        self.logger.error('sync::syncTeams: ', error);
        return Promise.reject(error);
      });
      promiseArray.push(promise);
    }
    // 超大群
    if (options.syncSuperTeams) {
      promise = db.getSuperTeams().then(function (records) {
        superTeams = records;
        superTeams.invalid = invalidSuperTeams;
      }, function (event) {
        event._msg = 'on superteams error';
        return event;
      }).catch(function (error) {
        self.logger.error('sync::syncSuperTeams: ', error);
        return Promise.reject(error);
      });
      promiseArray.push(promise);
    }
    // 我的群成员
    promise = db.getTeamMembersByAccount(self.account).then(function (members) {
      self.mergeMyTeamMembers(members);
    }).catch(function (error) {
      self.logger.error('sync::getTeamMembersByAccount: ', error);
      return Promise.reject(error);
    });
    promiseArray.push(promise);
    // donnop
    promise = db.getDonnop().then(function (donnop) {
      self.mergeDonnop(donnop);
    }).catch(function (error) {
      self.logger.error('sync::donnop: ', error);
      return Promise.reject(error);
    });
    promiseArray.push(promise);
    // 会话
    promise = db.getSessions().then(function (records) {
      sessions = records;
    }, function (event) {
      event._msg = 'on sessions error';
      return event;
    }).catch(function (error) {
      self.logger.error('sync::getSession: ', error);
      return Promise.reject(error);
    });
    promiseArray.push(promise);
    // 系统通知未读数
    promise = db.getSysMsgUnread().then(function (records) {
      sysMsgUnread = records;
    }, function (event) {
      event._msg = 'on sysMsgUnread error';
      return event;
    }).catch(function (error) {
      self.logger.error('sync::getSysMsgUnread: ', error);
      return Promise.reject(error);
    });
    promiseArray.push(promise);
  }

  // 同步完成之后的一些任务, 这些任务放在这里是为了保证时序上的问题
  // - 比如说漫游消息和离线消息要存储好之后才能删除, 如果删的操作过早是没有效果的
  // - 首先将被删除的消息从漫游和离线里剔除, 然后从数据库里删除这些消息, 同时修改回传给用户的会话
  function taskAfterSync() {
    self.logger.info('sync::onSyncDone: taskAfterSync');
    rejectDeletedMsgs();
    var array = [];
    array.push(self.deleteMsgOfflineRoaming(result.deleteMsgSysMsgs, sessions));
    return Promise.all(array);
  }

  // 将被删除的消息从漫游和离线里剔除
  function rejectDeletedMsgs() {
    if (result.deleteMsgSysMsgs) {
      var roamingMsgsMap = {};
      if (roamingMsgs) {
        roamingMsgs.forEach(function (obj) {
          roamingMsgsMap[obj.sessionId] = obj;
        });
      }
      var offlineMsgsMap = {};
      if (offlineMsgs) {
        offlineMsgs.forEach(function (obj) {
          offlineMsgsMap[obj.sessionId] = obj;
        });
      }
      // 剔除消息
      var api = self.api;
      result.deleteMsgSysMsgs.forEach(function (obj) {
        obj.sysMsgs.forEach(function (sysMsg) {
          var msg = sysMsg.msg;
          var sessionId = msg.sessionId;[roamingMsgsMap, offlineMsgsMap].forEach(function (roamingOfflineMsgsMap) {
            if (roamingOfflineMsgsMap[sessionId]) {
              roamingOfflineMsgsMap[sessionId].msgs = api.cutMsgs(roamingOfflineMsgsMap[sessionId].msgs, msg);
            }
          });
        });
      });
      // 修正会话, 只有在没有数据库的时候才修正, 有数据的时候在 deleteMsgOfflineRoaming 里面修正会话
      if (!db.enable) {
        ;[roamingMsgs, offlineMsgs].forEach(function (roamingOfflineMsgs) {
          if (roamingOfflineMsgs) {
            roamingOfflineMsgs.forEach(function (obj) {
              if (obj.msgs.length) {
                var session = self.genSessionByMsgs(obj.msgs);
                self.cacheSyncedSession(session);
                sessions = api.mergeSessions(sessions, session);
              } else {
                sessions = api.cutSessions(sessions, {
                  id: obj.sessionId
                });
              }
            });
          }
        });
      }
    }
  }

  function notifyData() {
    // 用 setTimeout 模拟异步线程
    setTimeout(notifyDataAsync, 0);
  }

  // 从服务器同步数据和从数据库同步数据的promise 都 resolve 后调用，触发各个同步的options 回调
  function notifyDataAsync() {
    // 是否要等待同步漫游消息时间戳
    var timetags = [];
    var timetag;
    var msgs;

    if (blacklist) {
      self.logger.info('sync::notifyDataAsync: on blacklist', objs2accounts(blacklist), blacklist);
      options.onblacklist(blacklist);
    }

    if (mutelist) {
      self.logger.info('sync::notifyDataAsync: on mutelist', objs2accounts(mutelist), mutelist);
      options.onmutelist(mutelist);
    }

    if (friends) {
      self.logger.info('sync::notifyDataAsync: on friends', objs2accounts(friends), friends);
      options.onfriends(friends);
    }

    if (myInfo) {
      self.logger.info('sync::notifyDataAsync: on myInfo', myInfo);
      // 记录我的信息
      self.myInfo = myInfo;
      options.onmyinfo(util.copy(myInfo));
    }

    if (users) {
      users.forEach(function (user) {
        self.mergeUser(user);
      });
      self.logger.info('sync::notifyDataAsync: on users', objs2accounts(users), users);
      options.onusers(users);
    }

    if (teams) {
      self.logger.info('sync::notifyDataAsync: on teams', teams2ids(teams), teams);
      options.onteams(teams);
    }
    if (superTeams) {
      self.logger.info('sync::notifyDataAsync: onSuperTeams', teams2ids(superTeams), superTeams);
      options.onSuperTeams(superTeams);
    }

    // 第一次同步之后的后续同步, 因为是增量的
    // 如果先同步到 sessions, 后同步到 msgReceipts
    // 那就需要将 msgReceipts merge 到 sessions 里
    // 需要为了安全起见 merge 一下
    if (msgReceipts) {
      if (!self.hasSynced && sessions && sessions.length || self.hasSynced) {
        sessions = self.mergeSessionAndMsgReceipts(sessions, msgReceipts);
      }
    }

    if (!!sessions && sessions.length) {
      // 在这里存储所有初始化得到的会话, 能保证全
      // 因为如果没有同步到会话, 会从数据库里取出会话
      sessions.forEach(function (session) {
        if (self.syncResult.sessions && self.syncResult.sessions[session.id] && typeof self.syncResult.sessions[session.id].unread === 'number') {
          session.unread = self.syncResult.sessions[session.id].unread;
        }
        self.mergeSession(session);
        Session.trim(session);
      });
      self.logger.info('sync::notifyDataAsync: on sessions', objs2ids(sessions), sessions);
      options.onsessions(sessions);
    }

    if (roamingMsgs) {
      roamingMsgs.forEach(function (i) {
        timetags.push(i.timetag);
        msgs = i.msgs;
        // 判断一下长度, 有可能都被删了
        if (msgs.length) {
          self.logger.info('sync::notifyDataAsync: on roaming msgs', i.sessionId, msgs.length, msgs);
          options.onroamingmsgs(i);
          if (msgs[0].scene === 'superTeam') {
            db.updateSuperTeamRoamingMsgTimetag(i.timetag);
          }
        }
      });
    }

    if (offlineMsgs) {
      offlineMsgs.forEach(function (i) {
        timetags.push(i.timetag);
        msgs = i.msgs;
        // 判断一下长度, 有可能都被删了
        if (msgs.length) {
          self.logger.info('sync::notifyDataAsync: on offline msgs', i.sessionId, msgs.length, msgs);
          options.onofflinemsgs(i);
        }
      });
    }

    if (offlineFilterMsgs) {
      offlineFilterMsgs.forEach(function (i) {
        timetags.push(i.timetag);
        msgs = i.msgs;
        if (msgs.length) {
          self.logger.info('sync::notifyDataAsync: on offline filter msgs', i.sessionId, msgs.length, msgs);
          options.onofflinefiltermsgs(msgs);
        }
      });
    }

    // 撤回消息的系统通知
    var deleteMsgSysMsgsRoaming = [];
    var deleteMsgSysMsgsOffline = [];
    if (result.deleteMsgSysMsgs) {
      result.deleteMsgSysMsgs.forEach(function (obj) {
        if (obj.type === 'roaming') {
          deleteMsgSysMsgsRoaming = deleteMsgSysMsgsRoaming.concat(obj.sysMsgs);
        } else {
          deleteMsgSysMsgsOffline = deleteMsgSysMsgsOffline.concat(obj.sysMsgs);
        }
      });
    }
    if (deleteMsgSysMsgsRoaming.length) {
      roamingSysMsgs = roamingSysMsgs || [];
      roamingSysMsgs = roamingSysMsgs.concat(deleteMsgSysMsgsRoaming);
    }
    if (deleteMsgSysMsgsOffline.length) {
      offlineSysMsgs = offlineSysMsgs || [];
      offlineSysMsgs = offlineSysMsgs.concat(deleteMsgSysMsgsOffline);
    }

    if (roamingSysMsgs) {
      self.logger.info('sync::notifyDataAsync: on roaming sys msgs', roamingSysMsgs.length, roamingSysMsgs);
      options.onroamingsysmsgs(roamingSysMsgs);
    }

    if (offlineSysMsgs) {
      self.logger.info('sync::notifyDataAsync: on offline sys msgs', offlineSysMsgs.length, offlineSysMsgs);
      options.onofflinesysmsgs(offlineSysMsgs);
    }

    // 目前并没有这种类型的消息
    if (offlineFilterSysMsgs) {
      self.logger.info('sync::notifyDataAsync: on offline filter sys msgs', offlineFilterSysMsgs.length, offlineFilterSysMsgs);
      options.onofflinefiltersysmsgs(offlineFilterSysMsgs);
    }

    if (offlineCustomSysMsgs) {
      self.logger.info('sync::notifyDataAsync: on offline custom sys msgs', offlineCustomSysMsgs.length, offlineCustomSysMsgs);
      options.onofflinecustomsysmsgs(offlineCustomSysMsgs);
    }

    if (offlineFilterCustomSysMsgs) {
      self.logger.info('sync::notifyDataAsync: on offline filter custom sys msgs', offlineFilterCustomSysMsgs.length, offlineFilterCustomSysMsgs);
      options.onofflinefiltercustomsysmsgs(offlineFilterCustomSysMsgs);
    }

    if (sysMsgUnread) {
      sysMsgUnread = util.merge({}, self.sysMsgUnread, sysMsgUnread);
      self.sysMsgUnread = util.merge({}, sysMsgUnread);
      self.logger.info('sync::notifyDataAsync: on sysMsgUnread', sysMsgUnread);
      options.onsysmsgunread(sysMsgUnread);
    }

    var pushNotificationMultiportConfig = self.getPushNotificationMultiportConfig();
    self.logger.info('sync::notifyDataAsync: on pushNotificationMultiportConfig', pushNotificationMultiportConfig);
    options.onPushNotificationMultiportConfig(pushNotificationMultiportConfig);

    // timetags 时间戳数组长度为0 表示没有漫游消息和离线消息
    // 如果没有漫游消息和离线消息, 不需要更新漫游消息时间戳
    // 如果有, 需要更新漫游消息时间戳, 取所有漫游消息和离线消息里面最大的时间戳
    if (timetags.length) {
      timetag = Math.max.apply(Math, timetags);
      self.updateRoamingMsgTimetag(timetag).then(bingo, bingo);
    } else {
      bingo();
    }

    // 清空同步缓存数据
    self.syncPromiseArray = [];
    self.syncResult = {};
  }

  function bingo() {
    // 处理同步过程中的收发消息和系统通知, 处理完之后设置 syncing 为 false, 表示同步完成
    self.processUnsettledMsgs();
    self.processUnsettledSysMsgs();

    if (self.syncing) {
      // 如果之前通知过就不通知了，避免后到的数据又一次触发同步完成通知
      options.onsyncdone();
    }
    // 设置 flag
    self.syncing = false;

    // 如果要同步群成员, 并且有群（全量或者增量）, 则同步群成员
    // 如果不要同步群成员, 或者没有群（本来就没有群或者没有增量更新）, 当做群成员已经同步完成
    if (options.syncTeamMembers && !!teams && !!teams.length) {
      throw new NIMError('sync team members api deprecated!');

      // self.syncTeamMembers(teams)
    } else {
        // setTimeout(function () {
        //   self.onSyncTeamMembersDone()
        // }, 0)
      }
  }
};

IMProtocolFn.syncTeamMembers = function (teams) {
  var self = this;
  // var db = self.db
  // if (db.enable) {
  //   db.getTeamMemberTimetags().then(function (timetags) {
  //     bingo(timetags)
  //   }, function () {
  //     bingo()
  //   })
  // } else {
  //   bingo(self.timetags)
  // }
  bingo(self.timetags);
  function bingo(timetags) {
    var sync = {};
    timetags = timetags || {};
    teams.forEach(function (team) {
      sync[team.teamId] = 0; // timetags['team-' + team.teamId] || 0
    }, self);
    self.sendCmd('syncTeamMembers', {
      sync: sync
    }, self.onSyncTeamMembers.bind(self));
  }
};

IMProtocolFn.onSyncTeamMembers = function (error, obj) {
  error.callFunc = 'sync::onSyncTeamMembers';
  error.message = '同步群成员错误';
  this.onCustomError('SYNC_TEAM_MEMBERS_ERROR', error);
};

/*
 * - 同步时如果启用了数据库, 统一在同步完成后通知开发者
 * - 同步时如果没启用数据库, 会在同步过程中通知开发者
 * - 请参考 IMProtocol#onTeamMembers~getAll
 */
IMProtocolFn.onSyncTeamMembersDone = function () {
  var self = this,
      db = self.db,
      options = self.options,
      result = self.syncTeamMembersResult,
      promiseArray = self.syncTeamMembersPromiseArray,
      promise;

  if (promiseArray.length) {
    Promise.all(promiseArray).then(afterSync, function (e) {
      e.callFunc = 'sync::onSyncTeamMembersDone';
      e.message = '同步群成员 syncTeamMembersPromiseArray 错误';
      self.onCustomError('SYNC_TEAM_MEMBERS_ERROR', e);
    }).catch(function (err) {
      // ... 待修改
      self.logger.log('sync::onSyncTeamMembersDone: syncTeamMembersPromiseArray promise ', err);
      afterSync();
    });
  } else {
    afterSync();
  }

  // 所有同步的 Promise 均已完成
  function afterSync() {
    self.logger.log('sync::onSyncTeamMembersDone: afterSync', util.promises2cmds(promiseArray));
    promiseArray = [];
    // 如果启用了数据库, 并且还没有同步过, 那么从数据库获取全量数据
    if (db.enable && !self.hasSyncedTeamMembers) {
      self.hasSyncedTeamMembers = true;
      pullFullData();
    } else {
      notifyData();
    }
  }

  function pullFullData() {
    // 如果不同步群或者不同步群成员, 则直接通知同步完成
    if (!options.syncTeams || !options.syncTeamMembers) {
      return bingo();
    }
    db.getTeams().then(function (teams) {
      teams.forEach(function (team) {
        var teamId = team.teamId;
        promise = new Promise(function (resolve, reject) {
          self.api.getTeamMembers({
            teamId: teamId,
            done: function done(err, obj) {
              if (err) {
                reject({
                  callFunc: 'sync::getTeamMembers: teamId-' + teamId,
                  message: 'sync team members error'
                });
              }
              result[teamId] = obj.members || [];
              resolve();
            }
          });
        });
        promiseArray.push(promise);
      });
      if (promiseArray.length) {
        Promise.all(promiseArray).then(notifyData, function (e) {
          e.callFunc = 'sync::onSyncTeamMembersDone';
          e.message = 'pullFullData promiseArray notifyData 错误';
          self.onCustomError('SYNC_TEAM_MEMBERS_ERROR', e);
        });
      } else {
        notifyData();
      }
    }, function (event) {
      event.callFunc = 'sync::onSyncTeamMembersDone';
      event.message = 'pullFullData getTeams 错误';
      self.onCustomError('SYNC_TEAM_MEMBERS_ERROR', event);
    });
  }

  function notifyData() {
    // 用 setTimeout 模拟异步线程
    setTimeout(notifyDataAsync, 0);
  }

  function notifyDataAsync() {
    var members, invalid;
    Object.keys(result).forEach(function (teamId) {
      if (teamId.indexOf('invalid') === -1) {
        members = result[teamId];
        invalid = result[teamId + '-invalid'] || [];
        members.invalid = invalid;
        onTeamMembers(teamId, members);
      }
    });
    bingo();
  }

  function onTeamMembers(teamId, members) {
    self.logger.info('sync::onSyncTeamMembersDone: onTeamMembers', teamId, objs2accounts(members), members);
    options.onteammembers({
      teamId: teamId,
      members: members
    });
  }

  function bingo() {
    self.logger.info('sync::onSyncTeamMembersDone: bingo');
    options.onsyncteammembersdone();
    // 清空同步缓存数据
    self.syncTeamMembersResult = null;
    self.syncTeamMembersPromiseArray = null;
  }
};

/***/ }),

/***/ "./src/im/protocol/im/sysMsg.js":
/*!**************************************!*\
  !*** ./src/im/protocol/im/sysMsg.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var SystemMessage = __webpack_require__(/*! im/model/systemMessage */ "./src/im/model/systemMessage.js");

IMProtocolFn.splitSysMsgs = function (sysMsgs, customSysMsgs) {
  var sysMsg;
  for (var i = sysMsgs.length - 1; i >= 0; i--) {
    sysMsg = sysMsgs[i];
    if (SystemMessage.isCustom(sysMsg)) {
      sysMsgs.splice(i, 1);
      customSysMsgs.push(sysMsg);
    }
  }
};

// 收到离线系统通知
// 不用调用 handleSysMsg, 因为同步的时候已经同步到这些变更了
IMProtocolFn.onOfflineSysMsgs = function (packet, isFilter) {
  var self = this;
  var sysMsgs = packet.content.sysMsgs.map(function (sysMsg) {
    sysMsg = SystemMessage.reverse(sysMsg);
    if (isFilter) {
      sysMsg.filter = true;
    }
    return sysMsg;
  });
  // 服务器返回的数据是按照时间从晚到早排序的, 但是一般UI上都是按照时间从早到晚排序的
  sysMsgs = sysMsgs.reverse();
  // 标记系统通知已读
  self.markSysMsgRead(sysMsgs);
  // 剥离出自定义系统通知
  var customSysMsgs = [];
  self.splitSysMsgs(sysMsgs, customSysMsgs);
  var p1 = isFilter ? 'offlineFilterSysMsgs' : 'offlineSysMsgs';
  var p2 = isFilter ? 'offlineFilterCustomSysMsgs' : 'offlineCustomSysMsgs';
  // 存储离线系统通知
  if (sysMsgs.length) {
    var promise = self.putSysMsg(sysMsgs, 'offlineSysMsgs').then(function (records) {
      // debugger
      // 这里返回的是过滤后的系统通知, 有可能为空数组
      sysMsgs = records;
      // 记录同步结果
      if (sysMsgs.length) {
        self.logger.info('sysmsg::onOfflineSysMsgs: ', p1, sysMsgs.length, sysMsgs);
        self.syncResult[p1] = self.syncResult[p1] || [];
        self.syncResult[p1] = self.syncResult[p1].concat(sysMsgs);
      }
    }).catch(function (error) {
      self.logger.error('sysMsg::onOfflineSysMsgs: ', error);
      return Promise.reject(error);
    });
    promise.cmd = 'sysMsgs';
    self.syncPromiseArray.push(promise);
  }
  // 记录同步结果
  if (customSysMsgs.length) {
    self.logger.info('sysmsg::onOfflineSysMsgs: ', p2, customSysMsgs);
    self.syncResult[p2] = self.syncResult[p2] || [];
    self.syncResult[p2] = self.syncResult[p2].concat(customSysMsgs);
  }
};

IMProtocolFn.onSendSysMsg = function (packet, isFilter) {
  var self = this;
  var sysMsg = packet.obj;
  self.completeSysMsg(sysMsg);
  if (!packet.error) {
    sysMsg.status = 'success';
  } else {
    sysMsg.status = 'fail';
  }
  sysMsg = SystemMessage.reverse(sysMsg);
  if (isFilter) {
    packet.obj.filter = true;
  }
  packet.obj = sysMsg;
};

IMProtocolFn.completeSysMsg = function (sysMsg) {
  sysMsg.from = this.account;
  return sysMsg;
};

// 收到系统通知
IMProtocolFn.onSysMsg = function (packet, isFilter) {
  var self = this;
  var sysMsg = SystemMessage.reverse(packet.content.sysMsg);
  // 标记已读
  self.markSysMsgRead(sysMsg);
  // 是否是过滤
  if (isFilter) {
    sysMsg.filter = true;
  }
  // 处理系统通知
  if (SystemMessage.isCustom(sysMsg)) {
    self.logger.info('sysmsg::onSysMsg: on customSysMsg', sysMsg);
    self.options.oncustomsysmsg(sysMsg);
  } else {
    // 如果正在同步中, 那么先不处理系统通知, 等到同步完成之后再处理系统通知
    if (self.syncing) {
      self.unhandledSysMsgs.push(sysMsg);
    } else {
      self.handleSysMsg(sysMsg);
    }
  }
};

IMProtocolFn.handleSysMsg = function (sysMsg) {
  var self = this;
  var type = sysMsg.type;
  var from = sysMsg.from;
  self.sysMsgPromise = self.sysMsgPromise.then(function () {
    // 存储系统通知
    return self.putSysMsg(sysMsg, 'onSysMsg');
  }).then(function (records) {
    // 这里返回的是过滤后的系统通知, 有可能为空数组
    sysMsg = records[0];
  }).then(function () {
    // debugger
    if (!sysMsg) {
      return;
    }
    // 分类型处理
    var obj;
    var promise = Promise.resolve();
    switch (type) {
      case 'addFriend':
        obj = {
          type: 'addFriend',
          account: from
        };
        promise = self.onFriendRequest(obj);
        break;
      case 'passFriendApply':
        obj = {
          type: 'passFriendApply',
          account: from
        };
        promise = self.onFriendRequest(obj);
        break;
      case 'deleteFriend':
        promise = self.onDeleteFriend({
          account: from
        });
        break;
    }
    if (obj && obj.friend) {
      sysMsg.friend = obj.friend;
    }
    return promise;
  }).then(function () {
    // debugger
    if (!sysMsg) {
      return;
    }
    // 通知系统通知
    self.logger.info('sysmsg::handleSysMsg: ', type, sysMsg);
    setTimeout(function () {
      self.options.onsysmsg(sysMsg);
    }, 0);
  });
};

/*
 * 存储系统通知（不存自定义系统通知）
 * - 收到离线系统通知
 * - 收到系统通知
 * 多 tab 页
 * - 当支持多个 tab 同时登录时, 收到消息时, 只会在一个 tab 页里面存储这些消息, 其它 tab 页会存储失败
 * - 存储成功的 tab 负责存储会话和更新未读数, 其它 tab 页也要计算自己的未读数(但是不能更新到数据库), 同时也要将消息推给开发者
 * type
 * - offlineSysMsgs
 * - onSysMsg
 */
IMProtocolFn.putSysMsg = function (sysMsgs, type) {
  // debugger
  if (!util.isArray(sysMsgs)) {
    sysMsgs = [sysMsgs];
  }
  // 如果是过滤（云商服专用）, 直接返回
  if (sysMsgs[0].filter) {
    return Promise.resolve(sysMsgs);
  }
  var self = this;
  var db = self.db;
  var supportDb = db.enable;
  var promise = Promise.resolve();
  // 未计入未读数的消息
  var uncoundSysMsgs = [];
  // 存储并过滤
  promise = promise.then(function () {
    // debugger
    if (supportDb) {
      return db.putSysMsg(sysMsgs);
    } else {
      return sysMsgs;
    }
  }).then(function (records) {
    // debugger
    // 过滤出最终回传给用户的消息
    var arr = [];
    sysMsgs.forEach(function (sysMsg) {
      if (self.checkSysMsgUnique(sysMsg)) {
        arr.push(sysMsg);
      }
    });
    sysMsgs = arr;
    if (supportDb) {
      // records 为存储到数据库的消息数组, 需要根据此数组来更新未读数
      uncoundSysMsgs = records;
    } else {
      uncoundSysMsgs = sysMsgs;
    }
  });
  promise = promise.then(function () {
    // debugger
    // 获取未读数
    return self.getSysMsgUnread().then(function (sysMsgUnread) {
      // debugger
      // 如果未计入未读数的消息不为空数组, 说明此 tab 页负责存储消息
      // 如果未计入未读数的消息为空数组, 则说明其它 tab 页已经存储过消息了, 但是依然需要重新计算未读数, 只是不能存储这个未读数
      if (!uncoundSysMsgs.length) {
        uncoundSysMsgs = sysMsgs;
        uncoundSysMsgs.backward = true;
      }
      // 更新未读数
      return self.updateSysMsgUnread(uncoundSysMsgs, sysMsgUnread, 1).then(function (sysMsgUnread) {
        // debugger
        // 缓存未读数
        if (type === 'offlineSysMsgs') {
          self.syncResult.sysMsgUnread = sysMsgUnread;
        }
        // 通知开发者, 未读数更新了
        if (type === 'onSysMsg') {
          self.onUpdateSysMsgUnread(sysMsgUnread);
        }
      });
    });
  });
  return promise.then(function () {
    // 把过滤后的系统通知返回出去
    return sysMsgs;
  });
};

IMProtocolFn.checkSysMsgUnique = util.genCheckUniqueFunc('idServer');

// 如果支持数据库, 那么从数据库拿未读记录
// 如果不支持数据库, 那么从数据源获取未读记录
IMProtocolFn.getSysMsgUnread = function () {
  var self = this;
  var db = self.db;
  return new Promise(function (resolve) {
    if (db.enable) {
      db.getSysMsgUnread().then(function (records) {
        resolve(records);
      }, function () {
        resolve(self.sysMsgUnread);
      });
    } else {
      resolve(self.sysMsgUnread);
    }
  });
};

/*
 * 更新系统通知未读数, 如果支持数据库, 更新数据库
 * - 收到系统通知 delta 为 1
 * - 主动标记系统通知 delta 为 -1
 */
IMProtocolFn.updateSysMsgUnread = function (sysMsgs, sysMsgUnread, delta) {
  // debugger
  if (!util.isArray(sysMsgs)) {
    sysMsgs = [sysMsgs];
  }
  if (!sysMsgs.length) {
    return Promise.resolve(sysMsgUnread);
  }
  sysMsgUnread = sysMsgUnread || {};
  var self = this;
  var db = self.db;
  var type;
  sysMsgs.forEach(function (sysMsg) {
    if (delta > 0 && !sysMsg.read || delta < 0 && sysMsg.read) {
      type = sysMsg.type;
      sysMsgUnread[type] = (sysMsgUnread[type] || 0) + delta;
    }
  });
  sysMsgUnread = SystemMessage.completeUnread(sysMsgUnread);
  // 更新后存起来
  self.sysMsgUnread = sysMsgUnread;
  // 如果落后, 那么不能存储未读数
  if (db.enable && !sysMsgs.backward) {
    return db.updateSysMsgUnread(sysMsgUnread);
  } else {
    return Promise.resolve(sysMsgUnread);
  }
};

IMProtocolFn.reduceSysMsgUnread = function (sysMsgs) {
  var self = this;
  return self.getSysMsgUnread().then(function (sysMsgUnread) {
    return self.updateSysMsgUnread(sysMsgs, sysMsgUnread, -1);
  }).then(function (sysMsgUnread) {
    self.onUpdateSysMsgUnread(sysMsgUnread);
  });
};

IMProtocolFn.onUpdateSysMsgUnread = function (sysMsgUnread) {
  var self = this;
  setTimeout(function () {
    self.logger.info('sysmsg::onUpdateSysMsgUnread:', sysMsgUnread);
    self.options.onupdatesysmsgunread(sysMsgUnread);
  }, 0);
};

/*
 * 更新系统消息, 如果支持数据库, 那么将变更写入数据库
 * - 更新好友相关的系统消息的状态
 * - 更新群相关的系统消息的状态
 * 更新完后, 通知开发者
 */
IMProtocolFn.updateSysMsg = function (sysMsg) {
  var self = this;
  var db = self.db;
  var promise;
  if (db.enable) {
    promise = db.updateSysMsg(sysMsg);
  } else {
    promise = Promise.resolve(sysMsg);
  }
  promise.then(function (sysMsg) {
    self.onUpdateSysMsg(sysMsg);
  });
};

IMProtocolFn.onUpdateSysMsg = function (sysMsgs) {
  var self = this;
  setTimeout(function () {
    if (!util.isArray(sysMsgs)) {
      sysMsgs = [sysMsgs];
    }
    sysMsgs.forEach(function (sysMsg) {
      self.logger.info('sysmsg::onUpdateSysMsg:', sysMsg);
      self.options.onupdatesysmsg(sysMsg);
    });
  }, 0);
};

IMProtocolFn.processUnsettledSysMsgs = function () {
  var self = this;
  self.unhandledSysMsgs.forEach(function (sysMsg) {
    self.handleSysMsg(sysMsg);
  });
  self.resetUnsettledSysMsgs();
};

/***/ }),

/***/ "./src/im/protocol/im/team.js":
/*!************************************!*\
  !*** ./src/im/protocol/im/team.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var objs2accounts = util.objs2accounts;
var teams2ids = util.teams2ids;
var Team = __webpack_require__(/*! im/model/team */ "./src/im/model/team.js");
var TeamMember = __webpack_require__(/*! im/model/teamMember */ "./src/im/model/teamMember.js");

/**
 * 处理群协议
 */
IMProtocolFn.processTeam = function (packet) {
  var self = this;
  var error = packet.error;
  var team = void 0;
  var member = void 0;
  var owner = void 0;
  if (typeof packet.obj === 'undefined') {
    packet.obj = {};
  }
  switch (packet.cmd) {
    case 'createTeam':
      team = packet.obj.team;
      if (!error) {
        team = packet.content.team;
      }
      team = Team.reverse(team);
      packet.obj.team = team;
      owner = TeamMember.assembleOwner(team);
      packet.obj.owner = owner;
      if (!error) {
        var obj = {
          team: team,
          owner: owner
        };
        self.logger.info('team::processTeam: create team', obj);
        // self.options.onCreateTeam(obj)
        self.onCreateTeam(team, owner);
      }
      break;
    case 'syncCreateTeam':
      team = Team.reverse(packet.content.team);
      owner = TeamMember.assembleOwner(team);
      self.logger.info('team::processTeam: sync createTeam', team, owner);
      self.options.onsynccreateteam(team, owner);
      self.onCreateTeam(team, owner);
      break;
    case 'sendSuperTeamMsg':
      self.onSendMsg(packet);
      break;
    case 'sendTeamMsg':
      self.onSendMsg(packet);
      break;
    case 'teamMsg':
      self.onMsg(packet);
      break;
    case 'teamMsgs':
      self.onMsgs(packet);
      break;
    case 'addTeamMembers':
    case 'removeTeamMembers':
    case 'leaveTeam':
    case 'dismissTeam':
    case 'addTeamManagers':
    case 'removeTeamManagers':
    case 'transferTeam':
      break;
    case 'updateInfoInTeam':
      if (!error) {
        member = packet.obj;
        member.account = self.account;
        member.id = TeamMember.genId(member.teamId, member.account);
        member = TeamMember.reverse(member);
        packet.obj = member;
        self.mergeMyTeamMembers(member);
        self.onUpdateTeamMember(member);
      }
      break;
    case 'updateNickInTeam':
      packet.obj = TeamMember.reverse(packet.obj);
      break;
    case 'updateTeam':
      packet.obj = Team.reverse(packet.obj, true);
      break;
    case 'applyTeam':
      if (!packet.error) {
        packet.obj = Team.reverse(packet.content.team);
      }
      break;
    case 'passTeamApply':
      self.updateTeamSysMsgState(packet, 'passed');
      break;
    case 'rejectTeamApply':
      self.updateTeamSysMsgState(packet, 'rejected');
      break;
    case 'acceptTeamInvite':
      self.updateTeamSysMsgState(packet, 'passed');
      if (!packet.error) {
        packet.obj = Team.reverse(packet.content.team);
      }
      break;
    case 'rejectTeamInvite':
      self.updateTeamSysMsgState(packet, 'rejected');
      break;
    case 'getTeam':
      if (!packet.error) {
        packet.obj = Team.reverse(packet.content.team);
      }
      break;
    case 'getTeams':
      self.onTeams(packet);
      break;
    case 'getTeamMembers':
      self.onTeamMembers(packet);
      break;
    case 'syncTeams':
      self.onTeams(packet);
      break;
    case 'syncTeamMembers':
      self.onTeamMembers(packet);
      break;
    case 'getTeamHistoryMsgs':
    case 'searchTeamHistoryMsgs':
      self.onHistoryMsgs(packet);
      break;
    case 'syncSendTeamMsg':
      self.onMsg(packet);
      break;
    // 通知群消息已读
    case 'notifyTeamMsgReads':
      self.onTeamMsgReceipt(packet);
      break;
    // 在其他端更新了自己的群信息
    // 在其他端更新了别人的群信息
    // 更新别人的群昵称
    // 都会走这里
    case 'syncUpdateTeamMember':
      member = TeamMember.reverse(packet.content.teamMember);
      self.onUpdateTeamMember(member);
      // 如果是更新自己, 那么存储数据
      if (member.account === self.account) {
        self.mergeMyTeamMembers(member);
      }
      break;
    case 'updateMuteStateInTeam':
      break;
    case 'getMyTeamMembers':
      if (!packet.error) {
        packet.obj = TeamMember.reverseMembers(packet.content.teamMembers);
      }
      break;
    case 'getMutedTeamMembers':
      if (!packet.error) {
        packet.obj = {
          teamId: packet.obj.teamId,
          members: TeamMember.reverseMembers(packet.content.teamMembers)
        };
      }
      break;
    case 'syncMyTeamMembers':
      self.onSyncMyTeamMembers(packet);
      break;
    default:
      break;
  }
};

IMProtocolFn.onCreateTeam = function (team, owner) {
  var db = this.db;
  if (db.enable) {
    db.putTeam(team);
    db.putTeamMembers(owner);
  }
  this.options.onCreateTeam(team, owner);
};

/*
 * 处理群, 同步和主动获取都会走这个逻辑
 */
IMProtocolFn.onTeams = function (packet) {
  packet.content = packet.content || {};
  var self = this;
  var db = self.db;
  // 有同步和主动获取两种情况
  var isSync = self.packetFromSync(packet);
  var rawTeams = packet.content.teams || [];
  var hasChange = true;
  var timetag;
  var teams = [];
  var invalidTeams = [];

  if (packet.error) {
    switch (packet.error.code) {
      // 没有获取到增量更新
      case 803:
        packet.error = null;
        hasChange = false;
        break;
    }
  }

  // 用于同步的Promise
  var promise = new Promise(function (resolve, reject) {
    if (!packet.error) {
      // 处理数据
      parseData();
      // 如果支持数据库, 那么合并数据, 否则直接 bingo
      if (db.enable) {
        mergeData(resolve, reject);
      } else {
        bingo();
        resolve();
      }
    } else if (isSync) {
      // 同步时应该没有error, 所以这里应该走不到
      // packet error 带了相应信息
      reject(packet.error);
    }
  }).catch(function (error) {
    self.logger.error('team::onTeams: ', error);
    return Promise.reject(error);
  });

  if (isSync) {
    promise.cmd = 'teams';
    self.syncPromiseArray.push(promise);
  }

  function parseData() {
    if (hasChange) {
      rawTeams.forEach(function (team) {
        team = Team.reverse(team);
        if (team.validToCurrentUser) {
          teams.push(team);
        } else {
          invalidTeams.push(team);
        }
      });
    }
    self.logger.info('team::onTeams: parseData', teams2ids(teams), teams, 'invalid', teams2ids(invalidTeams), invalidTeams);
    if (!rawTeams.length) {
      hasChange = false;
    } else {
      hasChange = true;
      timetag = packet.content.timetag;
    }
  }

  function mergeData(resolveSync, rejectSync) {
    // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
    packet.promise = new Promise(function (resolve, reject) {
      if (hasChange) {
        // 增量更新数据库
        db.mergeTeams(teams, invalidTeams, timetag).then(function () {
          afterMergeData();
        }).then(undefined, function (event) {
          // self.logger.warn('team::onTeams:mergeData: db.mergeTeams error', event)
          var error = {
            callFunc: 'team::onTeams:mergeData',
            message: 'db.mergeTeams error',
            event: event
          };
          reject(error);
          rejectSync(error);
        });
      } else {
        self.logger.warn('team::onTeams:mergeData: no teams need merge');
        afterMergeData();
      }
      function afterMergeData() {
        if (!isSync) {
          db.getTeams().then(function (records) {
            teams = records;
            bingo();
            resolve();
            resolveSync();
          }).then(undefined, function (event) {
            event.message = 'db.getTeams error';
            event.callFunc = 'team::afterMergeData';
            reject(event);
            rejectSync(event);
          });
        } else {
          bingo();
          resolve();
          resolveSync();
        }
      }
    }).then(undefined, function (event) {
      event.message = 'merge teams data error';
      event.callFunc = 'team::mergeData';
      rejectSync(event);
      throw event;
    });
  }

  function bingo() {
    self.timetags.teams = timetag;
    teams.invalid = invalidTeams;
    // 返回数据
    if (isSync) {
      // 如果是同步, 那么统一在 onSyncDone 里面通知开发者
      self.syncResult.teams = teams;
      self.syncResult.invalidTeams = invalidTeams;
      if (!self.syncing) {
        // 如果数据比同步完成命令后收到也会通知
        self.onSyncDone();
      }
    } else {
      self.logger.info('team::onTeams: not in syncing, get teams', teams2ids(teams), teams);
      packet.obj = teams;
    }
  }
};

// TODO 同步的时候不存储群成员和时间戳, 等所有的群成员同步完成之后再存储, 这样可以减少数据库操作
IMProtocolFn.onTeamMembers = function (packet) {
  packet.content = packet.content || {};
  var self = this;
  var db = self.db;
  // 有同步和主动获取两种情况
  var isSync = self.packetFromSync(packet);
  var rawMembers = packet.content.members || [];
  var hasChange = true;
  var timetag;
  var teamId;
  var members = [];
  var invalidMembers = [];

  // 获取 teamId
  if (packet.obj) {
    teamId = packet.obj.teamId;
  }

  if (!teamId) {
    teamId = packet.content.teamId;
  }
  teamId = '' + teamId;

  if (packet.error) {
    switch (packet.error.code) {
      // 没有获取到增量更新
      case 406:
        packet.error = null;
        hasChange = false;
        break;
    }
  }

  // 用于同步的Promise
  var promise = new Promise(function (resolve, reject) {
    if (!packet.error) {
      // 处理数据
      parseData();
      // 如果支持数据库, 那么合并数据, 否则直接 bingo
      // if (db.enable) {
      //   mergeData(resolve, reject)
      // } else {
      //   bingo()
      //   resolve()
      // }
      bingo();
      resolve();
    } else if (isSync) {
      // 同步时应该没有error, 所以这里应该走不到
      self.logger.error('team::onTeamMember: team error:', teamId, packet.error);
      reject({
        callFunc: 'team::onTeamMembers',
        event: packet.error,
        message: 'teamId-' + teamId + ' \u83B7\u53D6\u7FA4\u6210\u5458\u9519\u8BEF'
      });
    }
  });
  if (isSync) {
    promise.cmd = teamId;
    self.syncTeamMembersPromiseArray.push(promise);
  }

  function parseData() {
    if (hasChange) {
      rawMembers.forEach(function (member) {
        member = TeamMember.reverse(member);
        if (member.valid) {
          members.push(member);
        } else {
          invalidMembers.push(member);
        }
      });
    }
    self.logger.warn('team::onTeamMembers: parseData', teamId, objs2accounts(members), members, 'invalid', objs2accounts(invalidMembers), invalidMembers);
    if (!rawMembers.length) {
      hasChange = false;
    } else {
      hasChange = true;
      timetag = packet.content.timetag;
    }
  }

  function bingo() {
    members.invalid = invalidMembers;
    // 返回数据
    if (isSync) {
      // 如果是同步, 那么统一在 onSyncTeamMembersDone 里面通知开发者
      self.syncTeamMembersResult[teamId] = members;
      self.syncTeamMembersResult[teamId + '-invalid'] = invalidMembers;
      self.timetags['team-' + teamId] = timetag;
    } else {
      self.logger.info('team::onTeamMembers: not syncing, get members', teamId, objs2accounts(members), members);
      packet.obj = {
        teamId: teamId,
        members: members
      };
    }
  }
};

IMProtocolFn.onUpdateTeamMember = function (member) {
  var self = this;
  if (!member.updateTime) {
    member.updateTime = +new Date();
  }
  self.logger.info('team::onUpdateTeamMember: ', member);
  self.options.onupdateteammember(util.simpleClone(member));
  var team = {
    teamId: member.teamId,
    memberUpdateTime: member.updateTime
  };
  self.onUpdateTeam(team);
  var db = this.db;
  if (db.enable) {
    db.updateTeamMember(member);
  }
};

IMProtocolFn.onUpdateTeam = function (team) {
  var self = this;
  self.logger.info('team::onUpdateTeam:', team);
  self.options.onUpdateTeam(util.simpleClone(team));
  var db = self.db;
  if (db.enable) {
    db.updateTeam(team);
  }
};

// 同步到所有群里面我的群成员信息
// 这里不用存储时间戳, 无意义
IMProtocolFn.onSyncMyTeamMembers = function (packet) {
  var self = this;
  var db = self.db;
  var teamMembers = TeamMember.reverseMembers(packet.content.teamMembers);
  self.logger.info('team::onSyncMyTeamMembers:', teamMembers);
  if (db.enable) {
    var promise = db.putTeamMembers(teamMembers).then(function () {
      return db.updateMyTeamMembersTimetag(packet.content.timetag);
    }).catch(function (error) {
      self.logger.error('team::syncMyTeamMember: ', error);
      return Promise.reject(error);
    });
    promise.cmd = 'myTeamMembers';
    self.syncTeamMembersPromiseArray.push(promise);
  }
  self.mergeMyTeamMembers(teamMembers);
};

// 存储我的群成员信息
IMProtocolFn.mergeMyTeamMembers = function (teamMembers) {
  if (!util.isArray(teamMembers)) {
    teamMembers = [teamMembers];
  }
  var self = this;
  var myTeamMembersMap = self.myTeamMembersMap = self.myTeamMembersMap || {};
  teamMembers.forEach(function (member) {
    var teamId = member.teamId;
    myTeamMembersMap[teamId] = util.merge(myTeamMembersMap[teamId], member);
  });
  self.logger.info('team::mergeMyTeamMembers:', myTeamMembersMap);
};

/**
 * 是否需要群消息通知
 * 如果没有我的群成员信息, 那么从服务器拉取
 */
IMProtocolFn.notifyForNewTeamMsg = function (teamIds) {
  if (!util.isArray(teamIds)) {
    teamIds = [teamIds];
  }
  var self = this;
  var myTeamMembersMap = this.myTeamMembersMap || {};
  // 如果现有数据没有, 需要从服务器拉取
  var map = {};
  var missing = [];
  teamIds.forEach(function (teamId) {
    if (util.exist(myTeamMembersMap[teamId])) {
      map[teamId] = myTeamMembersMap[teamId].muteNotiType;
      // map[teamId] = !myTeamMembersMap[teamId].muteTeam
    } else {
      missing.push(teamId);
    }
  });
  var promise = Promise.resolve(map);
  if (missing.length) {
    promise = self.api.getMyTeamMembers({
      teamIds: missing,
      promise: true
    }).then(function (teamMembers) {
      self.mergeMyTeamMembers(teamMembers);
      teamMembers.forEach(function (member) {
        map[member.teamId] = member.muteNotiType;
        // map[member.teamId] = !member.muteTeam
      });
      return map;
    });
  }
  return promise;
};

/*
 * 更新群系统通知的状态
 * - 通过入群申请
 * - 拒绝入群申请
 * - 通过入群邀请
 * - 拒绝入群邀请
 */
IMProtocolFn.updateTeamSysMsgState = function (packet, state) {
  var error = packet.error;
  var sysMsg;

  // 处理错误
  if (error) {
    state = 'error';
    error = util.filterObj(error, 'code message');
  }

  sysMsg = {
    idServer: packet.obj.idServer,
    state: state
  };
  if (error) {
    sysMsg.error = error;
  }
  this.updateSysMsg(sysMsg);
};

/* 群消息业务已读 通知消息 */
IMProtocolFn.onTeamMsgReceipt = function (packet) {
  var content = packet.content;
  var error = packet.error;
  // 处理错误
  if (error) {
    this.logger.error('team::onTeamMsgReceipt:', error);
  }
  if (content && content.teamMsgReceipts) {
    this.options.onTeamMsgReceipt(content);
  }
};

/***/ }),

/***/ "./src/im/protocol/im/user.js":
/*!************************************!*\
  !*** ./src/im/protocol/im/user.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// var Promise = require('es6-promise').Promise
var IMProtocolFn = __webpack_require__(/*! ./index */ "./src/im/protocol/im/index.js").fn;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var objs2accounts = util.objs2accounts;
var SpecialRelation = __webpack_require__(/*! im/model/specialRelation */ "./src/im/model/specialRelation.js");
var User = __webpack_require__(/*! im/model/user */ "./src/im/model/user.js");

IMProtocolFn.processUser = function (packet) {
  var self = this;
  var db = self.db;
  var obj = packet.obj;
  var error = packet.error;
  var content = packet.content;
  var users;

  switch (packet.cmd) {
    // 加入黑名单/从黑名单移除
    case 'markInBlacklist':
      if (!error) {
        self.markInBlacklist(obj);
      }
      break;
    case 'syncMarkInBlacklist':
      self.markInBlacklist(content, true);
      break;
    // 加入静音列表/从静音列表移除
    case 'markInMutelist':
      if (!error) {
        self.markInMutelist(obj);
      }
      break;
    case 'syncMarkInMutelist':
      self.markInMutelist(content, true);
      break;
    // 获取黑名单和静音列表
    case 'getRelations':
      if (!error) {
        self.onRelations(packet);
      }
      break;
    case 'syncMyInfo':
      self.onMyInfo(packet, true);
      break;
    case 'updateMyInfo':
      if (!error) {
        obj.updateTime = content.timetag;
        self.onUpdateMyInfo(packet, obj);
      }
      break;
    case 'syncUpdateMyInfo':
      self.onUpdateMyInfo(packet, content.user, true);
      break;
    case 'getUsers':
      if (!error) {
        users = content.users.map(function (user) {
          user = User.reverse(user);
          self.mergeUser(user);
          return user;
        });
        packet.obj = users;
        if (db.enable) {
          db.putUsers(users);
        }
      }
      break;
    case 'updateDonnop':
      self.onUpdateDonnop(packet);
      break;
    case 'syncUpdateDonnop':
      self.onDonnop(packet, false);
      break;
    default:
      break;
  }
};

/*
 * 处理我的信息
 */
IMProtocolFn.onMyInfo = function (packet) {
  var self = this;
  var db = self.db;
  var error = packet.error;
  var content = packet.content;
  var isSync = true;
  var user = void 0;

  // 用于同步的Promise
  var promise = new Promise(function (resolve, reject) {
    if (!error) {
      // 处理数据
      parseData();
      // 如果支持数据库, 那么合并数据, 否则直接 bingo
      if (db.enable) {
        mergeData(resolve, reject);
      } else {
        bingo();
        resolve();
      }
    } else if (isSync) {
      // 同步时应该没有error, 所以这里应该走不到
      // reject(error);
      if (error) {
        error.callFunc = 'user::onMyInfo';
      }
      resolve(error);
      self.syncData();
    }
  }).catch(function (error) {
    self.logger.error('user::onMyInfo: ', error);
    return Promise.reject(error);
  });
  if (isSync) {
    promise.cmd = 'myInfo';
    self.syncPromiseArray.push(promise);
  }

  function parseData() {
    user = User.reverse(content.user);
    self.logger.info('user::onMyInfo: parseData', user);
  }

  function mergeData(resolveSync, rejectSync) {
    // 不用设置用于主动获取的 Promise
    db.mergeMyInfo(user, isSync).then(function () {
      bingo();
      resolveSync();
    }).then(undefined, function (event) {
      event.message = 'db.mergeMyInfo error';
      event.callFunc = 'user::onMyInfo';
      rejectSync(event);
    });
  }

  function bingo() {
    self.timetags.myInfo = user.updateTime;
    if (isSync) {
      // 如果是同步, 那么统一在 onSyncDone 里面通知开发者
      self.syncResult.myInfo = user;
    }
  }
};

/**
 * 更新我的信息
 * @private
 * @param  {Object}  user     增量的用户信息
 * @param  {Boolean} isSynced 是否是多端同步
 */
IMProtocolFn.onUpdateMyInfo = function (packet, obj, isSynced) {
  var self = this;
  var db = self.db;
  var userUpdate = User.reverse(obj);
  var user = util.merge(self.myInfo, userUpdate);
  self.myInfo = user;
  // 如果是多端同步, 那么通知开发者
  if (isSynced) {
    self.logger.info('user::onUpdateMyInfo:', user);
    self.options.onupdatemyinfo(user);
  } else {
    packet.obj = user;
  }
  if (db.enable) {
    userUpdate.account = self.account;
    db.updateUser(userUpdate);
  }
};

/*
 * 处理黑名单和静音列表, 同步和主动获取都会走这个逻辑
 */
IMProtocolFn.onRelations = function (packet) {
  var self = this;
  var db = self.db;
  var error = packet.error;
  // 有同步和主动获取两种情况
  var isSync = self.packetFromSync(packet);
  var rawRelations = packet.content.specialRelations;
  var hasChange = true;
  var timetag = void 0;
  var blacklist = [];
  var invalidBlacklist = [];
  var mutelist = [];
  var invalidMutelist = [];

  // 用于同步的Promise
  var promise = new Promise(function (resolve, reject) {
    if (!error) {
      // 处理数据
      parseData();
      // 如果支持数据库, 那么合并数据, 否则直接 bingo
      if (db.enable) {
        mergeData(resolve, reject);
      } else {
        bingo();
        resolve();
      }
    } else if (isSync) {
      // 同步时应该没有error, 所以这里应该走不到
      // reject(error)
      resolve(error);
      self.syncData();
    }
  }).catch(function (error) {
    self.logger.error('user::onRelations: ', error);
    return Promise.reject(error);
  });
  if (isSync) {
    promise.cmd = 'relations';
    self.syncPromiseArray.push(promise);
  }

  function parseData() {
    rawRelations.forEach(function (sr) {
      sr = SpecialRelation.parse(sr);
      var item = {
        account: sr.account,
        createTime: sr.createTime,
        updateTime: sr.updateTime
      };
      if (sr.isBlacked) {
        blacklist.push(item);
      } else {
        invalidBlacklist.push(item);
      }
      if (sr.isMuted) {
        mutelist.push(item);
      } else {
        invalidMutelist.push(item);
      }
    });
    self.logger.info('user::onRelations: parse blacklist', objs2accounts(blacklist), blacklist, 'delete', objs2accounts(invalidBlacklist), invalidBlacklist);
    self.logger.info('user::onRelations: parse mutelist', objs2accounts(mutelist), mutelist, 'delete', objs2accounts(invalidMutelist), invalidMutelist);
    if (!rawRelations.length) {
      hasChange = false;
    } else {
      hasChange = true;
      timetag = packet.content.timetag;
    }
  }

  function mergeData(resolveSync, rejectSync) {
    // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
    packet.promise = new Promise(function (resolve, reject) {
      if (hasChange) {
        // 增量更新数据库
        db.mergeRelations(blacklist, invalidBlacklist, mutelist, invalidMutelist, timetag).then(function () {
          afterMergeData();
        }).then(undefined, function (event) {
          event.message = 'db.mergeRelations error';
          event.callFunc = 'user::onRelations';
          reject(event);
          rejectSync(event);
        });
      } else {
        self.logger.warn('user::onRelations: no relations need merge');
        afterMergeData();
      }
      function afterMergeData() {
        // 如果不是同步, 那么需要获取完整的列表
        if (!isSync) {
          db.getRelations().then(function (result) {
            blacklist = result[0];
            mutelist = result[1];
            bingo();
            resolve();
            resolveSync();
          }).then(undefined, function (event) {
            event.message = 'db.getRelations error';
            event.callFunc = 'user::onRelations';
            reject(event);
            rejectSync(event);
          });
        } else {
          bingo();
          resolve();
          resolveSync();
        }
      }
    }).then(undefined, function (event) {
      event.message = 'merge relations data error';
      event.callFunc = 'user::onRelations';
      rejectSync(event);
      throw event;
    });
  }

  function bingo() {
    self.timetags.relations = timetag;
    blacklist.invalid = invalidBlacklist;
    mutelist.invalid = invalidMutelist;
    // 返回数据
    if (isSync) {
      // 如果是同步, 那么统一在onSyncDone里面通知开发者
      self.syncResult.blacklist = blacklist;
      self.syncResult.mutelist = mutelist;
      self.syncResult.invalidBlacklist = invalidBlacklist;
      self.syncResult.invalidMutelist = invalidMutelist;
    } else {
      self.logger.info('user::onRelations: get relations', blacklist, mutelist);
      packet.obj.blacklist = blacklist;
      packet.obj.mutelist = mutelist;
    }
  }
};

/**
 * 标记黑名单
 * @private
 * @param  {Object}  obj      请求对象
 * @param  {Boolean} isSynced 是否是多端同步
 * @return {Void}
 */
IMProtocolFn.markInBlacklist = function (obj, isSynced) {
  var self = this;
  var db = self.db;
  obj.record = {
    account: obj.account,
    updateTime: +new Date()
  };
  if (db.enable) {
    db.markInBlacklist(obj);
  }
  if (isSynced) {
    self.logger.info('user::markInBlacklist:', obj);
    self.options.onsyncmarkinblacklist(obj);
  }
};

/**
 * 标记静音列表
 * @private
 * @param  {Object}  obj      请求对象
 * @param  {Boolean} isSynced 是否是多端同步
 * @return {Void}
 */
IMProtocolFn.markInMutelist = function (obj, isSynced) {
  var self = this;
  var db = self.db;
  obj.record = {
    account: obj.account,
    updateTime: +new Date()
  };
  if (db.enable) {
    db.markInMutelist(obj);
  }
  if (isSynced) {
    self.logger.info('user::markInMutelist:', obj);
    self.options.onsyncmarkinmutelist(obj);
  }
};

IMProtocolFn.mergeUser = function (user) {
  this.userSet[user.account] = user;
};

/***/ }),

/***/ "./src/im/protocol/map/configBase.js":
/*!*******************************************!*\
  !*** ./src/im/protocol/map/configBase.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var idMap = {
  // 连接相关
  link: {
    id: 1,
    // 心跳
    heartbeat: 2
  },
  // 同步 音视频 IM 共用
  sync: {
    id: 5,
    // 同步
    sync: 1,
    // 同步群成员
    syncTeamMembers: 2
  },
  // 其它
  misc: {
    id: 6,
    // 获取nos上传凭证
    getSimpleNosToken: 1,
    // 获取nos上传凭证
    getNosToken: 2,
    // 下发SDK日志上传通知
    notifyUploadLog: 3,
    // 上传日志的 url
    uploadSdkLogUrl: 4,
    // 语音转文字
    audioToText: 5,
    // 处理图片
    processImage: 6,
    // 获取文档转码专用NOS上传token协议
    getNosTokenTrans: 7,
    // 文档转码结束后的下发协议
    notifyTransLog: 8,
    // 查询文档
    fetchFile: 9,
    // 获取分页文档列表
    fetchFileList: 10,
    // 删除文档
    removeFile: 11,
    // 同步客户端反垃圾词库
    getClientAntispam: 17,
    fileQuickTransfer: 18,
    // 获取NOS原始文件地址
    getNosOriginUrl: 22
  },
  avSignal: {
    id: 15,
    signalingCreate: 1,
    signalingDelay: 2,
    signalingClose: 3,
    signalingJoin: 4,
    signalingLeave: 5,
    signalingInvite: 6,
    signalingCancel: 7,
    signalingReject: 8,
    signalingAccept: 9,
    signalingControl: 10,
    signalingNotify: 11,
    signalingMutilClientSyncNotify: 12,
    signalingUnreadMessageSyncNotify: 13,
    signalingChannelsSyncNotify: 14,
    signalingGetChannelInfo: 15
  }

  /**
   * 命令配置
   * params 说明: 如果类型是 Property, 如果没有 entity, entity 值就是 name
   */
};var cmdConfig = {
  // 心跳
  heartbeat: { sid: idMap.link.id, cid: idMap.link.heartbeat },
  // 获取nos上传凭证
  getSimpleNosToken: {
    sid: idMap.misc.id,
    cid: idMap.misc.getSimpleNosToken,
    params: [{ type: 'int', name: 'num' }]
  },
  // 获取nos上传凭证
  getNosToken: {
    sid: idMap.misc.id,
    cid: idMap.misc.getNosToken,
    params: [{ type: 'String', name: 'responseBody' }, { type: 'Property', name: 'nosToken', entity: 'nosToken' }]
  },
  uploadSdkLogUrl: {
    sid: idMap.misc.id,
    cid: idMap.misc.uploadSdkLogUrl,
    params: [{ type: 'string', name: 'url' }]
  },
  // 语音转文字
  audioToText: {
    sid: idMap.misc.id,
    cid: idMap.misc.audioToText,
    params: [{ type: 'Property', name: 'audioToText' }]
  },
  // 处理图片
  processImage: {
    sid: idMap.misc.id,
    cid: idMap.misc.processImage,
    params: [{ type: 'String', name: 'url' }, { type: 'PropertyArray', name: 'imageOps', entity: 'imageOp' }]
  },
  // 获取客户端反垃圾
  getClientAntispam: {
    sid: idMap.misc.id,
    cid: idMap.misc.getClientAntispam,
    params: [{ type: 'Property', name: 'clientAntispam' }]
  },
  // 文件快传
  fileQuickTransfer: {
    sid: idMap.misc.id,
    cid: idMap.misc.fileQuickTransfer,
    params: [{ type: 'Property', name: 'fileQuickTransfer' }]
  },
  // 获取NOS原始文件地址
  getNosOriginUrl: {
    sid: idMap.misc.id,
    cid: idMap.misc.getNosOriginUrl,
    params: [{ type: 'Property', name: 'nosFileUrlTag' }]
  },
  // 获取文档转码专用NOS上传token协议
  getNosTokenTrans: {
    sid: idMap.misc.id,
    cid: idMap.misc.getNosTokenTrans,
    params: [{ type: 'Property', name: 'transToken' }]
  },
  // 获取文档具体内容
  fetchFile: {
    sid: idMap.misc.id,
    cid: idMap.misc.fetchFile,
    params: [{ type: 'String', name: 'docId' }]
  },
  // 获取文档列表
  fetchFileList: {
    sid: idMap.misc.id,
    cid: idMap.misc.fetchFileList,
    params: [{ type: 'Property', name: 'fileListParam' }]
  },
  // 删除文档
  removeFile: {
    sid: idMap.misc.id,
    cid: idMap.misc.removeFile,
    params: [{ type: 'String', name: 'docId' }]
  },
  /*
    通用独立音视频信令
  */
  signalingCreate: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingCreate,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingDelay: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingDelay,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingClose: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingClose,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingJoin: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingJoin,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingLeave: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingLeave,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingInvite: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingInvite,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingCancel: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingCancel,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingReject: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingReject,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingAccept: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingAccept,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingControl: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingControl,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  },

  signalingGetChannelInfo: {
    sid: idMap.avSignal.id,
    cid: idMap.avSignal.signalingGetChannelInfo,
    params: [{ type: 'Property', name: 'avSignalTag' }]
  }

  /**
   * 回包配置
   * response 说明: 如果没有 entity, entity 值就是 name
   */
};var packetConfig = {
  // 心跳
  '1_2': { service: 'link', cmd: 'heartbeat' },
  // 获取nos上传凭证
  '6_1': {
    service: 'misc',
    cmd: 'getSimpleNosToken',
    response: [{ type: 'PropertyArray', name: 'nosTokens', entity: 'nosToken' }]
  },
  // 获取nos上传凭证
  '6_2': {
    service: 'misc',
    cmd: 'getNosToken',
    response: [{ type: 'Property', name: 'nosToken' }]
  },
  '6_3': { service: 'misc', cmd: 'notifyUploadLog' },
  // 语音转文字
  '6_5': {
    service: 'misc',
    cmd: 'audioToText',
    response: [{ type: 'String', name: 'text' }]
  },
  // 处理图片
  '6_6': {
    service: 'misc',
    cmd: 'processImage',
    response: [{ type: 'String', name: 'url' }]
  },
  // 获取文档转码专用NOS上传token协议
  '6_7': {
    service: 'misc',
    cmd: 'getNosTokenTrans',
    response: [{ type: 'Property', name: 'nosToken' }, { type: 'String', name: 'docId' }]
  },
  // 文档转码结束后的下发协议
  '6_8': {
    service: 'misc',
    cmd: 'notifyTransLog',
    response: [{ type: 'Property', name: 'transInfo' }]
  },
  // 查询单个文档内容
  '6_9': {
    service: 'misc',
    cmd: 'fetchFile',
    response: [{ type: 'Property', name: 'info', entity: 'transInfo' }]
  },
  // 查询分页文档
  '6_10': {
    service: 'misc',
    cmd: 'fetchFileList',
    response: [{ type: 'PropertyArray', name: 'list', entity: 'transInfo' }, { type: 'Number', name: 'totalCount' }]
  },
  // 删除文档
  '6_11': {
    service: 'misc',
    cmd: 'removeFile',
    response: [{ type: 'String', name: 'res' }]
  },
  // 客户端反垃圾
  '6_17': {
    service: 'misc',
    cmd: 'getClientAntispam',
    response: [{ type: 'Property', name: 'clientAntispam' }]
  },
  // 文件快传
  '6_18': {
    service: 'misc',
    cmd: 'fileQuickTransfer',
    response: [{ type: 'Property', name: 'fileQuickTransfer' }]
  },
  // 获取NOS文件安全、原始链接
  '6_22': {
    service: 'misc',
    cmd: 'getNosOriginUrl',
    response: [{ type: 'Property', name: 'nosFileUrlTag' }]
  },
  /*
    通用独立音视频信令
  */
  '15_1': {
    service: 'avSignal',
    cmd: 'signalingCreate',
    response: [{ type: 'Property', name: 'avSignalTag' }]
  },
  '15_2': {
    service: 'avSignal',
    cmd: 'signalingDelay',
    response: [{ type: 'Property', name: 'avSignalTag' }]
  },
  '15_3': {
    service: 'avSignal',
    cmd: 'signalingClose',
    response: [{ type: 'Property', name: 'avSignalTag' }]
  },
  '15_4': {
    service: 'avSignal',
    cmd: 'signalingJoin',
    response: [{ type: 'Property', name: 'avSignalTag' }]
  },
  '15_5': {
    service: 'avSignal',
    cmd: 'signalingLeave',
    response: []
  },
  '15_6': {
    service: 'avSignal',
    cmd: 'signalingInvite',
    response: []
  },
  '15_7': {
    service: 'avSignal',
    cmd: 'signalingCancel',
    response: []
  },
  '15_8': {
    service: 'avSignal',
    cmd: 'signalingReject',
    response: []
  },
  '15_9': {
    service: 'avSignal',
    cmd: 'signalingAccept',
    response: []
  },
  '15_10': {
    service: 'avSignal',
    cmd: 'signalingControl',
    response: []
  },
  '15_11': {
    service: 'avSignal',
    cmd: 'signalingNotify',
    response: [{ type: 'Property', name: 'avSignalTag' }]
  },
  '15_12': {
    service: 'avSignal',
    cmd: 'signalingMutilClientSyncNotify',
    response: [{ type: 'Property', name: 'avSignalTag' }]
  },
  '15_13': {
    service: 'avSignal',
    cmd: 'signalingUnreadMessageSyncNotify',
    response: [{ type: 'PropertyArray', name: 'avSignalTag' }]
  },
  '15_14': {
    service: 'avSignal',
    cmd: 'signalingChannelsSyncNotify',
    response: [{ type: 'PropertyArray', name: 'avSignalTag' }]
  },
  '15_15': {
    service: 'avSignal',
    cmd: 'signalingGetChannelInfo',
    response: [{ type: 'Property', name: 'avSignalTag' }]
  }
};

module.exports = {
  idMap: idMap,
  cmdConfig: cmdConfig,
  packetConfig: packetConfig
};

/***/ }),

/***/ "./src/im/protocol/map/configChatroom.js":
/*!***********************************************!*\
  !*** ./src/im/protocol/map/configChatroom.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var configBase = __webpack_require__(/*! ./configBase */ "./src/im/protocol/map/configBase.js");

// 外层是 service, 内层是 cmd
var idMap = util.merge({}, configBase.idMap, {
  chatroom: {
    id: 13,
    // 进入聊天室
    login: 2,
    // 被踢
    kicked: 3,
    // 退出聊天室
    logout: 4,
    // 发消息
    sendMsg: 6,
    // 收到消息
    msg: 7,
    // 分页获取成员列表
    getChatroomMembers: 8,
    // 获取历史消息
    getHistoryMsgs: 9,
    // 设定聊天室成员标记身份
    markChatroomMember: 11,
    // 关闭聊天室
    closeChatroom: 12,
    // 获取当前聊天室信息
    getChatroom: 13,
    // 更新聊天室信息
    updateChatroom: 14,
    // 更新自己在聊天室内的信息
    updateMyChatroomMemberInfo: 15,
    // 获取指定成员在聊天室中的信息
    getChatroomMembersInfo: 16,
    // 踢掉特定成员
    kickChatroomMember: 17,
    // 设置聊天室临时禁言
    updateChatroomMemberTempMute: 19,
    queueOffer: 20,
    queuePoll: 21,
    queueList: 22,
    peak: 23, // 查看头上第一个元素，但不删除
    queueDrop: 24,
    queueInit: 25,
    queueChange: 26
  },
  user: {
    id: 3,
    syncRobot: 16
  }
});

/**
 * 命令配置
 * params 说明: 如果类型是 Property, 如果没有 entity, entity 值就是 name
 */
var cmdConfig = util.merge({}, configBase.cmdConfig, {
  login: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.login,
    params: [{ type: 'byte', name: 'type' }, { type: 'Property', name: 'login' }, { type: 'Property', name: 'imLogin' }] },
  logout: { sid: idMap.chatroom.id, cid: idMap.chatroom.logout },
  sendMsg: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.sendMsg,
    params: [{ type: 'Property', name: 'msg' }] },
  getChatroomMembers: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.getChatroomMembers,
    params: [{ type: 'byte', name: 'type' }, { type: 'long', name: 'time' }, { type: 'int', name: 'limit' }] },
  getHistoryMsgs: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.getHistoryMsgs,
    params: [{ type: 'long', name: 'timetag' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }, { type: 'LongArray', name: 'msgTypes' }] },
  markChatroomMember: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.markChatroomMember,
    params: [{ type: 'string', name: 'account' }, { type: 'int', name: 'type' }, { type: 'bool', name: 'isAdd' }, { type: 'int', name: 'level' }, { type: 'string', name: 'custom' }] },
  closeChatroom: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.closeChatroom,
    params: [{ type: 'string', name: 'custom' }] },
  getChatroom: { sid: idMap.chatroom.id, cid: idMap.chatroom.getChatroom },
  updateChatroom: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.updateChatroom,
    params: [{ type: 'Property', name: 'chatroom' }, { type: 'bool', name: 'needNotify' }, { type: 'String', name: 'custom' }] },
  updateMyChatroomMemberInfo: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.updateMyChatroomMemberInfo,
    params: [{ type: 'Property', name: 'chatroomMember' }, { type: 'bool', name: 'needNotify' }, { type: 'String', name: 'custom' }, { type: 'bool', name: 'needSave' }] },
  getChatroomMembersInfo: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.getChatroomMembersInfo,
    params: [{ type: 'StrArray', name: 'accounts' }] },
  kickChatroomMember: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.kickChatroomMember,
    params: [{ type: 'string', name: 'account' }, { type: 'string', name: 'custom' }] },
  updateChatroomMemberTempMute: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.updateChatroomMemberTempMute,
    params: [{ type: 'String', name: 'account' }, { type: 'long', name: 'duration' }, { type: 'bool', name: 'needNotify' }, { type: 'String', name: 'custom' }] },
  queueOffer: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.queueOffer,
    params: [{ type: 'string', name: 'elementKey' }, { type: 'string', name: 'elementValue' }, { type: 'bool', name: 'transient' }] },
  queuePoll: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.queuePoll,
    params: [{ type: 'string', name: 'elementKey' }] },
  queueList: { sid: idMap.chatroom.id, cid: idMap.chatroom.queueList },
  peak: { sid: idMap.chatroom.id, cid: idMap.chatroom.peak },
  queueDrop: { sid: idMap.chatroom.id, cid: idMap.chatroom.queueDrop },
  queueInit: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.queueInit,
    params: [{ type: 'int', name: 'limit' }] },
  queueChange: { sid: idMap.chatroom.id,
    cid: idMap.chatroom.queueChange,
    params: [{ type: 'StrStrMap', name: 'elementMap' }, { type: 'bool', name: 'needNotify' }, { type: 'string', name: 'notifyExt' }] },
  syncRobot: {
    sid: idMap.user.id,
    cid: idMap.user.syncRobot,
    params: [{ type: 'long', name: 'timetag' }]
  }
});

/**
 * 回包配置
 * response 说明: 如果没有 entity, entity 值就是 name
 */
var serviceChatroom = 'chatroom';
var packetConfig = util.merge({}, configBase.packetConfig, {
  // 通知包
  '4_10': { service: 'notify' },
  '4_11': { service: 'notify' },
  '3_16': { service: serviceChatroom,
    cmd: 'syncRobot',
    response: [{ type: 'PropertyArray', name: 'robots', entity: 'robot' }] },
  '13_2': { service: serviceChatroom,
    cmd: 'login',
    response: [{ type: 'Property', name: 'chatroom' }, { type: 'Property', name: 'chatroomMember' }] },
  '13_3': { service: serviceChatroom,
    cmd: 'kicked',
    response: [{ type: 'Number', name: 'reason' }, { type: 'String', name: 'custom' }] },
  '13_4': { service: serviceChatroom, cmd: 'logout' },
  '13_6': { service: serviceChatroom,
    cmd: 'sendMsg',
    response: [{ type: 'Property', name: 'msg' }] },
  '13_7': { service: serviceChatroom,
    cmd: 'msg',
    response: [{ type: 'Property', name: 'msg' }] },
  '13_8': { service: serviceChatroom,
    cmd: 'getChatroomMembers',
    response: [{ type: 'PropertyArray', name: 'members', entity: 'chatroomMember' }] },
  '13_9': { service: serviceChatroom,
    cmd: 'getHistoryMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
  '13_11': { service: serviceChatroom,
    cmd: 'markChatroomMember',
    response: [{ type: 'Property', name: 'chatroomMember' }] },
  '13_12': { service: serviceChatroom, cmd: 'closeChatroom' },
  '13_13': { service: serviceChatroom,
    cmd: 'getChatroom',
    response: [{ type: 'Property', name: 'chatroom' }] },
  '13_14': { service: serviceChatroom, cmd: 'updateChatroom' },
  '13_15': { service: serviceChatroom, cmd: 'updateMyChatroomMemberInfo' },
  '13_16': { service: serviceChatroom,
    cmd: 'getChatroomMembersInfo',
    response: [{ type: 'PropertyArray', name: 'members', entity: 'chatroomMember' }] },
  '13_17': { service: serviceChatroom, cmd: 'kickChatroomMember' },
  '13_19': { service: serviceChatroom, cmd: 'updateChatroomMemberTempMute' },
  '13_20': { service: serviceChatroom, cmd: 'queueOffer' },
  '13_21': { service: serviceChatroom,
    cmd: 'queuePoll',
    response: [{ type: 'String', name: 'elementKey' }, { type: 'String', name: 'elementValue' }] },
  '13_22': { service: serviceChatroom,
    cmd: 'queueList',
    response: [{ type: 'KVArray', name: 'queueList' }] },
  '13_23': { service: serviceChatroom,
    cmd: 'peak',
    response: [{ type: 'String', name: 'elementKey' }, { type: 'String', name: 'elementValue' }] },
  '13_24': { service: serviceChatroom, cmd: 'queueDrop' },
  '13_25': { service: serviceChatroom, cmd: 'queueInit' },
  '13_26': { service: serviceChatroom,
    cmd: 'queueChange',
    response: [{ type: 'StrArray', name: 'elementKeyArray' }] }
});

module.exports = {
  idMap: idMap,
  cmdConfig: cmdConfig,
  packetConfig: packetConfig
};

/***/ }),

/***/ "./src/im/protocol/map/configIM.js":
/*!*****************************************!*\
  !*** ./src/im/protocol/map/configIM.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var configBase = __webpack_require__(/*! ./configBase */ "./src/im/protocol/map/configBase.js");

// 外层是 service, 内层是 cmd
var idMap = util.merge({}, configBase.idMap, {
  // 登录协议
  auth: {
    id: 2,
    // web一键登录
    login: 3,
    // 被踢通知
    kicked: 5,
    // 退出登录
    logout: 6,
    // 多端登陆通知
    multiPortLogin: 7,
    // 踢其它端
    kick: 8
  },
  // 用户协议
  user: {
    id: 3,
    // 更新push token
    updatePushToken: 1,
    // app切后台
    appBackground: 2,
    // 加入黑名单/从黑名单移除
    markInBlacklist: 3,
    // 获取黑名单
    getBlacklist: 4,
    // 加入静音列表/从静音列表移除
    markInMutelist: 5,
    // 获取静音列表
    getMutelist: 6,
    // 获取黑名单和静音列表
    getRelations: 8,
    getUsers: 7,
    updateMyInfo: 10,
    updateDonnop: 15,
    // syncRobot: 16,
    syncMyInfo: 109,
    syncUpdateMyInfo: 110
  },
  // 通知
  notify: {
    id: 4,
    // 标记通知已读
    markRead: 3,
    // 离线session+team消息通知
    syncOfflineMsgs: 4,
    // 批量标记协议已读
    batchMarkRead: 5,
    // 离线system消息同步通知
    syncOfflineSysMsgs: 6,
    // 漫游消息同步通知
    // 每个会话返回一个包
    syncRoamingMsgs: 9,
    // 消息已读同步通知
    syncMsgReceipts: 12,
    // 同步机器人列表
    syncRobots: 15,
    syncBroadcastMsgs: 16,
    // 超大群漫游消息，一条会话一个回包
    syncSuperTeamRoamingMsgs: 17
  },
  // 同步
  sync: {
    id: 5,
    // 同步
    sync: 1,
    // 同步群成员
    syncTeamMembers: 2,
    // 同步超大群群成员
    syncSuperTeamMembers: 3
  },
  // 消息
  msg: {
    id: 7,
    // 发送消息
    sendMsg: 1,
    // 消息通知
    msg: 2,
    // 系统通知通知
    sysMsg: 3,
    // 获取单人历史消息
    getHistoryMsgs: 6,
    // 发送自定义系统通知
    sendCustomSysMsg: 7,
    // 获取包含关键词的单人历史消息
    searchHistoryMsgs: 8,
    // 删除会话
    deleteSessions: 9,
    // 获取会话列表
    getSessions: 10,
    // 发送消息后发送方的多端同步通知
    syncSendMsg: 101,
    // 发送消息已读回执
    sendMsgReceipt: 11,
    // 收到消息已读回执
    msgReceipt: 12,
    // 撤回消息
    deleteMsg: 13,
    // 撤回消息通知
    msgDeleted: 14,
    markSessionAck: 16,
    // 广播通知
    broadcastMsg: 17,
    // 删除单人会话云端历史消息
    clearServerHistoryMsgs: 18
  },
  // 群
  team: {
    id: 8,
    // 创建群
    createTeam: 1,
    // 发送群消息
    sendTeamMsg: 2,
    // 群消息通知
    teamMsg: 3,
    // 群消息列表通知
    teamMsgs: 4,
    // 拉人入群
    addTeamMembers: 5,
    // 踢人出群
    removeTeamMembers: 6,
    // 修改群资料
    updateTeam: 7,
    // 退出群
    leaveTeam: 8,
    // 获取群
    getTeam: 9,
    // 获取群列表
    getTeams: 10,
    // 获取群成员
    getTeamMembers: 11,
    // 解散群
    dismissTeam: 12,
    // 申请入群
    applyTeam: 13,
    // 同意入群申请
    passTeamApply: 14,
    // 拒绝入群申请
    rejectTeamApply: 15,
    // 添加群管理员
    addTeamManagers: 16,
    // 移除群管理员
    removeTeamManagers: 17,
    // 转让群
    transferTeam: 18,
    // 修改自己的群资料
    updateInfoInTeam: 19,
    // 修改别人的群昵称
    updateNickInTeam: 20,
    // 接受入群邀请
    acceptTeamInvite: 21,
    // 拒绝入群邀请
    rejectTeamInvite: 22,
    // 获取群组历史消息
    getTeamHistoryMsgs: 23,
    // 获取包含关键词的群组历史消息
    searchTeamHistoryMsgs: 24,
    // 群成员禁言
    updateMuteStateInTeam: 25,
    // 获取指定群的我的群信息
    getMyTeamMembers: 26,
    // 获取群禁言成员列表
    getMutedTeamMembers: 27,
    // 同步所有群的我的群信息
    sendTeamMsgReceipt: 28,
    // 标记群组消息已读
    getTeamMsgReads: 29,
    // 查询群组消息已读、未读数量
    getTeamMsgReadAccounts: 30,
    // 查询群组已读、未读账号列表
    notifyTeamMsgReads: 31,
    // 通知群组消息已读
    muteTeamAll: 32,
    // 获取群成员的邀请者accid
    getTeamMemberInvitorAccid: 33,
    // 设置群禁言
    syncMyTeamMembers: 126,
    // 同步群列表通知
    syncTeams: 109,
    // 同步群成员通知
    syncTeamMembers: 111,
    // 多端同步创建群通知
    syncCreateTeam: 101,
    // 多端同步发送群消息通知
    syncSendTeamMsg: 102,
    // 多端同步更新群成员通知
    syncUpdateTeamMember: 119
  },
  superTeam: {
    id: 21,
    // 发送超大群消息
    sendSuperTeamMsg: 2,
    // 超大群消息通知
    superTeamMsg: 3,
    // 拉人入群
    addSuperTeamMembers: 5,
    // 踢人出群
    removeSuperTeamMembers: 6,
    // 主动退群
    leaveSuperTeam: 7,
    // 更新群信息
    updateSuperTeam: 8,
    // 获取群信息
    getSuperTeam: 9,
    // 获取群信息列表，可分批查询
    getSuperTeams: 12,
    // 修改个人群成员信息
    updateInfoInSuperTeam: 10,
    // 获取指定群列表的我的群信息，实际中没用
    getMySuperTeamMembers: 11,
    // 获取（同步）群成员信息列表
    getSuperTeamMembers: 13,
    // 获取超大群云端历史消息
    getSuperTeamHistoryMsgs: 14,
    // 同步所在群的个人群成员信息
    syncMySuperTeamMembers: 111,
    // 同步群信息列表
    syncSuperTeams: 109,
    // 同步群成员列表
    syncSuperTeamMembers: 113,
    // 多端同步创建群
    syncCreateSuperTeam: 101,
    // 多端同步发送群消息
    syncSendSuperTeamMsg: 102,
    // 多端同步更新群成员信息
    syncUpdateSuperTeamMember: 110
  },
  // 好友协议
  friend: {
    id: 12,
    // 添加好友
    friendRequest: 1,
    // 添加好友多端同步
    syncFriendRequest: 101,
    // 删除好友
    deleteFriend: 2,
    // 删除好友多端同步
    syncDeleteFriend: 102,
    // 更新好友
    updateFriend: 3,
    // 更新好友多端同步
    syncUpdateFriend: 103,
    // 获取好友列表
    getFriends: 4
  },
  chatroom: {
    id: 13,
    getChatroomAddress: 1
  },
  // 过滤协议, 此协议下的消息都会转发给第三方服务器, 由第三方服务器处理后得到最终发送的消息内容
  filter: {
    id: 101,
    // 发送过滤消息
    sendFilterMsg: 1,
    // 过滤消息通知
    filterMsg: 2,
    // 过滤系统通知通知
    filterSysMsg: 3,
    // 发送过滤自定义系统通知
    sendFilterCustomSysMsg: 7
  },
  // 事件服务协议 发布-订阅 模型
  eventService: {
    id: 14,
    publishEvent: 1,
    pushEvent: 2,
    subscribeEvent: 3,
    unSubscribeEventsByAccounts: 4,
    unSubscribeEventsByType: 5,
    querySubscribeEventsByAccounts: 6,
    querySubscribeEventsByType: 7,
    pushEvents: 9
  }
});

/**
 * 命令配置
 * params 说明: 如果类型是 Property, 如果没有 entity, entity 值就是 name
 */
var cmdConfig = util.merge({}, configBase.cmdConfig, {
  // 登录
  login: {
    sid: idMap.auth.id,
    cid: idMap.auth.login,
    params: [{ type: 'Property', name: 'login' }]
  },
  // 退出登录
  logout: { sid: idMap.auth.id, cid: idMap.auth.logout },
  // 踢其它端
  kick: {
    sid: idMap.auth.id,
    cid: idMap.auth.kick,
    params: [{ type: 'StrArray', name: 'deviceIds' }]
  },
  // 更新推送token
  updatePushToken: {
    sid: idMap.user.id,
    cid: idMap.user.updatePushToken,
    params: [{ type: 'String', name: 'tokenName' }, { type: 'String', name: 'token' },
    // 不填apns，1:pushkit音视频
    { type: 'int', name: 'pushkit' }]
  },
  // app前后台切换
  appBackground: {
    sid: idMap.user.id,
    cid: idMap.user.appBackground,
    params: [{ type: 'bool', name: 'isBackground' }, { type: 'Int', name: 'badge' }]
  },
  // 加入黑名单/从黑名单移除
  markInBlacklist: {
    sid: idMap.user.id,
    cid: idMap.user.markInBlacklist,
    params: [{ type: 'String', name: 'account' }, { type: 'bool', name: 'isAdd' }]
  },
  // 获取黑名单
  getBlacklist: {
    sid: idMap.user.id,
    cid: idMap.user.getBlacklist,
    params: [{ type: 'long', name: 'time' }]
  },
  // 加入静音列表/从静音列表移除
  markInMutelist: {
    sid: idMap.user.id,
    cid: idMap.user.markInMutelist,
    params: [{ type: 'String', name: 'account' }, { type: 'bool', name: 'isAdd' }]
  },
  // 获取静音列表
  getMutelist: {
    sid: idMap.user.id,
    cid: idMap.user.getMutelist,
    params: [{ type: 'long', name: 'time' }]
  },
  getRelations: {
    sid: idMap.user.id,
    cid: idMap.user.getRelations,
    params: [{ type: 'long', name: 'timetag' }]
  },
  getUsers: {
    sid: idMap.user.id,
    cid: idMap.user.getUsers,
    params: [{ type: 'StrArray', name: 'accounts' }]
  },
  updateMyInfo: {
    sid: idMap.user.id,
    cid: idMap.user.updateMyInfo,
    params: [{ type: 'Property', name: 'user' }]
  },
  updateDonnop: {
    sid: idMap.user.id,
    cid: idMap.user.updateDonnop,
    params: [{ type: 'Property', name: 'donnop' }]
  },

  // 标记通知已读, 实际未使用, 统一使用批量标记协议已读
  markRead: {
    sid: idMap.notify.id,
    cid: idMap.notify.markRead,
    params: [{ type: 'long', name: 'id' }, { type: 'ph', name: 'ph' }]
  },
  // 批量标记协议已读
  batchMarkRead: {
    sid: idMap.notify.id,
    cid: idMap.notify.batchMarkRead,
    params: [{ type: 'byte', name: 'sid' }, { type: 'byte', name: 'cid' }, { type: 'LongArray', name: 'ids' }]
  },

  // 同步 4_4(离线session+team消息), 4_6(离线system消息), 8_109(群资料)
  sync: {
    sid: idMap.sync.id,
    cid: idMap.sync.sync,
    params: [{ type: 'Property', name: 'sync' }]
  },
  // 同步群成员
  syncTeamMembers: {
    sid: idMap.sync.id,
    cid: idMap.sync.syncTeamMembers,
    params: [{ type: 'LongLongMap', name: 'sync' }]
  },
  // 同步超大群成员
  syncSuperTeamMembers: {
    sid: idMap.sync.id,
    cid: idMap.sync.syncSuperTeamMembers,
    params: [{ type: 'LongLongMap', name: 'sync' }]
  },

  // 发送消息
  sendMsg: {
    sid: idMap.msg.id,
    cid: idMap.msg.sendMsg,
    params: [{ type: 'Property', name: 'msg' }]
  },
  // 获取单人历史消息
  getHistoryMsgs: {
    sid: idMap.msg.id,
    cid: idMap.msg.getHistoryMsgs,
    params: [{ type: 'String', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'long', name: 'lastMsgId' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }, { type: 'LongArray', name: 'msgTypes' }]
  },
  // 发送自定义系统通知
  sendCustomSysMsg: {
    sid: idMap.msg.id,
    cid: idMap.msg.sendCustomSysMsg,
    params: [{ type: 'Property', name: 'sysMsg' }]
  },
  // 获取包含关键词的单人历史消息
  searchHistoryMsgs: {
    sid: idMap.msg.id,
    cid: idMap.msg.searchHistoryMsgs,
    params: [{ type: 'String', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'String', name: 'keyword' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }]
  },
  // 获取会话列表
  getSessions: {
    sid: idMap.msg.id,
    cid: idMap.msg.getSessions,
    params: [{ type: 'long', name: 'time' }]
  },
  // 删除会话
  deleteSessions: {
    sid: idMap.msg.id,
    cid: idMap.msg.deleteSessions,
    params: [{ type: 'StrArray', name: 'sessions' }]
  },
  sendMsgReceipt: {
    sid: idMap.msg.id,
    cid: idMap.msg.sendMsgReceipt,
    params: [{ type: 'Property', name: 'msgReceipt' }]
  },
  deleteMsg: {
    sid: idMap.msg.id,
    cid: idMap.msg.deleteMsg,
    params: [{ type: 'Property', name: 'sysMsg' }]
  },
  markSessionAck: {
    sid: idMap.msg.id,
    cid: idMap.msg.markSessionAck,
    params: [{ type: 'byte', name: 'scene' }, { type: 'String', name: 'to' }, { type: 'long', name: 'timetag' }]
  },
  clearServerHistoryMsgs: {
    sid: idMap.msg.id,
    cid: idMap.msg.clearServerHistoryMsgs,
    params: [{ type: 'Property', name: 'clearMsgsParams' }]
  },
  // 发送超大群消息
  sendSuperTeamMsg: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.sendSuperTeamMsg,
    params: [{ type: 'Property', name: 'msg' }]
  },
  // 拉人入超大群
  addSuperTeamMembers: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.addSuperTeamMembers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }]
  },
  // 踢人出超大群
  removeSuperTeamMembers: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.removeSuperTeamMembers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }]
  },
  // 退出超大群
  leaveSuperTeam: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.leaveSuperTeam,
    params: [{ type: 'long', name: 'teamId' }]
  },
  // 更新超大群
  updateSuperTeam: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.updateSuperTeam,
    params: [{ type: 'Property', name: 'team' }]
  },
  // 获取超大群
  getSuperTeam: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.getSuperTeam,
    params: [{ type: 'long', name: 'teamId' }]
  },
  // 获取超大群列表
  getSuperTeams: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.getSuperTeams,
    params: [{ type: 'long', name: 'timetag' }]
  },
  // 获取超大群成员列表
  getSuperTeamMembers: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.getSuperTeamMembers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'long', name: 'timetag' }]
  },
  // 修改个人超大群成员信息
  updateInfoInSuperTeam: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.updateInfoInSuperTeam,
    params: [{ type: 'Property', name: 'superTeamMember' }]
  },
  getSuperTeamHistoryMsgs: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.getSuperTeamHistoryMsgs,
    params: [{ type: 'long', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'long', name: 'lastMsgId' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }, { type: 'LongArray', name: 'msgTypes' }]
  },
  // 获取群列表中我的群成员信息
  getMySuperTeamMembers: {
    sid: idMap.superTeam.id,
    cid: idMap.superTeam.getMySuperTeamMembers,
    params: [{ type: 'LongArray', name: 'teamIds' }]
  },
  // 创建群
  createTeam: {
    sid: idMap.team.id,
    cid: idMap.team.createTeam,
    params: [{ type: 'Property', name: 'team' }, { type: 'StrArray', name: 'accounts' }, { type: 'String', name: 'ps' }]
  },
  // 发送群消息
  sendTeamMsg: {
    sid: idMap.team.id,
    cid: idMap.team.sendTeamMsg,
    params: [{ type: 'Property', name: 'msg' }]
  },
  // 拉人入群
  addTeamMembers: {
    sid: idMap.team.id,
    cid: idMap.team.addTeamMembers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }, { type: 'String', name: 'ps' }, { type: 'String', name: 'attach' }]
  },
  // 踢人出群
  removeTeamMembers: {
    sid: idMap.team.id,
    cid: idMap.team.removeTeamMembers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }]
  },
  // 更新群
  updateTeam: {
    sid: idMap.team.id,
    cid: idMap.team.updateTeam,
    params: [{ type: 'Property', name: 'team' }]
  },
  // 退出群
  leaveTeam: {
    sid: idMap.team.id,
    cid: idMap.team.leaveTeam,
    params: [{ type: 'long', name: 'teamId' }]
  },
  // 获取群
  getTeam: {
    sid: idMap.team.id,
    cid: idMap.team.getTeam,
    params: [{ type: 'long', name: 'teamId' }]
  },
  // 获取群列表
  getTeams: {
    sid: idMap.team.id,
    cid: idMap.team.getTeams,
    params: [{ type: 'long', name: 'timetag' }]
  },
  // 获取群成员
  getTeamMembers: {
    sid: idMap.team.id,
    cid: idMap.team.getTeamMembers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'long', name: 'timetag' }]
  },
  // 解散群
  dismissTeam: {
    sid: idMap.team.id,
    cid: idMap.team.dismissTeam,
    params: [{ type: 'long', name: 'teamId' }]
  },
  // 申请入群
  applyTeam: {
    sid: idMap.team.id,
    cid: idMap.team.applyTeam,
    params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'ps' }]
  },
  // 同意入群申请
  passTeamApply: {
    sid: idMap.team.id,
    cid: idMap.team.passTeamApply,
    params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }]
  },
  // 拒绝入群申请
  rejectTeamApply: {
    sid: idMap.team.id,
    cid: idMap.team.rejectTeamApply,
    params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }, { type: 'String', name: 'ps' }]
  },
  // 添加群管理员
  addTeamManagers: {
    sid: idMap.team.id,
    cid: idMap.team.addTeamManagers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }]
  },
  // 移除群管理员
  removeTeamManagers: {
    sid: idMap.team.id,
    cid: idMap.team.removeTeamManagers,
    params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }]
  },
  // 转让群
  transferTeam: {
    sid: idMap.team.id,
    cid: idMap.team.transferTeam,
    params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'account' }, { type: 'bool', name: 'leave' }]
  },
  // 修改自己的群资料
  updateInfoInTeam: {
    sid: idMap.team.id,
    cid: idMap.team.updateInfoInTeam,
    params: [{ type: 'Property', name: 'teamMember' }]
  },
  // 修改别人的群昵称
  updateNickInTeam: {
    sid: idMap.team.id,
    cid: idMap.team.updateNickInTeam,
    params: [{ type: 'Property', name: 'teamMember' }]
  },
  // 接受入群邀请
  acceptTeamInvite: {
    sid: idMap.team.id,
    cid: idMap.team.acceptTeamInvite,
    params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }]
  },
  // 拒绝入群邀请
  rejectTeamInvite: {
    sid: idMap.team.id,
    cid: idMap.team.rejectTeamInvite,
    params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }, { type: 'String', name: 'ps' }]
  },
  // 获取群组历史消息
  getTeamHistoryMsgs: {
    sid: idMap.team.id,
    cid: idMap.team.getTeamHistoryMsgs,
    params: [{ type: 'long', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'long', name: 'lastMsgId' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }, { type: 'LongArray', name: 'msgTypes' }]
  },
  // 获取包含关键词的群组历史消息
  searchTeamHistoryMsgs: {
    sid: idMap.team.id,
    cid: idMap.team.searchTeamHistoryMsgs,
    params: [{ type: 'long', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'String', name: 'keyword' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }]
  },
  // 群成员禁言
  updateMuteStateInTeam: {
    sid: idMap.team.id,
    cid: idMap.team.updateMuteStateInTeam,
    params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'account' }, { type: 'int', name: 'mute' }]
  },
  getMyTeamMembers: {
    sid: idMap.team.id,
    cid: idMap.team.getMyTeamMembers,
    params: [{ type: 'LongArray', name: 'teamIds' }]
  },
  getMutedTeamMembers: {
    sid: idMap.team.id,
    cid: idMap.team.getMutedTeamMembers,
    params: [{ type: 'long', name: 'teamId' }]
  },
  // 标记群组消息已读
  sendTeamMsgReceipt: {
    sid: idMap.team.id,
    cid: idMap.team.sendTeamMsgReceipt,
    params: [{
      type: 'PropertyArray',
      name: 'teamMsgReceipts',
      entity: 'teamMsgReceipt'
    }]
  },
  // 查询群组消息已读、未读数量
  getTeamMsgReads: {
    sid: idMap.team.id,
    cid: idMap.team.getTeamMsgReads,
    params: [{
      type: 'PropertyArray',
      name: 'teamMsgReceipts',
      entity: 'teamMsgReceipt'
    }]
  },
  // 查询群组已读、未读账号列表
  getTeamMsgReadAccounts: {
    sid: idMap.team.id,
    cid: idMap.team.getTeamMsgReadAccounts,
    params: [{
      type: 'Property',
      name: 'teamMsgReceipt'
    }]
  },

  muteTeamAll: {
    sid: idMap.team.id,
    cid: idMap.team.muteTeamAll,
    params: [{ type: 'long', name: 'teamId' }, { type: 'int', name: 'muteType' }]
  },
  // 获取群成员的邀请者accid
  getTeamMemberInvitorAccid: {
    sid: idMap.team.id,
    cid: idMap.team.getTeamMemberInvitorAccid,
    params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }]
  },
  // 添加好友
  friendRequest: {
    sid: idMap.friend.id,
    cid: idMap.friend.friendRequest,
    params: [{ type: 'String', name: 'account' }, { type: 'byte', name: 'type' }, { type: 'String', name: 'ps' }]
  },
  // 删除好友
  deleteFriend: {
    sid: idMap.friend.id,
    cid: idMap.friend.deleteFriend,
    params: [{ type: 'String', name: 'account' }, { type: 'Property', name: 'delFriendParams' }]
  },
  // 更新好友
  updateFriend: {
    sid: idMap.friend.id,
    cid: idMap.friend.updateFriend,
    params: [{ type: 'Property', name: 'friend' }]
  },
  // 获取好友列表
  getFriends: {
    sid: idMap.friend.id,
    cid: idMap.friend.getFriends,
    params: [{ type: 'long', name: 'timetag' }]
  },
  getChatroomAddress: {
    sid: idMap.chatroom.id,
    cid: idMap.chatroom.getChatroomAddress,
    params: [{ type: 'long', name: 'chatroomId' }, { type: 'bool', name: 'isWeixinApp' }]
  },
  // 发送过滤消息
  sendFilterMsg: {
    sid: idMap.filter.id,
    cid: idMap.filter.sendFilterMsg,
    params: [{ type: 'Property', name: 'msg' }]
  },
  // 发送过滤自定义系统通知
  sendFilterCustomSysMsg: {
    sid: idMap.filter.id,
    cid: idMap.filter.sendFilterCustomSysMsg,
    params: [{ type: 'Property', name: 'sysMsg' }]
  },
  // 发布事件
  publishEvent: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.publishEvent,
    params: [{ type: 'Property', name: 'msgEvent' }]
  },
  pushEvent: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.pushEvent
  },
  subscribeEvent: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.subscribeEvent,
    params: [{
      type: 'Property',
      name: 'msgEventSubscribe'
    }, {
      type: 'StrArray',
      name: 'accounts'
    }]
  },
  unSubscribeEventsByAccounts: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.unSubscribeEventsByAccounts,
    params: [{
      type: 'Property',
      name: 'msgEventSubscribe'
    }, {
      type: 'StrArray',
      name: 'accounts'
    }]
  },
  unSubscribeEventsByType: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.unSubscribeEventsByType,
    params: [{ type: 'Property', name: 'msgEventSubscribe' }]
  },
  querySubscribeEventsByAccounts: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.querySubscribeEventsByAccounts,
    params: [{
      type: 'Property',
      name: 'msgEventSubscribe'
    }, {
      type: 'StrArray',
      name: 'accounts'
    }]
  },
  querySubscribeEventsByType: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.querySubscribeEventsByType,
    params: [{ type: 'Property', name: 'msgEventSubscribe' }]
  },
  pushEvents: {
    sid: idMap.eventService.id,
    cid: idMap.eventService.pushEvents
  }
});

/**
 * 回包配置
 * response 说明: 如果没有 entity, entity 值就是 name
 */
var packetConfig = util.merge({}, configBase.packetConfig, {
  // 登录
  '2_3': {
    service: 'auth',
    cmd: 'login',
    response: [{ type: 'Property', name: 'loginRes' }, { type: 'PropertyArray', name: 'loginPorts', entity: 'loginPort' }, { type: 'Property', name: 'aosPushInfo' }]
  },
  // 被踢通知
  '2_5': {
    service: 'auth',
    cmd: 'kicked',
    response: [{ type: 'Number', name: 'from' }, { type: 'Number', name: 'reason' }]
  },
  // 退出登录
  '2_6': { service: 'auth', cmd: 'logout' },
  // 多端登陆通知
  '2_7': {
    service: 'auth',
    cmd: 'multiPortLogin',
    response: [{ type: 'Number', name: 'state' }, { type: 'PropertyArray', name: 'loginPorts', entity: 'loginPort' }]
  },
  // 踢其它端
  '2_8': {
    service: 'auth',
    cmd: 'kick',
    response: [{ type: 'StrArray', name: 'deviceIds' }]
  },
  '3_1': { service: 'user', cmd: 'updatePushToken' },
  '3_2': { service: 'user', cmd: 'appBackground' },
  // 加入黑名单/从黑名单移除
  '3_3': { service: 'user', cmd: 'markInBlacklist' },
  // 加入黑名单/从黑名单移除多端同步
  '3_103': {
    service: 'user',
    cmd: 'syncMarkInBlacklist',
    response: [{ type: 'String', name: 'account' }, { type: 'Boolean', name: 'isAdd' }]
  },
  // 获取黑名单
  '3_4': {
    service: 'user',
    cmd: 'getBlacklist',
    response: [{ type: 'StrArray', name: 'blacklist' }]
  },
  // 加入静音列表/从静音列表移除
  '3_5': { service: 'user', cmd: 'markInMutelist' },
  // 加入静音列表/从静音列表移除多端同步
  '3_105': {
    service: 'user',
    cmd: 'syncMarkInMutelist',
    response: [{ type: 'String', name: 'account' }, { type: 'Boolean', name: 'isAdd' }]
  },
  // 获取静音列表
  '3_6': {
    service: 'user',
    cmd: 'getMutelist',
    response: [{ type: 'StrArray', name: 'mutelist' }]
  },
  // 获取黑名单和静音列表
  '3_8': {
    service: 'user',
    cmd: 'getRelations',
    response: [{
      type: 'PropertyArray',
      name: 'specialRelations',
      entity: 'specialRelation'
    }, { type: 'Number', name: 'timetag' }]
  },
  '3_7': {
    service: 'user',
    cmd: 'getUsers',
    response: [{ type: 'PropertyArray', name: 'users', entity: 'user' }]
  },
  '3_10': {
    service: 'user',
    cmd: 'updateMyInfo',
    response: [{ type: 'Number', name: 'timetag' }]
  },
  '3_15': {
    service: 'user',
    cmd: 'updateDonnop',
    response: [{ type: 'Number', name: 'timetag' }]
  },
  // '3_16': {service: 'user', cmd: 'syncRobot', response: [
  //     {type: 'PropertyArray', name: 'robots', entity: 'robot'},
  // ]},
  '3_115': {
    service: 'user',
    cmd: 'syncUpdateDonnop',
    response: [{ type: 'Property', name: 'donnop' }, { type: 'Number', name: 'timetag' }]
  },
  '3_109': {
    service: 'user',
    cmd: 'syncMyInfo',
    response: [{ type: 'Property', name: 'user' }, { type: 'Number', name: 'timetag' }]
  },
  '3_110': {
    service: 'user',
    cmd: 'syncUpdateMyInfo',
    response: [{ type: 'Property', name: 'user' }]
  },

  // 通知包
  '4_1': { service: 'notify' },
  '4_2': { service: 'notify' },
  '4_3': { service: 'notify', cmd: 'markRead' },
  // 离线session+team消息同步通知
  '4_4': {
    service: 'notify',
    cmd: 'syncOfflineMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 批量标记协议已读
  '4_5': { service: 'notify', cmd: 'batchMarkRead' },
  // 离线sysMsg通知
  '4_6': {
    service: 'notify',
    cmd: 'syncOfflineSysMsgs',
    response: [{ type: 'PropertyArray', name: 'sysMsgs', entity: 'sysMsg' }]
  },
  // 漫游消息同步通知
  '4_9': {
    service: 'notify',
    cmd: 'syncRoamingMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 超大群漫游消息同步通知
  '4_17': {
    service: 'notify',
    cmd: 'syncSuperTeamRoamingMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 消息已读同步通知
  '4_12': {
    service: 'notify',
    cmd: 'syncMsgReceipts',
    response: [{ type: 'PropertyArray', name: 'msgReceipts', entity: 'msgReceipt' }, { type: 'Number', name: 'timetag' }]
  },
  '4_13': {
    service: 'notify',
    cmd: 'syncDonnop',
    response: [{ type: 'Property', name: 'donnop' }, { type: 'Number', name: 'timetag' }]
  },
  '4_14': {
    service: 'notify',
    cmd: 'syncSessionAck',
    response: [{ type: 'StrLongMap', name: 'p2p' }, { type: 'LongLongMap', name: 'team' }, { type: 'Number', name: 'timetag' }]
  },
  '4_15': {
    service: 'notify',
    cmd: 'syncRobots',
    response: [{ type: 'PropertyArray', name: 'robots', entity: 'robot' }]
  },
  '4_16': {
    service: 'notify',
    cmd: 'syncBroadcastMsgs',
    response: [{ type: 'PropertyArray', name: 'broadcastMsgs', entity: 'broadcastMsg' }]
  },
  // 离线过滤的消息通知
  '4_100': {
    service: 'notify',
    cmd: 'syncOfflineFilterMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 离线过滤的sysMsg通知
  '4_101': {
    service: 'notify',
    cmd: 'syncOfflineFilterSysMsgs',
    response: [{ type: 'PropertyArray', name: 'sysMsgs', entity: 'sysMsg' }]
  },
  // 同步
  '5_1': {
    service: 'sync',
    cmd: 'syncDone',
    response: [{ type: 'Number', name: 'timetag' }]
  },
  // 同步群成员
  '5_2': {
    service: 'sync',
    cmd: 'syncTeamMembersDone',
    response: [{ type: 'Number', name: 'timetag' }]
  },
  // 同步超大群成员
  '5_3': {
    service: 'sync',
    cmd: 'syncSuperTeamMembersDone',
    response: [{ type: 'Number', name: 'timetag' }]
  },
  // 发送消息
  '7_1': {
    service: 'msg',
    cmd: 'sendMsg',
    response: [{ type: 'Property', name: 'msg' }],
    trivialErrorCodes: [7101]
  },
  // 消息通知
  '7_2': {
    service: 'msg',
    cmd: 'msg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 系统通知通知
  '7_3': {
    service: 'msg',
    cmd: 'sysMsg',
    response: [{ type: 'Property', name: 'sysMsg' }]
  },
  // 获取单人历史消息
  '7_6': {
    service: 'msg',
    cmd: 'getHistoryMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 发送自定义系统通知
  '7_7': {
    service: 'msg',
    cmd: 'sendCustomSysMsg',
    trivialErrorCodes: [7101]
  },
  // 获取包含关键词的单人历史消息
  '7_8': {
    service: 'msg',
    cmd: 'searchHistoryMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  '7_9': { service: 'msg', cmd: 'deleteSessions' },
  '7_10': {
    service: 'msg',
    cmd: 'getSessions',
    response: [{ type: 'StrArray', name: 'sessions' }]
  },
  // 发送消息后发送方的多端同步通知
  '7_101': {
    service: 'msg',
    cmd: 'syncSendMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  '7_11': {
    service: 'msg',
    cmd: 'sendMsgReceipt',
    response: [{ type: 'Property', name: 'msgReceipt' }]
  },
  '7_12': {
    service: 'msg',
    cmd: 'msgReceipt',
    response: [{ type: 'Property', name: 'msgReceipt' }]
  },
  '7_13': { service: 'msg', cmd: 'onDeleteMsg' },
  '7_14': {
    service: 'msg',
    cmd: 'onMsgDeleted',
    response: [{ type: 'Property', name: 'sysMsg' }]
  },
  '7_15': {
    service: 'msg',
    cmd: 'onDeleteMsgOfflineRoaming',
    response: [{ type: 'PropertyArray', name: 'sysMsgs', entity: 'sysMsg' }, { type: 'Number', name: 'timetag' }, { type: 'Number', name: 'type' }]
  },
  '7_16': { service: 'msg', cmd: 'onMarkSessionAck' },
  '7_17': {
    service: 'msg',
    cmd: 'broadcastMsg',
    response: [{ type: 'Property', name: 'broadcastMsg' }]
  },
  '7_18': {
    service: 'msg',
    cmd: 'clearServerHistoryMsgs'
  },
  '7_116': {
    service: 'msg',
    cmd: 'syncMarkSessionAck',
    response: [{ type: 'Number', name: 'scene' }, { type: 'String', name: 'to' }, { type: 'Number', name: 'timetag' }]
  },
  // 发送超大群消息
  '21_2': {
    service: 'superTeam',
    cmd: 'sendSuperTeamMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 超大群消息通知
  '21_3': {
    service: 'superTeam',
    cmd: 'superTeamMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 拉人入超大群
  '21_5': {
    service: 'superTeam',
    cmd: 'addSuperTeamMembers',
    response: [{ type: 'StrArray', name: 'abortedAccidList' }, { type: 'long', name: 'timetag' }]
  },
  // 踢人出超大群
  '21_6': { service: 'superTeam', cmd: 'removeSuperTeamMembers' },
  // 退出超大群
  '21_7': { service: 'superTeam', cmd: 'leaveSuperTeam' },
  // 更新超大群
  '21_8': {
    service: 'superTeam',
    cmd: 'updateSuperTeam',
    response: [{ type: 'long', name: 'teamId' }, { type: 'long', name: 'timetag' }]
  },
  // 获取超大群
  '21_9': {
    service: 'superTeam',
    cmd: 'getSuperTeam',
    response: [{ type: 'Property', name: 'team' }]
  },
  // 获取(同步)群列表
  '21_12': {
    service: 'superTeam',
    cmd: 'getSuperTeams',
    response: [{ type: 'PropertyArray', name: 'teams', entity: 'superTeam' }, { type: 'bool', name: 'isAll' }, // 是否为全量数据
    { type: 'long', name: 'timetag' }]
  },
  // 修改个人群成员信息
  '21_10': { service: 'superTeam', cmd: 'updateInfoInSuperTeam' },
  // 获取超大群成员
  '21_13': {
    service: 'superTeam',
    cmd: 'getSuperTeamMembers',
    response: [{ type: 'long', name: 'teamId' }, { type: 'PropertyArray', name: 'members', entity: 'superTeamMember' }, { type: 'bool', name: 'isAll' }, // 是否为全量数据
    { type: 'long', name: 'timetag' }]
  },
  '21_11': {
    service: 'superTeam',
    cmd: 'getMySuperTeamMembers',
    response: [{ type: 'PropertyArray', name: 'members', entity: 'superTeamMember' }]
  },
  '21_14': {
    service: 'superTeam',
    cmd: 'getSuperTeamHistoryMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 同步超大群成员通知
  '21_113': {
    service: 'superTeam',
    cmd: 'syncSuperTeamMembers',
    response: [{ type: 'Number', name: 'teamId' }, { type: 'PropertyArray', name: 'members', entity: 'superTeamMember' }, { type: 'bool', name: 'isAll' }, { type: 'long', name: 'timetag' }]
  },
  // 同步所在群的个人群成员信息
  '21_111': {
    service: 'superTeam',
    cmd: 'syncMySuperTeamMembers',
    response: [{ type: 'PropertyArray', name: 'teamMembers', entity: 'superTeamMember' }, { type: 'long', name: 'timetag' }]
  },
  // 同步超大群列表通知
  '21_109': {
    service: 'superTeam',
    cmd: 'syncSuperTeams',
    response: [{ type: 'PropertyArray', name: 'teams', entity: 'superTeam' }, { type: 'bool', name: 'isAll' }, { type: 'long', name: 'timetag' }]
  },
  // 同步创建超大群通知
  '21_101': {
    service: 'superTeam',
    cmd: 'syncCreateSuperTeam',
    response: [{ type: 'Property', name: 'team' }]
  },
  // 多端同步发送超大群消息通知
  '21_102': {
    service: 'superTeam',
    cmd: 'syncSendSuperTeamMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 多端同步更新超大群成员
  '21_110': {
    service: 'superTeam',
    cmd: 'syncUpdateSuperTeamMember',
    response: [{ type: 'Property', name: 'teamMember', entity: 'superTeamMember' }]
  },
  // 创建群
  '8_1': {
    service: 'team',
    cmd: 'createTeam',
    response: [{ type: 'Property', name: 'team' }, { type: 'StrArray', name: 'abortedAccidList' }]
  },
  // 发送群消息
  '8_2': {
    service: 'team',
    cmd: 'sendTeamMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 群消息通知
  '8_3': {
    service: 'team',
    cmd: 'teamMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 群消息列表通知
  '8_4': {
    service: 'team',
    cmd: 'teamMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 拉人入群
  '8_5': {
    service: 'team',
    cmd: 'addTeamMembers',
    response: [{ type: 'long', name: 'time' }, { type: 'StrArray', name: 'abortedAccidList' }]
  },
  // 踢人出群
  '8_6': { service: 'team', cmd: 'removeTeamMembers' },
  // 更新群
  '8_7': {
    service: 'team',
    cmd: 'updateTeam',
    response: [{ type: 'Number', name: 'id' }, { type: 'Number', name: 'time' }]
  },
  // 退出群
  '8_8': { service: 'team', cmd: 'leaveTeam' },
  // 获取群
  '8_9': {
    service: 'team',
    cmd: 'getTeam',
    response: [{ type: 'Property', name: 'team' }]
  },
  // 获取群列表
  '8_10': {
    service: 'team',
    cmd: 'getTeams',
    response: [{ type: 'PropertyArray', name: 'teams', entity: 'team' }, { type: 'Number', name: 'timetag' }]
  },
  // 获取群成员
  '8_11': {
    service: 'team',
    cmd: 'getTeamMembers',
    response: [{ type: 'Number', name: 'teamId' }, { type: 'PropertyArray', name: 'members', entity: 'teamMember' }, { type: 'Number', name: 'timetag' }]
  },
  // 解散群
  '8_12': { service: 'team', cmd: 'dismissTeam' },
  // 申请入群
  '8_13': {
    service: 'team',
    cmd: 'applyTeam',
    response: [{ type: 'Property', name: 'team' }]
  },
  // 同意入群申请
  '8_14': { service: 'team', cmd: 'passTeamApply' },
  // 拒绝入群申请
  '8_15': { service: 'team', cmd: 'rejectTeamApply' },
  // 添加群管理员
  '8_16': { service: 'team', cmd: 'addTeamManagers' },
  // 移除群管理员
  '8_17': { service: 'team', cmd: 'removeTeamManagers' },
  // 转让群
  '8_18': { service: 'team', cmd: 'transferTeam' },
  // 修改自己的群资料
  '8_19': { service: 'team', cmd: 'updateInfoInTeam' },
  // 修改别人的群昵称
  '8_20': { service: 'team', cmd: 'updateNickInTeam' },
  // 接受入群邀请
  '8_21': {
    service: 'team',
    cmd: 'acceptTeamInvite',
    response: [{ type: 'Property', name: 'team' }]
  },
  // 拒绝入群邀请
  '8_22': { service: 'team', cmd: 'rejectTeamInvite' },
  // 获取群组历史消息
  '8_23': {
    service: 'team',
    cmd: 'getTeamHistoryMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  // 获取包含关键词的群组历史消息
  '8_24': {
    service: 'team',
    cmd: 'searchTeamHistoryMsgs',
    response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }]
  },
  '8_25': { service: 'team', cmd: 'updateMuteStateInTeam' },
  '8_26': {
    service: 'team',
    cmd: 'getMyTeamMembers',
    response: [{ type: 'PropertyArray', name: 'teamMembers', entity: 'teamMember' }]
  },
  '8_27': {
    service: 'team',
    cmd: 'getMutedTeamMembers',
    response: [{ type: 'Number', name: 'teamId' }, { type: 'PropertyArray', name: 'teamMembers', entity: 'teamMember' }]
  },
  '8_28': {
    service: 'team',
    cmd: 'sendTeamMsgReceipt',
    response: [{
      type: 'PropertyArray',
      name: 'teamMsgReceipts',
      entity: 'teamMsgReceipt'
    }]
  },
  '8_29': {
    service: 'team',
    cmd: 'getTeamMsgReads',
    response: [{
      type: 'PropertyArray',
      name: 'teamMsgReceipts',
      entity: 'teamMsgReceipt'
    }]
  },
  '8_30': {
    service: 'team',
    cmd: 'getTeamMsgReadAccounts',
    response: [{ type: 'String', name: 'idClient' }, { type: 'StrArray', name: 'readAccounts' }, { type: 'StrArray', name: 'unreadAccounts' }]
  },
  '8_31': {
    service: 'team',
    cmd: 'notifyTeamMsgReads',
    response: [{
      type: 'PropertyArray',
      name: 'teamMsgReceipts',
      entity: 'teamMsgReceipt'
    }]
  },
  '8_32': {
    service: 'team',
    cmd: 'muteTeamAll',
    response: []
  },
  // 获取群成员的邀请者accid
  '8_33': {
    service: 'team',
    cmd: 'getTeamMemberInvitorAccid',
    response: [{ type: 'object', name: 'accountsMap' }]
  },
  '8_126': {
    service: 'team',
    cmd: 'syncMyTeamMembers',
    response: [{ type: 'PropertyArray', name: 'teamMembers', entity: 'teamMember' }, { type: 'Number', name: 'timetag' }]
  },
  // 同步群列表通知
  '8_109': {
    service: 'team',
    cmd: 'syncTeams',
    response: [{ type: 'Number', name: 'timetag' }, { type: 'PropertyArray', name: 'teams', entity: 'team' }]
  },
  // 同步群成员通知
  '8_111': {
    service: 'team',
    cmd: 'syncTeamMembers',
    response: [{ type: 'Number', name: 'teamId' }, { type: 'PropertyArray', name: 'members', entity: 'teamMember' }, { type: 'Number', name: 'timetag' }]
  },
  // 多端同步创建群通知
  '8_101': {
    service: 'team',
    cmd: 'syncCreateTeam',
    response: [{ type: 'Property', name: 'team' }]
  },
  // 多端同步发送群消息通知
  '8_102': {
    service: 'team',
    cmd: 'syncSendTeamMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 多端同步更新群成员通知
  '8_119': {
    service: 'team',
    cmd: 'syncUpdateTeamMember',
    response: [{ type: 'Property', name: 'teamMember' }]
  },

  // 添加好友
  '12_1': { service: 'friend', cmd: 'friendRequest' },
  // 添加好友多端同步
  '12_101': {
    service: 'friend',
    cmd: 'syncFriendRequest',
    response: [{ type: 'String', name: 'account' }, { type: 'Number', name: 'type' }, { type: 'String', name: 'ps' }]
  },
  // 删除好友
  '12_2': { service: 'friend', cmd: 'deleteFriend' },
  // 删除好友多端同步
  '12_102': {
    service: 'friend',
    cmd: 'syncDeleteFriend',
    response: [{ type: 'String', name: 'account' }]
  },
  // 更新好友
  '12_3': { service: 'friend', cmd: 'updateFriend' },
  // 更新好友多端同步
  '12_103': {
    service: 'friend',
    cmd: 'syncUpdateFriend',
    response: [{ type: 'Property', name: 'friend' }]
  },
  // 获取好友列表
  '12_4': {
    service: 'friend',
    cmd: 'getFriends',
    response: [{ type: 'PropertyArray', name: 'friends', entity: 'friend' }, { type: 'Number', name: 'timetag' }]
  },
  // 同步好友列表
  '12_5': {
    service: 'friend',
    cmd: 'syncFriends',
    response: [{ type: 'PropertyArray', name: 'friends', entity: 'friend' }, { type: 'Number', name: 'timetag' }]
  },
  '12_6': {
    service: 'friend',
    cmd: 'syncFriendUsers',
    response: [{ type: 'PropertyArray', name: 'users', entity: 'user' }, { type: 'Number', name: 'timetag' }]
  },

  '13_1': {
    service: 'chatroom',
    cmd: 'getChatroomAddress',
    response: [{ type: 'StrArray', name: 'address' }]
  },
  '14_1': {
    service: 'eventService',
    cmd: 'publishEvent',
    response: [{ type: 'Property', name: 'msgEvent' }]
  },
  '14_2': {
    service: 'eventService',
    cmd: 'pushEvent',
    response: [{ type: 'Property', name: 'msgEvent' }]
  },
  '14_3': {
    service: 'eventService',
    cmd: 'subscribeEvent',
    response: [{ type: 'StrArray', name: 'accounts' }]
  },
  '14_4': {
    service: 'eventService',
    cmd: 'unSubscribeEventsByAccounts',
    response: [{ type: 'StrArray', name: 'accounts' }]
  },
  '14_5': {
    service: 'eventService',
    cmd: 'unSubscribeEventsByType'
  },
  '14_6': {
    service: 'eventService',
    cmd: 'querySubscribeEventsByAccounts',
    response: [{
      type: 'PropertyArray',
      name: 'msgEventSubscribes',
      entity: 'msgEventSubscribe'
    }]
  },
  '14_7': {
    service: 'eventService',
    cmd: 'querySubscribeEventsByType',
    response: [{
      type: 'PropertyArray',
      name: 'msgEventSubscribes',
      entity: 'msgEventSubscribe'
    }]
  },
  '14_9': {
    service: 'eventService',
    cmd: 'pushEvents',
    response: [{ type: 'PropertyArray', name: 'msgEvents', entity: 'msgEvent' }]
  },
  // 发送过滤消息
  '101_1': {
    service: 'filter',
    cmd: 'sendFilterMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 过滤消息通知
  '101_2': {
    service: 'filter',
    cmd: 'filterMsg',
    response: [{ type: 'Property', name: 'msg' }]
  },
  // 过滤系统通知通知
  '101_3': {
    service: 'filter',
    cmd: 'filterSysMsg',
    response: [{ type: 'Property', name: 'sysMsg' }]
  },
  // 发送过滤自定义系统通知
  '101_7': { service: 'filter', cmd: 'sendFilterCustomSysMsg' }
});

module.exports = {
  idMap: idMap,
  cmdConfig: cmdConfig,
  packetConfig: packetConfig
};

/***/ }),

/***/ "./src/im/protocol/map/serializeMapChatroom.js":
/*!*****************************************************!*\
  !*** ./src/im/protocol/map/serializeMapChatroom.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  "imLogin": {
    "clientType": 3,
    "os": 4,
    "sdkVersion": 6,
    "appLogin": 8,
    "protocolVersion": 9,
    "pushTokenName": 10,
    "pushToken": 11,
    "deviceId": 13,
    "appKey": 18,
    "account": 19,
    "browser": 24,
    "session": 26,
    "deviceInfo": 32,
    "isReactNative": 112,
    "token": 1000,
    "customTag": 38
  },
  "nosToken": {
    "objectName": 1,
    "token": 2,
    "bucket": 3,
    "expireTime": 4,
    "expireSec": 7,
    "tag": 8,
    "shortUrl": 9
  },
  "audioToText": {
    "url": 2
  },
  "imageOp": {
    "type": 0,
    "stripmeta": 1,
    "typeType": 2,
    "blurRadius": 3,
    "blurSigma": 4,
    "qualityQuality": 5,
    "cropX": 6,
    "cropY": 7,
    "cropWidth": 8,
    "cropHeight": 9,
    "rotateAngle": 10,
    "pixelPixel": 11,
    "thumbnailMode": 12,
    "thumbnailWidth": 13,
    "thumbnailHeight": 14,
    "thumbnailAxisX": 15,
    "thumbnailAxisY": 16,
    "thumbnailCenterX": 17,
    "thumbnailCenterY": 18,
    "thumbnailEnlarge": 19,
    "thumbnailToStatic": 20,
    "watermarkType": 21,
    "watermarkGravity": 22,
    "watermarkDissolve": 23,
    "watermarkDx": 24,
    "watermarkDy": 25,
    "watermarkImage": 26,
    "watermarkText": 27,
    "watermarkFont": 28,
    "watermarkFontSize": 29,
    "watermarkFontColor": 30,
    "interlace": 31
  },
  "robot": {
    "account": 4,
    "nick": 5,
    "avatar": 6,
    "intro": 7,
    "config": 8,
    "valid": 9,
    "createTime": 10,
    "updateTime": 11,
    "custid": 12,
    "botid": 13,
    "bindTime": 14
  },
  "clientAntispam": {
    "version": 1,
    "md5": 2,
    "nosurl": 3,
    "thesaurus": 4
  },
  "fileQuickTransfer": {
    "md5": 1,
    "url": 2,
    "size": 3,
    "threshold": 4
  },
  "transToken": {
    "name": 1,
    "type": 2,
    "transType": 3,
    "size": 4,
    "extra": 5,
    "body": 6
  },
  "transInfo": {
    "docId": 1,
    "name": 2,
    "prefix": 3,
    "size": 4,
    "type": 5,
    "state": 6,
    "transType": 7,
    "transSize": 8,
    "pageCount": 9,
    "picInfo": 10,
    "extra": 11,
    "flag": 12
  },
  "nosFileUrlTag": {
    "safeUrl": 0,
    "originUrl": 1
  },
  "fileListParam": {
    "fromDocId": 1,
    "limit": 2
  },
  "avSignalTag": {
    "type": 1,
    "channelName": 2,
    "channelId": 3,
    "channelCreateTime": 4,
    "channelExpireTime": 5,
    "creator": 6,
    "ext": 7,
    "channelInValid": 8,
    "from": 10,
    "to": 11,
    "requestId": 12,
    "needPush": 13,
    "pushTitle": 14,
    "pushContent": 15,
    "pushPayload": 16,
    "needBadge": 17,
    "members": 18,
    "attach": 19,
    "attachExt": 20,
    "isSave": 21,
    "msgid": 22,
    "uid": 23,
    "time": 24
  },
  "login": {
    "appKey": 1,
    "account": 2,
    "deviceId": 3,
    "chatroomId": 5,
    "appLogin": 8,
    "chatroomNick": 20,
    "chatroomAvatar": 21,
    "chatroomCustom": 22,
    "chatroomEnterCustom": 23,
    "session": 26,
    "isAnonymous": 38
  },
  "chatroom": {
    "id": 1,
    "name": 3,
    "announcement": 4,
    "broadcastUrl": 5,
    "custom": 12,
    "createTime": 14,
    "updateTime": 15,
    "queuelevel": 16,
    "creator": 100,
    "onlineMemberNum": 101,
    "mute": 102
  },
  "msg": {
    "idClient": 1,
    "type": 2,
    "attach": 3,
    "custom": 4,
    "resend": 5,
    "userUpdateTime": 6,
    "fromNick": 7,
    "fromAvatar": 8,
    "fromCustom": 9,
    "yidunEnable": 10,
    "antiSpamContent": 11,
    "skipHistory": 12,
    "body": 13,
    "antiSpamBusinessId": 14,
    "clientAntiSpam": 15,
    "antiSpamUsingYidun": 16,
    "time": 20,
    "from": 21,
    "chatroomId": 22,
    "fromClientType": 23,
    "highPriority": 25
  },
  "chatroomMember": {
    "chatroomId": 1,
    "account": 2,
    "type": 3,
    "level": 4,
    "nick": 5,
    "avatar": 6,
    "custom": 7,
    "online": 8,
    "guest": 9,
    "enterTime": 10,
    "blacked": 12,
    "gaged": 13,
    "valid": 14,
    "updateTime": 15,
    "tempMuted": 16,
    "tempMuteDuration": 17
  }
};

/***/ }),

/***/ "./src/im/protocol/map/serializeMapIM.js":
/*!***********************************************!*\
  !*** ./src/im/protocol/map/serializeMapIM.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  "nosToken": {
    "objectName": 1,
    "token": 2,
    "bucket": 3,
    "expireTime": 4,
    "expireSec": 7,
    "tag": 8,
    "shortUrl": 9
  },
  "audioToText": {
    "url": 2
  },
  "imageOp": {
    "type": 0,
    "stripmeta": 1,
    "typeType": 2,
    "blurRadius": 3,
    "blurSigma": 4,
    "qualityQuality": 5,
    "cropX": 6,
    "cropY": 7,
    "cropWidth": 8,
    "cropHeight": 9,
    "rotateAngle": 10,
    "pixelPixel": 11,
    "thumbnailMode": 12,
    "thumbnailWidth": 13,
    "thumbnailHeight": 14,
    "thumbnailAxisX": 15,
    "thumbnailAxisY": 16,
    "thumbnailCenterX": 17,
    "thumbnailCenterY": 18,
    "thumbnailEnlarge": 19,
    "thumbnailToStatic": 20,
    "watermarkType": 21,
    "watermarkGravity": 22,
    "watermarkDissolve": 23,
    "watermarkDx": 24,
    "watermarkDy": 25,
    "watermarkImage": 26,
    "watermarkText": 27,
    "watermarkFont": 28,
    "watermarkFontSize": 29,
    "watermarkFontColor": 30,
    "interlace": 31
  },
  "robot": {
    "account": 4,
    "nick": 5,
    "avatar": 6,
    "intro": 7,
    "config": 8,
    "valid": 9,
    "createTime": 10,
    "updateTime": 11,
    "custid": 12,
    "botid": 13,
    "bindTime": 14
  },
  "clientAntispam": {
    "version": 1,
    "md5": 2,
    "nosurl": 3,
    "thesaurus": 4
  },
  "fileQuickTransfer": {
    "md5": 1,
    "url": 2,
    "size": 3,
    "threshold": 4
  },
  "transToken": {
    "name": 1,
    "type": 2,
    "transType": 3,
    "size": 4,
    "extra": 5,
    "body": 6
  },
  "transInfo": {
    "docId": 1,
    "name": 2,
    "prefix": 3,
    "size": 4,
    "type": 5,
    "state": 6,
    "transType": 7,
    "transSize": 8,
    "pageCount": 9,
    "picInfo": 10,
    "extra": 11,
    "flag": 12
  },
  "nosFileUrlTag": {
    "safeUrl": 0,
    "originUrl": 1
  },
  "fileListParam": {
    "fromDocId": 1,
    "limit": 2
  },
  "avSignalTag": {
    "type": 1,
    "channelName": 2,
    "channelId": 3,
    "channelCreateTime": 4,
    "channelExpireTime": 5,
    "creator": 6,
    "ext": 7,
    "channelInValid": 8,
    "from": 10,
    "to": 11,
    "requestId": 12,
    "needPush": 13,
    "pushTitle": 14,
    "pushContent": 15,
    "pushPayload": 16,
    "needBadge": 17,
    "members": 18,
    "attach": 19,
    "attachExt": 20,
    "isSave": 21,
    "msgid": 22,
    "uid": 23,
    "time": 24
  },
  "login": {
    "clientType": 3,
    "os": 4,
    "sdkVersion": 6,
    "appLogin": 8,
    "protocolVersion": 9,
    "pushTokenName": 10,
    "pushToken": 11,
    "deviceId": 13,
    "appKey": 18,
    "account": 19,
    "browser": 24,
    "session": 26,
    "deviceInfo": 32,
    "isReactNative": 112,
    "token": 1000,
    "customTag": 38
  },
  "loginRes": {
    "lastLoginDeviceId": 17,
    "customTag": 38,
    "connectionId": 102,
    "ip": 103,
    "port": 104,
    "country": 106,
    "hasXMPush": 111
  },
  "loginPort": {
    "type": 3,
    "os": 4,
    "mac": 5,
    "deviceId": 13,
    "account": 19,
    "deviceInfo": 32,
    "connectionId": 102,
    "ip": 103,
    "time": 109,
    "customTag": 38
  },
  "aosPushInfo": {
    "pushType": 110,
    "hasTokenPreviously": 111
  },
  "sync": {
    "myInfo": 1,
    "offlineMsgs": 2,
    "teams": 3,
    "netcallMsgs": 6,
    "roamingMsgs": 7,
    "relations": 9,
    "friends": 11,
    "sessions": 12,
    "friendUsers": 13,
    "msgReceipts": 14,
    "myTeamMembers": 15,
    "donnop": 16,
    "deleteMsg": 17,
    "sessionAck": 18,
    "robots": 19,
    "broadcastMsgs": 20,
    "avSignal": 21,
    "superTeams": 22,
    "myInfoInSuperTeams": 23,
    "superTeamRoamingMsgs": 24,
    "filterMsgs": 100
  },
  "donnop": {
    "open": 1
  },
  "superTeam": {
    "teamId": 1,
    "name": 3,
    "type": 4,
    "owner": 5,
    "level": 6,
    "selfCustom": 7,
    "valid": 8,
    "memberNum": 9,
    "memberUpdateTime": 10,
    "createTime": 11,
    "updateTime": 12,
    "validToCurrentUser": 13,
    "intro": 14,
    "announcement": 15,
    "joinMode": 16,
    "bits": 17,
    "custom": 18,
    "serverCustom": 19,
    "avatar": 20,
    "beInviteMode": 21,
    "inviteMode": 22,
    "updateTeamMode": 23,
    "updateCustomMode": 24,
    "mute": 100,
    "muteType": 101
  },
  "superTeamMember": {
    "teamId": 1,
    "account": 3,
    "type": 4,
    "nickInTeam": 5,
    "bits": 7,
    "active": 8,
    "valid": 9,
    "joinTime": 10,
    "updateTime": 11,
    "custom": 12,
    "mute": 13
  },
  "team": {
    "teamId": 1,
    "name": 3,
    "type": 4,
    "owner": 5,
    "level": 6,
    "selfCustom": 7,
    "valid": 8,
    "memberNum": 9,
    "memberUpdateTime": 10,
    "createTime": 11,
    "updateTime": 12,
    "validToCurrentUser": 13,
    "intro": 14,
    "announcement": 15,
    "joinMode": 16,
    "bits": 17,
    "custom": 18,
    "serverCustom": 19,
    "avatar": 20,
    "beInviteMode": 21,
    "inviteMode": 22,
    "updateTeamMode": 23,
    "updateCustomMode": 24,
    "mute": 100,
    "muteType": 101
  },
  "teamMember": {
    "teamId": 1,
    "account": 3,
    "type": 4,
    "nickInTeam": 5,
    "bits": 7,
    "active": 8,
    "valid": 9,
    "joinTime": 10,
    "updateTime": 11,
    "custom": 12,
    "mute": 13,
    "invitorAccid": 14
  },
  "msg": {
    "scene": 0,
    "to": 1,
    "from": 2,
    "fromClientType": 4,
    "fromDeviceId": 5,
    "fromNick": 6,
    "time": 7,
    "type": 8,
    "body": 9,
    "attach": 10,
    "idClient": 11,
    "idServer": 12,
    "resend": 13,
    "userUpdateTime": 14,
    "custom": 15,
    "pushPayload": 16,
    "pushContent": 17,
    "apnsAccounts": 18,
    "apnsContent": 19,
    "apnsForcePush": 20,
    "yidunEnable": 21,
    "antiSpamContent": 22,
    "antiSpamBusinessId": 23,
    "clientAntiSpam": 24,
    "antiSpamUsingYidun": 25,
    "needMsgReceipt": 26,
    "isHistoryable": 100,
    "isRoamingable": 101,
    "isSyncable": 102,
    "isMuted": 104,
    "cc": 105,
    "isInBlackList": 106,
    "isPushable": 107,
    "isOfflinable": 108,
    "isUnreadable": 109,
    "needPushNick": 110,
    "isReplyMsg": 111,
    "tempTeamMemberCount": 112
  },
  "msgReceipt": {
    "to": 1,
    "from": 2,
    "time": 7,
    "idClient": 11
  },
  "teamMsgReceipt": {
    "teamId": 0,
    "idServer": 1,
    "read": 100,
    "unread": 101,
    "idClient": 102,
    "account": 103
  },
  "sysMsg": {
    "time": 0,
    "type": 1,
    "to": 2,
    "from": 3,
    "ps": 4,
    "attach": 5,
    "idServer": 6,
    "sendToOnlineUsersOnly": 7,
    "apnsText": 8,
    "pushPayload": 9,
    "deletedIdClient": 10,
    "deletedIdServer": 11,
    "yidunEnable": 12,
    "antiSpamContent": 13,
    "deletedMsgTime": 14,
    "deletedMsgFromNick": 15,
    "opeAccount": 16,
    "cc": 105,
    "isPushable": 107,
    "isUnreadable": 109,
    "needPushNick": 110
  },
  "broadcastMsg": {
    "broadcastId": 1,
    "fromAccid": 2,
    "fromUid": 3,
    "timestamp": 4,
    "body": 5
  },
  "friend": {
    "account": 4,
    "flag": 5,
    "beflag": 6,
    "source": 7,
    "alias": 8,
    "bits": 9,
    "custom": 10,
    "createTime": 11,
    "updateTime": 12,
    "serverex": 13
  },
  "user": {
    "account": 1,
    "nick": 3,
    "avatar": 4,
    "sign": 5,
    "gender": 6,
    "email": 7,
    "birth": 8,
    "tel": 9,
    "custom": 10,
    "createTime": 12,
    "updateTime": 13
  },
  "specialRelation": {
    "account": 0,
    "isMuted": 1,
    "isBlacked": 2,
    "createTime": 3,
    "updateTime": 4
  },
  "msgType": {
    "text": 0,
    "picture": 1,
    "audio": 2,
    "video": 3,
    "location": 4,
    "notification": 5,
    "file": 6,
    "netcall_audio": 7,
    "netcall_vedio": 8,
    "datatunnel_new": 9,
    "tips": 10,
    "robot": 11,
    "custom": 100
  },
  "msgEvent": {
    "type": 1,
    "value": 2,
    "idClient": 3,
    "custom": 4,
    "validTime": 5,
    "broadcastType": 6,
    "sync": 7,
    "validTimeType": 8,
    "durable": 9,
    "time": 10,
    "idServer": 11,
    "clientType": 12,
    "serverConfig": 13,
    "serverCustom": 14,
    "appid": 101,
    "account": 103,
    "enableMultiClient": 104,
    "consid": 106
  },
  "msgEventSubscribe": {
    "type": 1,
    "subscribeTime": 2,
    "sync": 3,
    "to": 102,
    "from": 104,
    "time": 105
  },
  "clearMsgsParams": {
    "account": 1,
    "delRoam": 2
  },
  "delFriendParams": {
    "delAlias": 1
  }
};

/***/ }),

/***/ "./src/im/protocol/map/unserializeMapChatroom.js":
/*!*******************************************************!*\
  !*** ./src/im/protocol/map/unserializeMapChatroom.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  "imLogin": {
    "3": "clientType",
    "4": "os",
    "6": "sdkVersion",
    "8": "appLogin",
    "9": "protocolVersion",
    "10": "pushTokenName",
    "11": "pushToken",
    "13": "deviceId",
    "18": "appKey",
    "19": "account",
    "24": "browser",
    "26": "session",
    "32": "deviceInfo",
    "38": "customTag",
    "112": "isReactNative",
    "1000": "token"
  },
  "nosToken": {
    "1": "objectName",
    "2": "token",
    "3": "bucket",
    "4": "expireTime",
    "7": "expireSec",
    "8": "tag",
    "9": "shortUrl"
  },
  "audioToText": {
    "2": "url"
  },
  "imageOp": {
    "0": "type",
    "1": "stripmeta",
    "2": "typeType",
    "3": "blurRadius",
    "4": "blurSigma",
    "5": "qualityQuality",
    "6": "cropX",
    "7": "cropY",
    "8": "cropWidth",
    "9": "cropHeight",
    "10": "rotateAngle",
    "11": "pixelPixel",
    "12": "thumbnailMode",
    "13": "thumbnailWidth",
    "14": "thumbnailHeight",
    "15": "thumbnailAxisX",
    "16": "thumbnailAxisY",
    "17": "thumbnailCenterX",
    "18": "thumbnailCenterY",
    "19": "thumbnailEnlarge",
    "20": "thumbnailToStatic",
    "21": "watermarkType",
    "22": "watermarkGravity",
    "23": "watermarkDissolve",
    "24": "watermarkDx",
    "25": "watermarkDy",
    "26": "watermarkImage",
    "27": "watermarkText",
    "28": "watermarkFont",
    "29": "watermarkFontSize",
    "30": "watermarkFontColor",
    "31": "interlace"
  },
  "robot": {
    "4": "account",
    "5": "nick",
    "6": "avatar",
    "7": "intro",
    "8": "config",
    "9": "valid",
    "10": "createTime",
    "11": "updateTime",
    "12": "custid",
    "13": "botid",
    "14": "bindTime",
    "_6_safe": "_avatar_safe"
  },
  "clientAntispam": {
    "1": "version",
    "2": "md5",
    "3": "nosurl",
    "4": "thesaurus"
  },
  "fileQuickTransfer": {
    "1": "md5",
    "2": "url",
    "3": "size",
    "4": "threshold",
    "_2_safe": "_url_safe"
  },
  "transToken": {
    "1": "name",
    "2": "type",
    "3": "transType",
    "4": "size",
    "5": "extra",
    "6": "body"
  },
  "transInfo": {
    "1": "docId",
    "2": "name",
    "3": "prefix",
    "4": "size",
    "5": "type",
    "6": "state",
    "7": "transType",
    "8": "transSize",
    "9": "pageCount",
    "10": "picInfo",
    "11": "extra",
    "12": "flag"
  },
  "nosFileUrlTag": {
    "0": "safeUrl",
    "1": "originUrl"
  },
  "fileListParam": {
    "1": "fromDocId",
    "2": "limit"
  },
  "avSignalTag": {
    "1": "type",
    "2": "channelName",
    "3": "channelId",
    "4": "channelCreateTime",
    "5": "channelExpireTime",
    "6": "creator",
    "7": "ext",
    "8": "channelInValid",
    "10": "from",
    "11": "to",
    "12": "requestId",
    "13": "needPush",
    "14": "pushTitle",
    "15": "pushContent",
    "16": "pushPayload",
    "17": "needBadge",
    "18": "members",
    "19": "attach",
    "20": "attachExt",
    "21": "isSave",
    "22": "msgid",
    "23": "uid",
    "24": "time"
  },
  "login": {
    "1": "appKey",
    "2": "account",
    "3": "deviceId",
    "5": "chatroomId",
    "8": "appLogin",
    "20": "chatroomNick",
    "21": "chatroomAvatar",
    "22": "chatroomCustom",
    "23": "chatroomEnterCustom",
    "26": "session",
    "38": "isAnonymous",
    "_21_safe": "_chatroomAvatar_safe"
  },
  "chatroom": {
    "1": "id",
    "3": "name",
    "4": "announcement",
    "5": "broadcastUrl",
    "12": "custom",
    "14": "createTime",
    "15": "updateTime",
    "16": "queuelevel",
    "100": "creator",
    "101": "onlineMemberNum",
    "102": "mute"
  },
  "msg": {
    "1": "idClient",
    "2": "type",
    "3": "attach",
    "4": "custom",
    "5": "resend",
    "6": "userUpdateTime",
    "7": "fromNick",
    "8": "fromAvatar",
    "9": "fromCustom",
    "10": "yidunEnable",
    "11": "antiSpamContent",
    "12": "skipHistory",
    "13": "body",
    "14": "antiSpamBusinessId",
    "15": "clientAntiSpam",
    "16": "antiSpamUsingYidun",
    "20": "time",
    "21": "from",
    "22": "chatroomId",
    "23": "fromClientType",
    "25": "highPriority",
    "_8_safe": "_fromAvatar_safe"
  },
  "chatroomMember": {
    "1": "chatroomId",
    "2": "account",
    "3": "type",
    "4": "level",
    "5": "nick",
    "6": "avatar",
    "7": "custom",
    "8": "online",
    "9": "guest",
    "10": "enterTime",
    "12": "blacked",
    "13": "gaged",
    "14": "valid",
    "15": "updateTime",
    "16": "tempMuted",
    "17": "tempMuteDuration",
    "_6_safe": "_avatar_safe"
  }
};

/***/ }),

/***/ "./src/im/protocol/map/unserializeMapIM.js":
/*!*************************************************!*\
  !*** ./src/im/protocol/map/unserializeMapIM.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  "nosToken": {
    "1": "objectName",
    "2": "token",
    "3": "bucket",
    "4": "expireTime",
    "7": "expireSec",
    "8": "tag",
    "9": "shortUrl"
  },
  "audioToText": {
    "2": "url"
  },
  "imageOp": {
    "0": "type",
    "1": "stripmeta",
    "2": "typeType",
    "3": "blurRadius",
    "4": "blurSigma",
    "5": "qualityQuality",
    "6": "cropX",
    "7": "cropY",
    "8": "cropWidth",
    "9": "cropHeight",
    "10": "rotateAngle",
    "11": "pixelPixel",
    "12": "thumbnailMode",
    "13": "thumbnailWidth",
    "14": "thumbnailHeight",
    "15": "thumbnailAxisX",
    "16": "thumbnailAxisY",
    "17": "thumbnailCenterX",
    "18": "thumbnailCenterY",
    "19": "thumbnailEnlarge",
    "20": "thumbnailToStatic",
    "21": "watermarkType",
    "22": "watermarkGravity",
    "23": "watermarkDissolve",
    "24": "watermarkDx",
    "25": "watermarkDy",
    "26": "watermarkImage",
    "27": "watermarkText",
    "28": "watermarkFont",
    "29": "watermarkFontSize",
    "30": "watermarkFontColor",
    "31": "interlace"
  },
  "robot": {
    "4": "account",
    "5": "nick",
    "6": "avatar",
    "7": "intro",
    "8": "config",
    "9": "valid",
    "10": "createTime",
    "11": "updateTime",
    "12": "custid",
    "13": "botid",
    "14": "bindTime",
    "_6_safe": "_avatar_safe"
  },
  "clientAntispam": {
    "1": "version",
    "2": "md5",
    "3": "nosurl",
    "4": "thesaurus"
  },
  "fileQuickTransfer": {
    "1": "md5",
    "2": "url",
    "3": "size",
    "4": "threshold",
    "_2_safe": "_url_safe"
  },
  "transToken": {
    "1": "name",
    "2": "type",
    "3": "transType",
    "4": "size",
    "5": "extra",
    "6": "body"
  },
  "transInfo": {
    "1": "docId",
    "2": "name",
    "3": "prefix",
    "4": "size",
    "5": "type",
    "6": "state",
    "7": "transType",
    "8": "transSize",
    "9": "pageCount",
    "10": "picInfo",
    "11": "extra",
    "12": "flag"
  },
  "nosFileUrlTag": {
    "0": "safeUrl",
    "1": "originUrl"
  },
  "fileListParam": {
    "1": "fromDocId",
    "2": "limit"
  },
  "avSignalTag": {
    "1": "type",
    "2": "channelName",
    "3": "channelId",
    "4": "channelCreateTime",
    "5": "channelExpireTime",
    "6": "creator",
    "7": "ext",
    "8": "channelInValid",
    "10": "from",
    "11": "to",
    "12": "requestId",
    "13": "needPush",
    "14": "pushTitle",
    "15": "pushContent",
    "16": "pushPayload",
    "17": "needBadge",
    "18": "members",
    "19": "attach",
    "20": "attachExt",
    "21": "isSave",
    "22": "msgid",
    "23": "uid",
    "24": "time"
  },
  "login": {
    "3": "clientType",
    "4": "os",
    "6": "sdkVersion",
    "8": "appLogin",
    "9": "protocolVersion",
    "10": "pushTokenName",
    "11": "pushToken",
    "13": "deviceId",
    "18": "appKey",
    "19": "account",
    "24": "browser",
    "26": "session",
    "32": "deviceInfo",
    "38": "customTag",
    "112": "isReactNative",
    "1000": "token"
  },
  "loginRes": {
    "17": "lastLoginDeviceId",
    "38": "customTag",
    "102": "connectionId",
    "103": "ip",
    "104": "port",
    "106": "country",
    "111": "hasXMPush"
  },
  "loginPort": {
    "3": "type",
    "4": "os",
    "5": "mac",
    "13": "deviceId",
    "19": "account",
    "32": "deviceInfo",
    "38": "customTag",
    "102": "connectionId",
    "103": "ip",
    "109": "time"
  },
  "aosPushInfo": {
    "110": "pushType",
    "111": "hasTokenPreviously"
  },
  "sync": {
    "1": "myInfo",
    "2": "offlineMsgs",
    "3": "teams",
    "6": "netcallMsgs",
    "7": "roamingMsgs",
    "9": "relations",
    "11": "friends",
    "12": "sessions",
    "13": "friendUsers",
    "14": "msgReceipts",
    "15": "myTeamMembers",
    "16": "donnop",
    "17": "deleteMsg",
    "18": "sessionAck",
    "19": "robots",
    "20": "broadcastMsgs",
    "21": "avSignal",
    "22": "superTeams",
    "23": "myInfoInSuperTeams",
    "24": "superTeamRoamingMsgs",
    "100": "filterMsgs"
  },
  "donnop": {
    "1": "open"
  },
  "superTeam": {
    "1": "teamId",
    "3": "name",
    "4": "type",
    "5": "owner",
    "6": "level",
    "7": "selfCustom",
    "8": "valid",
    "9": "memberNum",
    "10": "memberUpdateTime",
    "11": "createTime",
    "12": "updateTime",
    "13": "validToCurrentUser",
    "14": "intro",
    "15": "announcement",
    "16": "joinMode",
    "17": "bits",
    "18": "custom",
    "19": "serverCustom",
    "20": "avatar",
    "21": "beInviteMode",
    "22": "inviteMode",
    "23": "updateTeamMode",
    "24": "updateCustomMode",
    "100": "mute",
    "101": "muteType",
    "_20_safe": "_avatar_safe"
  },
  "superTeamMember": {
    "1": "teamId",
    "3": "account",
    "4": "type",
    "5": "nickInTeam",
    "7": "bits",
    "8": "active",
    "9": "valid",
    "10": "joinTime",
    "11": "updateTime",
    "12": "custom",
    "13": "mute"
  },
  "team": {
    "1": "teamId",
    "3": "name",
    "4": "type",
    "5": "owner",
    "6": "level",
    "7": "selfCustom",
    "8": "valid",
    "9": "memberNum",
    "10": "memberUpdateTime",
    "11": "createTime",
    "12": "updateTime",
    "13": "validToCurrentUser",
    "14": "intro",
    "15": "announcement",
    "16": "joinMode",
    "17": "bits",
    "18": "custom",
    "19": "serverCustom",
    "20": "avatar",
    "21": "beInviteMode",
    "22": "inviteMode",
    "23": "updateTeamMode",
    "24": "updateCustomMode",
    "100": "mute",
    "101": "muteType",
    "_20_safe": "_avatar_safe"
  },
  "teamMember": {
    "1": "teamId",
    "3": "account",
    "4": "type",
    "5": "nickInTeam",
    "7": "bits",
    "8": "active",
    "9": "valid",
    "10": "joinTime",
    "11": "updateTime",
    "12": "custom",
    "13": "mute",
    "14": "invitorAccid"
  },
  "msg": {
    "0": "scene",
    "1": "to",
    "2": "from",
    "4": "fromClientType",
    "5": "fromDeviceId",
    "6": "fromNick",
    "7": "time",
    "8": "type",
    "9": "body",
    "10": "attach",
    "11": "idClient",
    "12": "idServer",
    "13": "resend",
    "14": "userUpdateTime",
    "15": "custom",
    "16": "pushPayload",
    "17": "pushContent",
    "18": "apnsAccounts",
    "19": "apnsContent",
    "20": "apnsForcePush",
    "21": "yidunEnable",
    "22": "antiSpamContent",
    "23": "antiSpamBusinessId",
    "24": "clientAntiSpam",
    "25": "antiSpamUsingYidun",
    "26": "needMsgReceipt",
    "100": "isHistoryable",
    "101": "isRoamingable",
    "102": "isSyncable",
    "104": "isMuted",
    "105": "cc",
    "106": "isInBlackList",
    "107": "isPushable",
    "108": "isOfflinable",
    "109": "isUnreadable",
    "110": "needPushNick",
    "111": "isReplyMsg",
    "112": "tempTeamMemberCount"
  },
  "msgReceipt": {
    "1": "to",
    "2": "from",
    "7": "time",
    "11": "idClient"
  },
  "teamMsgReceipt": {
    "0": "teamId",
    "1": "idServer",
    "100": "read",
    "101": "unread",
    "102": "idClient",
    "103": "account"
  },
  "sysMsg": {
    "0": "time",
    "1": "type",
    "2": "to",
    "3": "from",
    "4": "ps",
    "5": "attach",
    "6": "idServer",
    "7": "sendToOnlineUsersOnly",
    "8": "apnsText",
    "9": "pushPayload",
    "10": "deletedIdClient",
    "11": "deletedIdServer",
    "12": "yidunEnable",
    "13": "antiSpamContent",
    "14": "deletedMsgTime",
    "15": "deletedMsgFromNick",
    "16": "opeAccount",
    "105": "cc",
    "107": "isPushable",
    "109": "isUnreadable",
    "110": "needPushNick"
  },
  "broadcastMsg": {
    "1": "broadcastId",
    "2": "fromAccid",
    "3": "fromUid",
    "4": "timestamp",
    "5": "body"
  },
  "friend": {
    "4": "account",
    "5": "flag",
    "6": "beflag",
    "7": "source",
    "8": "alias",
    "9": "bits",
    "10": "custom",
    "11": "createTime",
    "12": "updateTime",
    "13": "serverex"
  },
  "user": {
    "1": "account",
    "3": "nick",
    "4": "avatar",
    "5": "sign",
    "6": "gender",
    "7": "email",
    "8": "birth",
    "9": "tel",
    "10": "custom",
    "12": "createTime",
    "13": "updateTime",
    "_4_safe": "_avatar_safe"
  },
  "specialRelation": {
    "0": "account",
    "1": "isMuted",
    "2": "isBlacked",
    "3": "createTime",
    "4": "updateTime"
  },
  "msgType": {
    "0": "text",
    "1": "picture",
    "2": "audio",
    "3": "video",
    "4": "location",
    "5": "notification",
    "6": "file",
    "7": "netcall_audio",
    "8": "netcall_vedio",
    "9": "datatunnel_new",
    "10": "tips",
    "11": "robot",
    "100": "custom"
  },
  "msgEvent": {
    "1": "type",
    "2": "value",
    "3": "idClient",
    "4": "custom",
    "5": "validTime",
    "6": "broadcastType",
    "7": "sync",
    "8": "validTimeType",
    "9": "durable",
    "10": "time",
    "11": "idServer",
    "12": "clientType",
    "13": "serverConfig",
    "14": "serverCustom",
    "101": "appid",
    "103": "account",
    "104": "enableMultiClient",
    "106": "consid"
  },
  "msgEventSubscribe": {
    "1": "type",
    "2": "subscribeTime",
    "3": "sync",
    "102": "to",
    "104": "from",
    "105": "time"
  },
  "clearMsgsParams": {
    "1": "account",
    "2": "delRoam"
  },
  "delFriendParams": {
    "1": "delAlias"
  }
};

/***/ }),

/***/ "./src/im/protocol/parser/index.js":
/*!*****************************************!*\
  !*** ./src/im/protocol/parser/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _url = __webpack_require__(/*! utiljs/url */ "./src/util/url.js");

/* eslint-disable promise/param-names */
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");

var configMapIM = __webpack_require__(/*! ../map/configIM */ "./src/im/protocol/map/configIM.js");
var serializeMapIM = __webpack_require__(/*! ../map/serializeMapIM */ "./src/im/protocol/map/serializeMapIM.js");
var unserializeMapIM = __webpack_require__(/*! ../map/unserializeMapIM */ "./src/im/protocol/map/unserializeMapIM.js");

var configMapChatroom = __webpack_require__(/*! ../map/configChatroom */ "./src/im/protocol/map/configChatroom.js");
var serializeMapChatroom = __webpack_require__(/*! ../map/serializeMapChatroom */ "./src/im/protocol/map/serializeMapChatroom.js");
var unserializeMapChatroom = __webpack_require__(/*! ../map/unserializeMapChatroom */ "./src/im/protocol/map/unserializeMapChatroom.js");

function ParserMid() {}

function Parser(options) {
  this.mixin(options);
}

Parser.prototype = Object.create(ParserMid.prototype, {
  protocol: {
    value: null,
    writable: true,
    enumerable: true,
    configurable: true
  }
});

Parser.prototype.setProtocol = function (value) {
  this.protocol = value;
};

Parser.prototype.mixin = function (options) {
  var _this = this;

  this.configMap = this.configMap || {};['idMap', 'cmdConfig', 'packetConfig'].forEach(function (key) {
    _this.configMap[key] = util.merge({}, _this.configMap[key], options.configMap && options.configMap[key]);
  });['serializeMap', 'unserializeMap'].forEach(function (key) {
    _this[key] = util.merge({}, _this[key], options[key]);
  });
};

/**
 * 构造命令
 *
 * @param  {String} cmd     命令名称
 * @param  {Map}    content 命令内容
 * @return {Object}         命令对象
 */
Parser.prototype.createCmd = function () {
  // 发包序列号
  var serialId = 1;
  return function (cmd, content) {
    // console.log("构造命令，cmd:", cmd, "\r\ncontent: ", content);
    var self = this;
    var config = this.configMap.cmdConfig[cmd];
    // console.log("构造命令，config: ", config)
    var nowSerialId = cmd === 'heartbeat' ? 0 : serialId++;
    if (nowSerialId > 32767) {
      nowSerialId = 1;
      serialId = 2;
    }
    cmd = {
      SID: config.sid,
      CID: config.cid,
      SER: nowSerialId
      // 构造参数列表
    };if (config.params) {
      cmd.Q = [];
      config.params.forEach(function (param) {
        var type = param.type;
        var name = param.name;
        var entity = param.entity;
        var value = content[name];
        if (util.undef(value)) {
          return;
        }
        switch (type) {
          case 'PropertyArray':
            type = 'ArrayMable';
            value = value.map(function (item) {
              return {
                t: 'Property',
                v: self.serialize(item, entity)
              };
            });
            break;
          case 'Property':
            value = self.serialize(value, name);
            break;
          case 'bool':
            value = value ? 'true' : 'false';
            break;
          default:
            break;
        }
        cmd.Q.push({ t: type, v: value });
      });
    }
    return cmd;
  };
}();

/**
 * 解析包内容
 *
 * @param  {String} data 包数据
 * @return {Object}      解析后的包数据
 * @property {Object} raw       原始包数据
 * @property {Object} error     错误信息
 * @property {Object} content   包内容
 * @property {String} service   包的协议类型
 * @property {String} cmd       包的命令类型
 */
Parser.prototype.parseResponse = function (data) {
  var self = this;
  return new Promise(function (parseResolve, reject) {
    var raw = JSON.parse(data);
    var packet = {
      raw: raw,
      rawStr: data,
      error: NIMError.genError(raw.code)
      // 获取包配置和包内容
    };var config = self.configMap.packetConfig[raw.sid + '_' + raw.cid];
    if (!config) {
      packet.notFound = {
        sid: raw.sid,
        cid: raw.cid
      };
      parseResolve(packet);
      return;
    }
    var body = raw.r;
    // 如果是通知(4_1,4_2), 那么具体内容在内层包里面
    var isNotify = config.service === 'notify' && !config.cmd;
    packet.isNotify = isNotify;
    if (isNotify) {
      var innerPacket = raw.r[1].headerPacket;
      config = self.configMap.packetConfig[innerPacket.sid + '_' + innerPacket.cid];
      body = raw.r[1].body;
      if (!config) {
        packet.notFound = {
          sid: innerPacket.sid,
          cid: innerPacket.cid
        };
        parseResolve(packet);
        return;
      }
    }
    // 附加属性
    packet.service = config.service;
    packet.cmd = config.cmd;

    // 416 频控
    if (packet.error) {
      var tempIds = raw.sid + '_' + raw.cid;
      if (isNotify) {
        tempIds = innerPacket.sid + '_' + innerPacket.cid;
      }
      packet.error.cmd = packet.cmd;
      packet.error.callFunc = 'protocol::parseResponse: ' + tempIds;
      if (packet.error.code === 416) {
        var duration = body[0];
        if (duration) {
          // s -> ms
          packet.frequencyControlDuration = duration * 1000;
        }
      }
    }
    // 错误是否不影响 response 的解析
    var errorIsTrivial = false;
    if (packet.error && config.trivialErrorCodes) {
      errorIsTrivial = config.trivialErrorCodes.indexOf(packet.error.code) !== -1;
    }
    var promiseArr = []; // 需要异步替换内容的集合
    // 如果没错误，或者错误不影响 response 的解析，那么解析 response
    if ((!packet.error || errorIsTrivial) && !!config.response) {
      packet.content = {};
      // 如果是通知, id在整个包内容的第一个位置, 里面的消息和系统消息是没有这个id的
      // hzzhangyingya
      var dealIdServer = function dealIdServer(isNotify, raw, packet, name) {
        if (isNotify && name === 'msg' || name === 'sysMsg') {
          var obj = packet.content[name];
          if (util.isObject(obj) && !obj.idServer) {
            obj.idServer = '' + raw.r[0];
            if (obj.type && obj.type === '8' && obj.deletedIdClient) {
              obj.idServer = obj.deletedIdClient;
            }
          }
        }
      };
      config.response.forEach(function (res, index) {
        var value = body[index];
        if (util.undef(value)) {
          return;
        }

        var type = res.type;
        var name = res.name;
        var entity = res.entity || name;

        switch (type) {
          case 'Property':
            promiseArr.push(self.unserialize(value, entity).then(function (isNotify, raw, packet, name, resObj) {
              packet.content[name] = resObj;
              dealIdServer(isNotify, raw, packet, name);
            }.bind(this, isNotify, raw, packet, name)));
            break;
          case 'PropertyArray':
            packet.content[name] = [];
            value.forEach(function (data) {
              promiseArr.push(self.unserialize(data, entity).then(function (packet, name, resObj) {
                packet.content[name].push(resObj);
              }.bind(this, packet, name)));
            });
            break;
          case 'KVArray':
            packet.content[name] = value;
            dealIdServer(isNotify, raw, packet, name);
            break;
          case 'long':
          case 'Long':
          case 'byte':
          case 'Byte':
          case 'Number':
            packet.content[name] = +value;
            break;
          default:
            packet.content[name] = value;
            dealIdServer(isNotify, raw, packet, name);
            break;
        }
      });
    }
    Promise.all(promiseArr).then(function () {
      parseResolve(packet);
    });
  });
};

/**
 * 序列化数据
 *
 * @param  {Object} obj     待序列化的对象
 * @param  {String} entity  对应的实体
 * @return {Object}         序列化后的对象
 */
Parser.prototype.serialize = function (obj, entity) {
  // console.log('序列化数据, obj: ', obj, '\r\nentity: ', entity)
  var map = this.serializeMap[entity];
  // console.log('序列化数据, serializeMap: ', this.serializeMap)
  // console.log('序列化数据, map: ', map)
  var data = {};
  for (var p in map) {
    if (obj.hasOwnProperty(p)) {
      data[map[p]] = obj[p];
    }
  }
  // console.log('序列化数据, data: ', data)
  return data;
};
/**
 *  nos 文件安全短链验证：短链统一加查询参数(_im_url，int值，位标记)，标记当前链接是短链，只有该查询参数的url才判定为短链
 *
 * @param  {Object} url   短链
 * @return {boolean}      检查结果 true / false
 */
Parser.prototype.matchNosSafeUrl = function (url) {
  if (!util.isString(url) || !~url.indexOf('_im_url=1')) {
    return false;
  }
  var urlObj = (0, _url.urlQuery2Object)(url);
  if (urlObj && urlObj['_im_url'] && urlObj['_im_url'] == 1) {
    return true;
  }
  return false;
};
/**
 *  nos 文件安全短链替换：将一个 nos 安全短链替换为可以正常访问的源链
 *
 * @param  {Object} url   短链
 * @param  {Object} obj   短链所属对象
 * @param  {Object} key   短链所属对象属性
 * @return {Promise}
 */
//
Parser.prototype.getOneNosOriginUrl = function (url, obj, key) {
  var self = this;
  return new Promise(function (replaceResolve, reject) {
    self.protocol.getNosOriginUrlReqNum++;
    self.protocol.sendCmd('getNosOriginUrl', {
      nosFileUrlTag: {
        safeUrl: url
      }
    }, function (error, req, res) {
      self.protocol.getNosOriginUrlReqNum--;
      if (error) {
        console.warn('error: get nos originUrl failed', error);
      } else {
        obj['_' + key + '_safe'] = obj[key];
        obj[key] = res.nosFileUrlTag && res.nosFileUrlTag.originUrl;
      }
      replaceResolve();
    });
  });
};

/**
 * 递归检查短链
 *
 * @param  {Object} obj   待检查的对象，为服务端回传的对象字符串，不会循环引用
 * @param  {Arrary} promiseArr promise对象数组
 * @param  {Arrary} promiseArr promise对象数组
 * @return {undefined}         无返回
 */
Parser.prototype.checkObjSafeUrl = function (obj, pmsArr1, pmsArr2) {
  var _this2 = this;

  for (var key in obj) {
    // 遍历对象
    if (obj.hasOwnProperty(key)) {
      var value = obj[key];
      if (util.isString(value)) {
        // 判断层值类型，只处理字符串、对象、数组
        if (this.matchNosSafeUrl(value)) {
          var pms = this.getOneNosOriginUrl(value, obj, key);
          pmsArr1.push(pms);
          pmsArr2.push(pms);
        }
      } else if (util.isObject(value)) {
        this.checkObjSafeUrl(value, pmsArr1, pmsArr2);
      } else if (util.isArray(value)) {
        value.forEach(function (item) {
          if (util.isObject(item)) {
            _this2.checkObjSafeUrl(item, pmsArr1, pmsArr2);
          }
        });
      }
    }
  }
};
/**
 * 反序列化
 *
 * @param  {Object} data   序列化的对象
 * @param  {String} entity 对应的实体
 * @return {Object}        反序列化后的对象
 */
// audioToText、robot、fileQuickTransfer、chatroomMember、msg、login、team、user 这些对象可能含有nos安全短链的属性
var mayHaveSafeUrlAttrArr = ['url', 'avatar', 'fromAvatar', 'chatroomAvatar'];
Parser.prototype.unserialize = function (data, entity) {
  var self = this;
  return new Promise(function (unsrlzResolve, reject) {
    var map = self.unserializeMap[entity];
    var obj = {};
    var promiseArr = [];
    if (data) {
      for (var p in map) {
        var attachPromiseArr = [];
        // map有可能会有多余项, data不一定有对应内容
        if (data.hasOwnProperty(p)) {
          obj[map[p]] = data[p];
          if (!self.protocol.keepNosSafeUrl) {
            // 是否检查并转换nos安全连接
            // 如果是 attach 字符串，直接检查字符串里是否有 '_im_url=1'，有则每个都转换，只检测替换两层
            if (map[p] === 'attach' && data[p] && data[p].indexOf && ~data[p].indexOf('_im_url=1')) {
              try {
                var tempAttach = JSON.parse(data[p]); // 将 attach 转换为对象
                self.checkObjSafeUrl(tempAttach, attachPromiseArr, promiseArr);
                Promise.all(attachPromiseArr).then(function (obj, tempAttach) {
                  obj['attach'] = JSON.stringify(tempAttach);
                }.bind(self, obj, tempAttach));
              } catch (e) {
                console.warn(e);
              }
            } else if (~mayHaveSafeUrlAttrArr.indexOf(map[p]) && data[p] && self.matchNosSafeUrl(data[p])) {
              promiseArr.push(self.getOneNosOriginUrl(data[p], obj, map[p]));
            }
          }
        }
      }
    }
    Promise.all(promiseArr).then(function (allResObj) {
      unsrlzResolve(obj);
    });
  });
};
/**
 * 反序列化，同步函数
 *
 * @param  {Object} data   序列化的对象
 * @param  {String} entity 对应的实体
 * @return {Object}        反序列化后的对象
 */
Parser.prototype.syncUnserialize = function (data, entity) {
  var self = this;
  var map = self.unserializeMap[entity];
  var obj = {};
  if (data) {
    for (var p in map) {
      // map有可能会有多余项, data不一定有对应内容
      if (data.hasOwnProperty(p)) {
        obj[map[p]] = data[p];
      }
    }
  }
  return obj;
};

var parserIm = new Parser({
  configMap: configMapIM,
  serializeMap: serializeMapIM,
  unserializeMap: unserializeMapIM
});

var parserChatroom = new Parser({
  configMap: configMapChatroom,
  serializeMap: serializeMapChatroom,
  unserializeMap: unserializeMapChatroom
});

module.exports = {
  IM: parserIm,
  Chatroom: parserChatroom
};

/***/ }),

/***/ "./src/polyfill/libDb/general.js":
/*!***************************************!*\
  !*** ./src/polyfill/libDb/general.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function DB(options) {
  this.concurrency = 0;
  this.pendingTasks = [];
  this.queue = Promise.resolve();
  this.logger = options.logger;
  this.enable = false;
  this.server = null;
  this.name = null;
}

var pro = DB.prototype;

pro.reset = function (flag) {
  this.enable = false;
};

pro.clear = pro.destroy = pro.close = pro.remove = pro.init = function (name) {
  return Promise.resolve();
};

module.exports = DB;

/***/ }),

/***/ "./src/polyfill/weixin-app.js":
/*!************************************!*\
  !*** ./src/polyfill/weixin-app.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./weixin-app/auto-polyfill */ "./src/polyfill/weixin-app/auto-polyfill.js");
var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
Config.lbsUrl = Config.lbsUrl.replace('/webconf.jsp', '/wxwebconf.jsp');
Config.defaultReportUrl = null;
Config.isWeixinApp = true;

/***/ }),

/***/ "./src/polyfill/weixin-app/auto-polyfill.js":
/*!**************************************************!*\
  !*** ./src/polyfill/weixin-app/auto-polyfill.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var polyfill = __webpack_require__(/*! ./index.js */ "./src/polyfill/weixin-app/index.js").polyfill;
try {
  polyfill();
} catch (e) {}
try {
  polyfill(GameGlobal);
} catch (e) {}
try {
  window = window || {};
  polyfill(window);
} catch (e) {}
try {
  localStorage = localStorage || __webpack_require__(/*! ./localstorage.js */ "./src/polyfill/weixin-app/localstorage.js");
} catch (e) {}
try {
  XMLHttpRequest = XMLHttpRequest || __webpack_require__(/*! ./xmlhttprequest.js */ "./src/polyfill/weixin-app/xmlhttprequest.js");
} catch (e) {}
try {
  FormData = FormData || __webpack_require__(/*! ./formdata.js */ "./src/polyfill/weixin-app/formdata.js");
} catch (e) {}
try {
  WebSocket = WebSocket || __webpack_require__(/*! ./websocket.js */ "./src/polyfill/weixin-app/websocket.js");
} catch (e) {}
try {
  navigator = navigator || __webpack_require__(/*! ./navigator.js */ "./src/polyfill/weixin-app/navigator.js");
} catch (e) {}

/***/ }),

/***/ "./src/polyfill/weixin-app/formdata.js":
/*!*********************************************!*\
  !*** ./src/polyfill/weixin-app/formdata.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FormData = function () {
  function FormData() {
    (0, _classCallCheck3.default)(this, FormData);

    this._entries = [];
  }

  (0, _createClass3.default)(FormData, [{
    key: 'append',
    value: function append(name, value) {
      if (typeof name !== 'string') {
        throw new TypeError('FormData name must be a string');
      }
      if (typeof value !== 'string') {
        if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object' || typeof value.uri !== 'string') {
          throw new TypeError('FormData value must be a string or { uri: tempFilePath }');
        }
      }
      this._entries.push([name, value]);
    }
  }, {
    key: 'set',
    value: function set(name, value) {
      var entry = this.get(name);
      if (entry) {
        entry[1] = value;
      } else {
        this.append(name, value);
      }
    }
  }, {
    key: 'delete',
    value: function _delete(name) {
      this._entries = this._entries.filter(function (entry) {
        return entry[0] !== name;
      });
    }
  }, {
    key: 'entries',
    value: function entries() {
      return this._entries;
    }
  }, {
    key: 'get',
    value: function get(name) {
      return this._entries.find(function (entry) {
        return entry[0] === name;
      });
    }
  }, {
    key: 'getAll',
    value: function getAll(name) {
      return this._entries.filter(function (entry) {
        return entry[0] === name;
      });
    }
  }, {
    key: 'has',
    value: function has(name) {
      return this._entries.some(function (entry) {
        return entry[0] === name;
      });
    }
  }, {
    key: 'keys',
    value: function keys() {
      return this._entries.map(function (entry) {
        return entry[0];
      });
    }
  }, {
    key: 'values',
    value: function values() {
      return this._entries.map(function (entry) {
        return entry[1];
      });
    }
  }]);
  return FormData;
}();

module.exports = FormData;

/***/ }),

/***/ "./src/polyfill/weixin-app/index.js":
/*!******************************************!*\
  !*** ./src/polyfill/weixin-app/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var localStorage = __webpack_require__(/*! ./localstorage.js */ "./src/polyfill/weixin-app/localstorage.js");
var XMLHttpRequest = __webpack_require__(/*! ./xmlhttprequest.js */ "./src/polyfill/weixin-app/xmlhttprequest.js");
var FormData = __webpack_require__(/*! ./formdata.js */ "./src/polyfill/weixin-app/formdata.js");
var WebSocket = __webpack_require__(/*! ./websocket.js */ "./src/polyfill/weixin-app/websocket.js");
var navigator = __webpack_require__(/*! ./navigator */ "./src/polyfill/weixin-app/navigator.js");

module.exports = {
  polyfill: function polyfill() {
    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : global || window;

    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) !== 'object') {
      throw new Error('polyfill target is not an Object');
    }
    var polyfills = {
      localStorage: localStorage,
      XMLHttpRequest: XMLHttpRequest,
      FormData: FormData,
      WebSocket: WebSocket,
      Object: Object,
      navigator: navigator,
      location: Object.create(null)
    };
    for (var k in polyfills) {
      if (!target[k]) target[k] = polyfills[k];
    }
    // OnlineOfflineEvents.polyfill(target);
    //  假扮为 React Native，让 axios 认为这是一个 nonStandardBrowserEnv
    target.navigator.product = 'WeixinApp';
  },

  localStorage: localStorage,
  XMLHttpRequest: XMLHttpRequest,
  FormData: FormData,
  WebSocket: WebSocket
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/polyfill/weixin-app/localstorage.js":
/*!*************************************************!*\
  !*** ./src/polyfill/weixin-app/localstorage.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Storage = function () {
  function Storage() {
    (0, _classCallCheck3.default)(this, Storage);
  }

  (0, _createClass3.default)(Storage, [{
    key: 'getItem',
    value: function getItem(key) {
      return wx.getStorageSync(key);
    }
  }, {
    key: 'setItem',
    value: function setItem(key, value) {
      return wx.setStorageSync(key, value);
    }
  }, {
    key: 'removeItem',
    value: function removeItem(key) {
      return this.setItem(key, '');
    }
  }, {
    key: 'clear',
    value: function clear() {
      return wx.clearStorageSync();
    }
  }]);
  return Storage;
}();

module.exports = new Storage();

/***/ }),

/***/ "./src/polyfill/weixin-app/navigator.js":
/*!**********************************************!*\
  !*** ./src/polyfill/weixin-app/navigator.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};

/***/ }),

/***/ "./src/polyfill/weixin-app/platform.js":
/*!*********************************************!*\
  !*** ./src/polyfill/weixin-app/platform.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  description: 'weixin micro app',
  layout: null,
  manufacturer: null,
  name: 'weixin',
  prerelease: null,
  product: null,
  ua: 'Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko) Weixin/1.9.1',
  version: '1.9.1',
  os: { architecture: 64, family: 'Windows', version: '1.9.1' }
};

/***/ }),

/***/ "./src/polyfill/weixin-app/websocket.js":
/*!**********************************************!*\
  !*** ./src/polyfill/weixin-app/websocket.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var CONNECTING = 0;
var OPEN = 1;
var CLOSING = 2;
var CLOSED = 3;

// const EVENTS = ['open', 'error', 'message', 'close']

// let instance;

// class WebSocket extends EventTarget(EVENTS) {

var WebSocket = function () {
  function WebSocket(url, protocal) {
    var _this = this;

    (0, _classCallCheck3.default)(this, WebSocket);

    if (!url) {
      throw new TypeError("Failed to construct 'WebSocket': url required");
    }
    if (protocal && !(wx.canIUse && wx.canIUse('connectSocket.object.protocols'))) {
      throw new Error('subprotocal not supported in weapp');
    }
    // FIXME url 中不能有端口
    // https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html#wxrequestobject
    url = url.replace(/:\d+/, '');
    this._url = url;
    this._protocal = protocal || ''; // default value according to specs
    this._readyState = CONNECTING;

    this._socketTask = wx.connectSocket({
      url: url,
      protocals: this._protocal,
      fail: function fail(event) {
        console.info('wx::ws: sockets build failed ...');
        _this.errorHandler(event);
      },
      success: function success(event) {
        console.log('wx::ws: sockets build succeed ...');
      }
    });

    this._socketTask.onOpen(function (event) {
      _this._readyState = OPEN;
      console.log('wx::ws: onopen ', event);
      _this.dispatchEvent({
        type: 'open'
      });
    });

    this._socketTask.onError(function (event) {
      _this.errorHandler(event);
    });

    this._socketTask.onClose(function (event) {
      _this._readyState = CLOSED;
      console.log('wx::ws: onclose ', event);
      var code = event.code,
          reason = event.reason,
          wasClean = event.wasClean;

      _this.dispatchEvent({
        code: code,
        reason: reason,
        wasClean: wasClean,
        type: 'close'
      });
      _this._socketTask = null;
    });

    this._socketTask.onMessage(function (event) {
      var data = event.data,
          origin = event.origin,
          ports = event.ports,
          source = event.source;
      // console.log('wx::ws: onmessage ', data)

      _this.dispatchEvent({
        data: data,
        origin: origin,
        ports: ports,
        source: source,
        type: 'message'
      });
    });
  }

  (0, _createClass3.default)(WebSocket, [{
    key: 'dispatchEvent',
    value: function dispatchEvent(options) {
      var type = options.type;
      var funKey = 'on' + type;
      if (typeof this[funKey] === 'function') {
        this[funKey](options);
      }
    }
  }, {
    key: 'close',
    value: function close() {
      // 强制关闭socket
      try {
        console.log('wx::ws:close WebSocket force close: readystate ' + this._readyState);
        this._socketTask.close({
          code: 1000,
          reason: 'wx::ws:user force close websocket',
          complete: function complete() {
            // console.log('wx::ws:close WebSocket force closed completed')
            // this._socketTask = null
          }
        });
      } catch (error) {
        console.warn('wx::ws:close WebSocket force error', error);
      }
      // if (this._readyState === CLOSED) {
      //   return
      // }
      // if (this._readyState === CONNECTING) {
      //   console.warn('wx::ws:close WebSocket which is connecting might not work')
      // }
      // this._socketTask.close({
      //   code: 1000,
      //   reason: 'wx::ws:user manually close websocket',
      //   success: () => {
      //     // console.log(111111111)
      //   },
      //   fail: (event) => {
      //     // console.log(222222222, event)
      //   },
      //   complete: () => {
      //     console.log('wx::ws:close WebSocket force closed')
      //     this._socketTask = null
      //   }
      // })
    }
  }, {
    key: 'send',
    value: function send(data) {
      // console.log('wx::ws: send msg', data)
      if (this._readyState !== OPEN) {
        throw new Error('wx:ws: sendMsg when readyState=' + this._readyState);
      }

      if (!(typeof data === 'string' || data instanceof ArrayBuffer)) {
        throw new TypeError('wx:ws: sendMsg only String/ArrayBuffer supported');
      }

      this._socketTask.send({
        data: data
      });
    }
  }, {
    key: 'errorHandler',
    value: function errorHandler(event) {
      // 安卓小程序会诡异地触发 onSocketError 回调
      // 通过比较 message 过滤掉
      console.error('wx::ws: onerror ', event);
      // if (event.message === '') return
      this._readyState = CLOSED;
      this.dispatchEvent({
        type: 'error',
        message: event.errMsg
      });
      if (event.errMsg && Object.prototype.toString.call(event.errMsg) === '[object Array]' && (event.errMsg.indexOf('断裂管道') > 0 || event.errMsg.indexOf('broken pipe') > 0)) {
        this.dispatchEvent({
          code: 1006,
          reason: event.errMsg,
          type: 'close'
        });
      }
      this._socketTask = null;
    }
  }, {
    key: 'url',
    get: function get() {
      return this._url;
    }
  }, {
    key: 'protocal',
    get: function get() {
      return this._protocal;
    }
  }, {
    key: 'readyState',
    get: function get() {
      return this._readyState;
    }
  }]);
  return WebSocket;
}();

assign(WebSocket, {
  CONNECTING: CONNECTING,
  OPEN: OPEN,
  CLOSING: CLOSING,
  CLOSED: CLOSED
});

module.exports = WebSocket;

/***/ }),

/***/ "./src/polyfill/weixin-app/xmlhttprequest.js":
/*!***************************************************!*\
  !*** ./src/polyfill/weixin-app/xmlhttprequest.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ "./node_modules/babel-runtime/helpers/defineProperty.js");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var FormData = __webpack_require__(/*! ./formdata.js */ "./src/polyfill/weixin-app/formdata.js");

var UNSENT = 0;
var OPENED = 1;
var HEADERS_RECEIVED = 2;
var LOADING = 3;
var DONE = 4;

var REQUEST_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend', 'readystatechange'];

var REQUEST_UPLOAD_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend'];

function successCallback(response) {
  this.status = response.statusCode;
  this.statusText = response.statusCode;
  // 基础库 1.2.0 开始支持
  if (response.header) {
    this._responseHeaders = Object.keys(response.header).reduce(function (headers, key) {
      headers[key.toLowerCase()] = response.header[key];
      return headers;
    }, {});
  }
  var text = response.data;
  if (typeof text !== 'string') {
    text = JSON.stringify(text);
  }
  this.responseText = this.response = text;
  this.readyState = DONE;
  this.dispatchEvent({ type: 'readystatechange' });
}

// class XMLHttpRequestUpload extends EventTarget(REQUEST_UPLOAD_EVENTS) {}

var XMLHttpRequestUpload = function () {
  function XMLHttpRequestUpload() {
    (0, _classCallCheck3.default)(this, XMLHttpRequestUpload);
  }

  (0, _createClass3.default)(XMLHttpRequestUpload, [{
    key: 'dispatchEvent',
    value: function dispatchEvent(options) {
      var type = options.type;
      var funKey = 'on' + type;
      if (typeof this[funKey] === 'function') {
        this[funKey](options);
      }
    }
  }]);
  return XMLHttpRequestUpload;
}();

// class XMLHttpRequest extends EventTarget(REQUEST_EVENTS) {


var XMLHttpRequest = function () {
  function XMLHttpRequest() {
    (0, _classCallCheck3.default)(this, XMLHttpRequest);

    // super()
    this.readyState = UNSENT;
    this._headers = {};
    this.upload = new XMLHttpRequestUpload();
  }

  (0, _createClass3.default)(XMLHttpRequest, [{
    key: 'dispatchEvent',
    value: function dispatchEvent(options) {
      var type = options.type;
      var funKey = 'on' + type;
      if (typeof this[funKey] === 'function') {
        this[funKey](options);
      }
    }
  }, {
    key: 'abort',
    value: function abort() {
      // 基础库 1.4.0 开始支持
      if (!this._request || this._request.abort) {
        this.status = 0;
        this.readyState = DONE;
        return this._request.abort();
      }
      throw new Error('该版本基础库不支持 abort request');
    }
  }, {
    key: 'getAllResponseHeaders',
    value: function getAllResponseHeaders() {
      var _this = this;

      return this._responseHeaders ? Object.keys(this._responseHeaders).map(function (key) {
        return key + ': ' + _this._responseHeaders[key];
      }).join('\r\n') : '';
    }
  }, {
    key: 'getResponseHeader',
    value: function getResponseHeader(key) {
      var lowserCasedKey = key.toLowerCase();
      if (this._responseHeaders && this._responseHeaders[lowserCasedKey]) {
        return this._responseHeaders[lowserCasedKey];
      }
      return null;
    }
  }, {
    key: 'overrideMimeType',
    value: function overrideMimeType() {
      throw new Error('not supported in weapp');
    }
  }, {
    key: 'open',
    value: function open(method, url) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (this.readyState !== UNSENT) {
        throw new Error('request is already opened');
      }
      if (!async) {
        throw new Error('sync request is not supported');
      }
      this._method = method;
      // FIXME url 中不能有端口
      // https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html#wxrequestobject
      url = url.replace(/:\d+/, '');
      this._url = url;
      this.readyState = OPENED;
      this.dispatchEvent({ type: 'readystatechange' });
    }
  }, {
    key: 'setRequestHeader',
    value: function setRequestHeader(header, value) {
      if (this.readyState !== OPENED) {
        throw new Error('request is not opened');
      }
      this._headers[header.toLowerCase()] = value;
    }
  }, {
    key: 'send',
    value: function send(data) {
      var _this2 = this;

      if (this.readyState !== OPENED) {
        throw new Error('request is not opened');
      }
      if (data instanceof FormData) {
        var entries = data.entries();
        var blobs = entries.filter(function (entry) {
          return typeof entry[1] !== 'string';
        });
        if (blobs.length === 0) {
          throw new Error('Must specify a Blob field in FormData');
        }
        if (blobs.length > 1) {
          console.warn('Only the first Blob will be send in Weapp');
        }
        var restData = entries.filter(function (entry) {
          return typeof entry[1] === 'string';
        }).reduce(function (result, entry) {
          return assign(result, (0, _defineProperty3.default)({}, entry[0], entry[1]));
        }, {});
        this._request = wx.uploadFile({
          url: this._url,
          name: blobs[0][0],
          filePath: blobs[0][1].uri,
          formData: restData,
          header: this._headers,
          success: successCallback.bind(this),
          fail: function fail(error) {
            _this2.status = 0;
            _this2.readyState = DONE;
            _this2.dispatchEvent({ type: 'readystatechange' });
            _this2.dispatchEvent({ type: 'error' });
          }
        });
        // 基础库 1.4.0 开始支持
        if (this._request && this._request.onProgressUpdate) {
          this._request.onProgressUpdate(function (_ref) {
            var totalBytesSent = _ref.totalBytesSent,
                totalBytesExpectedToSend = _ref.totalBytesExpectedToSend;

            _this2.upload.dispatchEvent({
              type: 'progress',
              loaded: totalBytesSent,
              total: totalBytesExpectedToSend
            });
          });
        }
      } else {
        this._request = wx.request({
          url: this._url,
          data: data || '',
          // method 的 value 居然必须为大写
          method: this._method.toUpperCase(),
          header: this._headers,
          success: successCallback.bind(this),
          fail: function fail(error) {
            _this2.status = 0;
            _this2.readyState = DONE;
            _this2.dispatchEvent({ type: 'readystatechange' });
            _this2.dispatchEvent({ type: 'error' });
          }
        });
      }
    }
  }]);
  return XMLHttpRequest;
}();

assign(XMLHttpRequest, {
  UNSENT: UNSENT,
  OPENED: OPENED,
  HEADERS_RECEIVED: HEADERS_RECEIVED,
  LOADING: LOADING,
  DONE: DONE
});

module.exports = XMLHttpRequest;

/***/ }),

/***/ "./src/util/ajax/ajax.js":
/*!*******************************!*\
  !*** ./src/util/ajax/ajax.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ../util */ "./src/util/util.js");
var ProxyXhr = __webpack_require__(/*! ./proxy/xhr */ "./src/util/ajax/proxy/xhr.js");
var ProxyUpload = __webpack_require__(/*! ./proxy/upload */ "./src/util/ajax/proxy/upload.js");
var ProxyFrame = __webpack_require__(/*! ./proxy/frame */ "./src/util/ajax/proxy/frame.js");

var cache = {};
var doFilter = util.f;

function getProxyByMode(options) {
  var mode = options.mode;
  var Constructor = ProxyXhr;
  // 如果是 IE 7/8/9 并且跨域, 那么使用 iframe 模式
  var window = util.getGlobal();
  if (!window.FormData && window.document) {
    mode = 'iframe';
  }
  if (mode === 'iframe') {
    Constructor = options.upload ? ProxyUpload : ProxyFrame;
  }
  return new Constructor(options);
}

function getProxy(options) {
  var upload = options.upload = (options.headers || util.o)['Content-Type'] === 'multipart/form-data';
  var cors = false;
  try {
    var origin1 = (location.protocol + '//' + location.host).toLowerCase();
    var origin2 = util.url2origin(options.url);
    cors = origin1 !== origin2;
  } catch (error) {
    // ignore error in weixin app
  }
  options.cors = cors;
  if (!upload && !cors && !options.mode) {
    return new ProxyXhr(options);
  }
  return getProxyByMode(options);
}

function clear(sn) {
  var c = cache[sn];
  if (!c) {
    return;
  }
  c.req.destroy();
  delete cache[sn];
}

function parseExtData(c, data) {
  data = {
    data: data
  };
  var keys = c.result.headers;
  if (keys) {
    data.headers = c.req.header(keys);
  }
  return data;
}

function callback(sn, type, data) {
  var c = cache[sn];
  if (!c) {
    return;
  }
  if (type === 'onload' && c.result) {
    data = parseExtData(c, data);
  }
  clear(sn);
  var event = {
    type: type,
    result: data
  };
  doFilter(event);
  if (!event.stopped) {
    c[type](event.result);
  }
}

function onLoad(sn, data) {
  callback(sn, 'onload', data);
}

function onError(sn, error) {
  callback(sn, 'onerror', error);
}

function mergeUrl(url, data) {
  var sep = util.genUrlSep(url);
  data = data || '';
  if (util.isObject(data)) {
    data = util.object2query(data);
  }
  if (data) {
    url += sep + data;
  }
  return url;
}

/**
 * ajax
 * @param  {String} url     请求地址
 * @param  {Object} options 配置参数
 * @property {String} [options.method='GET'] 请求方法, 可选值如下
 * - 'GET'
 * - 'POST'
 * @property {Boolean} [options.sync=false] 是否是同步请求
 * @property {Object|String} [options.query] 'GET' 请求的请求参数, 会拼接到 url
 * @property {Object|String} [options.data] 'POST' 请求要发送的数据, 如果是 'GET' 请求, 那么此参数会被拼接到 url
 * @property {Object} [options.headers] 头信息
 * @property {Boolean} [options.cookie=false] 是否设置`withCredentials`
 * @property {Number} [options.timeout=6000] ms, 超时时间, 0 表示不设置超时
 * @property {String} [options.type='text'] 请求成功时, 返回的数据格式, 可选的值如下
 * - 'text': 文本
 * - 'json': 对象
 * @property {Function} [options.onbeforesend] 发送之前的回调
 * @property {Function} [options.onload] 请求完成回调函数
 * @property {Function} [options.onerror] 请求失败回调函数
 * @property {String} [options.mode='auto'] 跨域或者文件上传所使用的模式
 * - 'auto': 自动, 高版本使用 HTML5, 低版本使用 iframe
 * - 'iframe': 全部使用 iframe
 * @property {Object} [options.result] onload回调时需包含的额外结果, 可选如下
 * - headers, 字符串或字符串数组, 那么会返回相应的头信息
 * @return {String}         序列号
 */
function ajax(url, options) {
  options = options || {};
  // cache callback
  var sn = util.uniqueID();
  var c = {
    result: options.result,
    onload: options.onload || util.f,
    onerror: options.onerror || util.f
  };
  cache[sn] = c;
  options.onload = onLoad.bind(null, sn);
  options.onerror = onError.bind(null, sn);
  // append query
  if (options.query) {
    url = mergeUrl(url, options.query);
  }
  // append data for get
  var method = options.method || '';
  if ((!method || /get/i.test(method)) && options.data) {
    url = mergeUrl(url, options.data);
    options.data = null;
  }
  options.url = url;
  c.req = getProxy(options);
  return sn;
}

ajax.filter = function (filter) {
  if (util.isFunction(filter)) {
    doFilter = filter;
  }
};

ajax.abort = function (sn) {
  var c = cache[sn];
  if (c && c.req) {
    c.req.abort();
  }
};

module.exports = ajax;

/***/ }),

/***/ "./src/util/ajax/chunkUpload.js":
/*!**************************************!*\
  !*** ./src/util/ajax/chunkUpload.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var chunkSize = Config.chunkSize;
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var ajax = __webpack_require__(/*! ./ajax */ "./src/util/ajax/ajax.js");
// https://www.163yun.com/help/documents/66981681442246656  NOS 直传服务文档，由于微信小程序限制不能用直传
// 对于https的请求，获取最佳上传节点的方式不是通过LBS，而是使用DNS解析，直传域名是 https://wanproxy-web.127.net
// 直传域名通过智能DNS方式，将每个区域解析到最佳的上传节点。区域和最佳上传节点的对应关系 基本与LBS方式一致，每周更新一次
// 这里索性直接用这个直传域名进行 http/https的上传
var chunkUpload = function chunkUpload(options, fileName, lastLayerContext) {
  // self.sn 用于终止上传
  var fileObj = {
    file: options.data[fileName],
    fileSize: options.data[fileName].size,
    fileUoloadedSize: 0,
    percentage: 0
  };
  function sliceupload(url, resObj, uploadOptions, fileName, fileObj) {
    var trunkStart = resObj.offset;
    var trunkEnd = resObj.offset + chunkSize;
    uploadOptions.data = fileObj.file.slice(trunkStart, trunkEnd);
    uploadOptions.query.offset = resObj.offset; // 断点续传偏移量
    uploadOptions.query.complete = trunkEnd >= fileObj.fileSize; // 是否是最后一片
    uploadOptions.query.context = resObj.context; // 上下文
    uploadOptions.onuploading = onuploading;
    uploadOptions.onload = onload;
    uploadOptions.onerror = onerror;
    return ajax(url, uploadOptions);
  }
  function onuploading(event) {
    var loaded = fileObj.fileUoloadedSize + event.loaded;
    var percentage = Math.floor(loaded * 10000 / fileObj.fileSize) / 100.0;
    if (parseInt(percentage) >= 100) {
      percentage = 100;
      onuploading = function onuploading() {};
    }
    if (fileObj.percentage === percentage) {
      // 已通知过
      return;
    }
    fileObj.percentage = percentage;
    var obj = {
      docId: options.docId,
      total: fileObj.fileSize,
      loaded: loaded,
      percentage: percentage,
      percentageText: percentage + '%'
    };
    if (options.fileInput) {
      obj.fileInput = options.fileInput;
    }
    if (options.blob) {
      obj.blob = options.blob;
    }
    options.uploadprogress(obj);
  }
  function onload(obj) {
    try {
      obj = JSON.parse(obj);
    } catch (e) {
      lastLayerContext.onError(e);
      return;
    }
    if (obj.errMsg || obj.errCode) {
      lastLayerContext.onError(obj);
      return;
    }
    if (obj.offset < fileObj.fileSize) {
      delete uploadOptions.onaftersend;
      fileObj.fileUoloadedSize = obj.offset;
      lastLayerContext.sn = sliceupload(options.url, obj, uploadOptions, fileName, fileObj);
    } else {
      var getFileInfoError = function getFileInfoError(err) {
        lastLayerContext.onError(err);
      };

      var fileUrl = Config.genFileUrl(options.nosToken);
      if (options.type === 'image') {
        ajax(fileUrl + '?imageInfo', {
          onload: function onload(body) {
            try {
              body = JSON.parse(body);
              options.uploaddone(null, {
                docId: obj.docId,
                w: body.Width,
                h: body.Height,
                orientation: body.Orientation || '',
                type: body.Type,
                size: body.Size || fileObj.fileSize
              });
            } catch (e) {
              getFileInfoError(e);
            }
          },
          onerror: getFileInfoError
        });
      } else if (options.type === 'video' || options.type === 'audio') {
        ajax(fileUrl + '?vinfo', {
          onload: function onload(body) {
            try {
              body = JSON.parse(body);
              if (body.GetVideoInfo && body.GetVideoInfo.VideoInfo) {
                body = body.GetVideoInfo.VideoInfo;
              }
              options.uploaddone(null, {
                docId: obj.docId,
                w: body.Width,
                h: body.Height,
                dur: body.Duration,
                orientation: body.Rotate,
                audioCodec: body.AudioCodec,
                videoCodec: body.VideoCodec,
                container: body.Container,
                size: body.Size || fileObj.fileSize
              });
            } catch (e) {
              getFileInfoError(e);
            }
          },
          onerror: getFileInfoError
        });
      } else {
        options.uploaddone(null, {
          docId: obj.docId,
          size: fileObj.fileSize
        });
      }
    }
  }
  function onerror(obj) {
    try {
      if (obj.result) {
        var result = JSON.parse(obj.result);
      } else {
        result = obj;
      }
      lastLayerContext.onError(result);
    } catch (error) {
      lastLayerContext.onError(error);
    }
  }
  var uploadOptions = {
    query: {
      offset: 0, // 断点续传偏移量
      complete: chunkSize >= fileObj.fileSize, // 是否是最后一片
      version: '1.0' // 版本
    },
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'x-nos-token': options.nosToken.token
    },
    method: 'POST',
    timeout: 0,
    onaftersend: function onaftersend() {
      options.beginupload(lastLayerContext);
    },
    onuploading: onuploading,
    onload: onload,
    onerror: onerror
  };
  uploadOptions.data = fileObj.file.slice(0, chunkSize);
  return ajax(options.url, uploadOptions);
};

module.exports = chunkUpload;

/***/ }),

/***/ "./src/util/ajax/index.js":
/*!********************************!*\
  !*** ./src/util/ajax/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ajax = __webpack_require__(/*! ./ajax */ "./src/util/ajax/ajax.js");
var json = __webpack_require__(/*! ./json */ "./src/util/ajax/json.js");
var upload = __webpack_require__(/*! ./upload */ "./src/util/ajax/upload.js");
var chunkUpload = __webpack_require__(/*! ./chunkUpload */ "./src/util/ajax/chunkUpload.js");

ajax.json = json;
ajax.upload = upload;
ajax.chunkUpload = chunkUpload;

module.exports = ajax;

/***/ }),

/***/ "./src/util/ajax/json.js":
/*!*******************************!*\
  !*** ./src/util/ajax/json.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ../util */ "./src/util/util.js");
var ajax = __webpack_require__(/*! ./ajax */ "./src/util/ajax/ajax.js");

var json = function () {
  var regJson = /json/i;
  var regPost = /post/i;
  return function (url, options) {
    options = options || {};
    var data = options.data = options.data || {};
    // parse headers
    var headers = options.headers = options.headers || {};
    var accept = util.checkWithDefault(headers, 'Accept', 'application/json');
    var contentType = util.checkWithDefault(headers, 'Content-Type', 'application/json');
    // response data format
    if (regJson.test(accept)) {
      options.type = 'json';
    }
    // post data
    if (regPost.test(options.method) && regJson.test(contentType)) {
      options.data = JSON.stringify(data);
    }
    return ajax(url, options);
  };
}();

module.exports = json;

/***/ }),

/***/ "./src/util/ajax/message.js":
/*!**********************************!*\
  !*** ./src/util/ajax/message.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ../util */ "./src/util/util.js");
var window = util.getGlobal();
var message = {};

var _self = window.name || '_parent';
var _listeners = [];
var _key = 'MSG|';
var _queue = [];

// for post message and onmessage event
message.addMsgListener = function (cb) {
  _listeners.push(cb);
};

var onMessage = function onMessage(_event) {
  for (var i = 0, l = _listeners.length; i < l; i++) {
    try {
      _listeners[i].call(null, _event);
    } catch (e) {}
  }
};

var formatOrigin = function () {
  var _reg = /^([\w]+?:\/\/.*?(?=\/|$))/i;
  return function (_origin) {
    _origin = _origin || '';
    if (_reg.test(_origin)) {
      return RegExp.$1;
    }
    return '*';
  };
}();

// 检测window.name变化情况
var checkWindowName = function checkWindowName() {
  // check name
  var _name = unescape(window.name || '').trim();
  if (!_name || _name.indexOf(_key) !== 0) {
    return;
  }
  window.name = '';
  // check result
  var _result = util.string2object(_name.replace(_key, ''), '|');
  var _origin = (_result.origin || '').toLowerCase();
  // check origin
  if (!!_origin && _origin !== '*' && location.href.toLowerCase().indexOf(_origin) !== 0) {
    return;
  }
  // dispatch onmessage event
  onMessage({
    data: JSON.parse(_result.data || 'null'),
    source: window.frames[_result.self] || _result.self,
    origin: formatOrigin(_result.ref || (typeof document === 'undefined' ? '' : document.referrer))
  });
};

var checkNameQueue = function () {
  var _checklist;
  var _hasItem = function _hasItem(_list, _item) {
    for (var i = 0, l = _list.length; i < l; i++) {
      if (_list[i] === _item) {
        return !0;
      }
    }
    return !1;
  };
  return function () {
    if (!_queue.length) return;
    _checklist = [];
    for (var i = _queue.length - 1, _map; i >= 0; i--) {
      _map = _queue[i];
      if (!_hasItem(_checklist, _map.w)) {
        _checklist.push(_map.w);
        _queue.splice(i, 1);
        // set window.name
        _map.w.name = _map.d;
      }
    }
    _checklist = null;
  };
}();

var startTimer = message.startTimer = function () {
  var flag = false;
  return function () {
    if (!flag) {
      flag = true;
      if (!window.postMessage) {
        setInterval(checkNameQueue, 100);
        setInterval(checkWindowName, 20);
      }
    }
  };
}();

message.postMessage = function (w) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  util.fillUndef(options, {
    origin: '*',
    source: _self
  });
  if (!window.postMessage) {
    startTimer();
    if (util.isObject(options)) {
      var _result = {};
      _result.origin = options.origin || '';
      _result.ref = location.href;
      _result.self = options.source;
      _result.data = JSON.stringify(options.data);
      options = _key + util.object2string(_result, '|', !0);
    }
    _queue.unshift({
      w: w,
      d: escape(options)
    });
  } else {
    var data = options.data;
    if (!window.FormData) {
      data = JSON.stringify(data);
    }
    w.postMessage(data, options.origin);
  }
};

module.exports = message;

/***/ }),

/***/ "./src/util/ajax/proxy/frame.js":
/*!**************************************!*\
  !*** ./src/util/ajax/proxy/frame.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ../../util */ "./src/util/util.js");
var message = __webpack_require__(/*! ../message */ "./src/util/ajax/message.js");
var Proxy = __webpack_require__(/*! ./index */ "./src/util/ajax/proxy/index.js");

var cache = {};

function ProxyFrame(options) {
  var self = this;
  self.init();
  Proxy.call(self, options);
}

var sp = Proxy.prototype;
var pro = ProxyFrame.prototype = Object.create(sp);

pro.init = function () {
  var flag = 'NEJ-AJAX-DATA:';
  var init = false;
  function onMessage(event) {
    var data = event.data;
    if (data.indexOf(flag) !== 0) {
      return;
    }
    data = JSON.parse(data.replace(flag, ''));
    var key = data.key;
    var proxy = cache[key];
    if (!proxy) {
      return;
    }
    delete cache[key];
    data.result = decodeURIComponent(data.result || '');
    proxy.onLoad(data);
  }
  function initMessage() {
    if (!init) {
      init = true;
      var window = util.getGlobal();
      if (window.postMessage) {
        util.on(window, 'message', onMessage);
      } else {
        message.addMsgListener(onMessage);
      }
    }
  }
  return function () {
    initMessage();
  };
}();

pro.doSend = function () {
  var self = this;
  var options = self.options;
  var origin = util.url2origin(options.url);
  var proxyUrl = options.proxyUrl || origin + '/res/nej_proxy_frame.html';
  var frame = cache[proxyUrl];
  // callback list
  if (util.isArray(frame)) {
    frame.push(self.doSend.bind(self, options));
    return;
  }
  // build frame proxy
  if (!frame) {
    cache[proxyUrl] = [self.doSend.bind(self, options)];
    util.createIframe({
      src: proxyUrl,
      onload: function onload(event) {
        var cbs = cache[proxyUrl];
        cache[proxyUrl] = util.target(event).contentWindow;
        cbs.forEach(function (cb) {
          try {
            cb();
          } catch (e) {
            // ignore
            console.log('error:', e);
          }
        });
      }
    });
    return;
  }
  // check aborted
  if (self.aborted) {
    return;
  }
  // send message to frame
  var key = self.key = util.uniqueID();
  cache[key] = self;
  var data = util.fetch({
    method: 'GET',
    url: '',
    data: null,
    headers: {},
    timeout: 0
  }, options);
  data.key = key;
  message.postMessage(frame, { data: data });
  self.afterSend();
};

pro.abort = function () {
  var self = this;
  self.aborted = true;
  delete cache[self.key];
  sp.abort.call(self);
};

module.exports = ProxyFrame;

/***/ }),

/***/ "./src/util/ajax/proxy/index.js":
/*!**************************************!*\
  !*** ./src/util/ajax/proxy/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ../../util */ "./src/util/util.js");
var f = util.f;
var EventEmitter = __webpack_require__(/*! wolfy87-eventemitter */ "./node_modules/wolfy87-eventemitter/EventEmitter.js");

function Proxy(options) {
  var self = this;
  // addListeners
  if (options.onload) {
    self.once('load', options.onload);
  }
  if (options.onerror) {
    self.once('error', options.onerror);
  }
  if (options.onbeforesend) {
    self.once('beforesend', options.onbeforesend);
  }
  if (options.onaftersend) {
    self.once('aftersend', options.onaftersend);
  }
  // handle options
  options = self.options = util.fetch({
    method: 'GET',
    url: '',
    sync: false,
    data: null,
    headers: {},
    cookie: false,
    timeout: 60000,
    type: 'text',
    // 文件上传用到的参数
    form: null,
    input: null,
    // 是否将文件放在末尾
    putFileAtEnd: false,
    // iframe 模式用到的代理地址
    proxyUrl: ''
  }, options);
  // headers
  var headers = options.headers;
  var contentType = 'Content-Type';
  if (util.notexist(headers[contentType])) {
    headers[contentType] = 'application/x-www-form-urlencoded';
  }
  self.send();
}

var pro = Proxy.prototype = Object.create(EventEmitter.prototype);

pro.send = function () {
  var self = this;
  var options = self.options;
  setTimeout(function () {
    try {
      try {
        self.emit('beforesend', options);
      } catch (error) {
        console.log('error:', 'ignore error ajax beforesend,', error);
      }
      self.doSend();
    } catch (error) {
      console.log('error:', 'ignore error server error,', error);
      self.onError('serverError', '请求失败:' + error.message);
    }
  }, 0);
};

pro.doSend = f;

pro.afterSend = function () {
  var self = this;
  setTimeout(function () {
    self.emit('aftersend', self.options);
  }, 0);
};

pro.onLoad = function (event) {
  var self = this;
  var options = self.options;
  var status = event.status;
  var result = event.result;
  // check status
  if (('' + status).indexOf('2') !== 0) {
    self.onError('serverError', '服务器返回异常状态', {
      status: status,
      result: result
    });
    return;
  }
  // parse json
  if (options.type === 'json') {
    try {
      result = JSON.parse(result);
    } catch (e) {
      console.log('error:', 'ignore error parse json,', e);
      self.onError('parseError', result);
      return;
    }
  }
  // onload
  self.emit('load', result);
};

pro.onError = function (code, message, ext) {
  var obj = util.isObject(ext) ? ext : {};
  obj.code = code || 'error';
  obj.message = message || '发生错误';
  this.emit('error', obj);
};

pro.onTimeout = function () {
  this.onError('timeout', '请求超时');
};

pro.abort = function () {
  this.onError('abort', '客户端中止');
};

pro.header = function (key) {
  var self = this;
  if (!util.isArray(key)) {
    return self.getResponseHeader(key || '');
  }
  var result = {};
  key.forEach(function (k) {
    result[k] = self.header(k);
  });
  return result;
};

pro.getResponseHeader = f;

pro.destroy = f;

module.exports = Proxy;

/***/ }),

/***/ "./src/util/ajax/proxy/upload.js":
/*!***************************************!*\
  !*** ./src/util/ajax/proxy/upload.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ../../util */ "./src/util/util.js");
var Proxy = __webpack_require__(/*! ./index */ "./src/util/ajax/proxy/index.js");
var message = __webpack_require__(/*! ../message */ "./src/util/ajax/message.js");

var flag = 'NEJ-UPLOAD-RESULT:';
var cache = {};

function ProxyUpload(options) {
  var self = this;
  self.init();
  Proxy.call(self, options);
}

var sp = Proxy.prototype;
var pro = ProxyUpload.prototype = Object.create(sp);

pro.init = function () {
  var init = false;
  function onMessage(event) {
    var data = event.data;
    if (data.indexOf(flag) !== 0) {
      return;
    }
    data = JSON.parse(data.replace(flag, ''));
    var key = data.key;
    var proxy = cache[key];
    if (!proxy) {
      return;
    }
    delete cache[key];
    data.result = decodeURIComponent(data.result || '');
    proxy.onLoad(data.result);
  }
  function initMessage() {
    if (!init) {
      init = true;
      var window = util.getGlobal();
      if (window.postMessage) {
        util.on(window, 'message', onMessage);
      } else {
        message.addMsgListener(onMessage);
        message.startTimer();
      }
    }
  }
  return function () {
    initMessage();
  };
}();

pro.doSend = function () {
  var self = this;
  var options = self.options;
  var key = self.key = 'zoro-ajax-upload-iframe-' + util.uniqueID();
  cache[key] = self;
  // create form
  var form = self.form = util.html2node('<form style="display:none;"></form>');
  if (typeof document === 'undefined') {
    console.log('error: document is undefined');
  } else {
    document.body.appendChild(form);
  }
  form.target = key;
  form.method = 'POST';
  form.enctype = 'multipart/form-data';
  form.encoding = 'multipart/form-data';
  var url = options.url;
  var sep = util.genUrlSep(url);
  form.action = url + sep + '_proxy_=form';
  // 处理参数
  var data = options.data;
  var files = [];
  var fileClones = [];
  if (data) {
    util.getKeys(data, options.putFileAtEnd).forEach(function (key) {
      var value = data[key];
      if (value.tagName && value.tagName.toUpperCase() === 'INPUT') {
        if (value.type === 'file') {
          var file = value;
          var fileClone = file.cloneNode(true);
          file.parentNode.insertBefore(fileClone, file);
          var name = util.dataset(file, 'name');
          if (name) {
            file.name = name;
          }
          // console.log('dosend upload', file)
          form.appendChild(file);
          if (util.isFunction(file.setAttribute)) {
            // Remove the HTML5 form attribute from the input
            file.setAttribute('form', '');
            file.removeAttribute('form');
          }
          files.push(value);
          fileClones.push(fileClone);
        }
      } else {
        var input = util.html2node('<input type="hidden"/>');
        input.name = key;
        input.value = value;
        form.appendChild(input);
      }
    });
  }
  function restoreFiles() {
    // 将 input 放回原处
    files.forEach(function (file, index) {
      var fileClone = fileClones[index];
      // just in case, fuck ie 8
      if (fileClone.parentNode) {
        file.name = fileClone.name;
        if (util.isFunction(file.setAttribute)) {
          file.setAttribute('form', fileClone.getAttribute('form'));
        }
        fileClone.parentNode.replaceChild(file, fileClone);
      }
    });
  }
  // create iframe
  var iframe = self.iframe = util.createIframe({
    name: key,
    onload: function onload() {
      // check aborted
      if (self.aborted) {
        restoreFiles();
        return;
      }
      util.on(iframe, 'load', self.checkResult.bind(self));
      form.submit();
      restoreFiles();
      self.afterSend();
    }
  });
};

// same domain upload result check
pro.checkResult = function () {
  var self = this;
  var body;
  var text;
  try {
    body = self.iframe.contentWindow.document.body;
    text = (body.innerText || body.textContent || '').trim();
    // if same domain with upload proxy html, use post message path
    if (text.indexOf(flag) >= 0 || body.innerHTML.indexOf(flag) >= 0) {
      return;
    }
  } catch (error) {
    console.log('error:', 'ignore error if not same domain,', error);
    return;
  }
  self.onLoad(text);
};

pro.onLoad = function (result) {
  var self = this;
  sp.onLoad.call(self, {
    status: 200,
    result: result
  });
  // do the destroy work
  util.remove(self.form);
  util.remove(self.iframe);
  sp.destroy.call(self);
};

// do nothing when destroy, this will let the iframe load, so we can restoreFiles.
pro.destroy = function () {
  util.remove(this.iframe);
  util.remove(this.form);
};

pro.abort = function () {
  var self = this;
  self.aborted = true;
  delete cache[self.key];
  sp.abort.call(self);
};

module.exports = ProxyUpload;

/***/ }),

/***/ "./src/util/ajax/proxy/xhr.js":
/*!************************************!*\
  !*** ./src/util/ajax/proxy/xhr.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ../../util */ "./src/util/util.js");
var Proxy = __webpack_require__(/*! ./index */ "./src/util/ajax/proxy/index.js");

function ProxyXhr(options) {
  var self = this;
  // addListeners
  if (options.onuploading) {
    self.on('uploading', options.onuploading);
  }
  Proxy.call(self, options);
}

var sp = Proxy.prototype;
var pro = ProxyXhr.prototype = Object.create(sp);

pro.doSend = function () {
  var self = this;
  var options = self.options;
  var headers = options.headers;
  var xhr = self.xhr = new XMLHttpRequest();
  // add event listener
  // upload progress 普通上传需要进度
  if (headers['Content-Type'] === 'multipart/form-data') {
    delete headers['Content-Type'];
    xhr.upload.onprogress = self.onProgress.bind(self);
    xhr.upload.onload = self.onProgress.bind(self);
    var data = options.data;
    options.data = new window.FormData();
    if (data) {
      util.getKeys(data, options.putFileAtEnd).forEach(function (key) {
        var value = data[key];
        if (value.tagName && value.tagName.toUpperCase() === 'INPUT') {
          if (value.type === 'file') {
            [].forEach.call(value.files, function (file) {
              options.data.append(util.dataset(value, 'name') || value.name || file.name || 'file-' + util.uniqueID(), file);
            });
          }
        } else {
          // console.log('dosend xhr', key, value)
          options.data.append(key, value);
        }
      });
    }
  } else if (headers['x-nos-token']) {
    // 直传情况下也需要进度
    xhr.upload.onprogress = self.onProgress.bind(self);
    xhr.upload.onload = self.onProgress.bind(self);
  }
  // state change
  xhr.onreadystatechange = self.onStateChange.bind(self);
  // timeout
  if (options.timeout !== 0) {
    self.timer = setTimeout(self.onTimeout.bind(self), options.timeout);
  }
  // prepare and send
  xhr.open(options.method, options.url, !options.sync);
  Object.keys(headers).forEach(function (key) {
    xhr.setRequestHeader(key, headers[key]);
  });
  if (!!options.cookie && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }
  xhr.send(options.data);
  self.afterSend();
};

pro.onProgress = function (event) {
  // IE 10很神奇的, 在upload的load事件之后还会再触发一次progress, 并且loaded比total大。。。
  if (event.lengthComputable && event.loaded <= event.total) {
    this.emit('uploading', event);
  }
};

pro.onStateChange = function () {
  var self = this;
  var xhr = self.xhr;
  if (xhr.readyState === 4) {
    self.onLoad({
      status: xhr.status,
      result: xhr.responseText || ''
    });
  }
};

pro.getResponseHeader = function (key) {
  var xhr = this.xhr;
  return !xhr ? '' : xhr.getResponseHeader(key);
};

pro.destroy = function () {
  var self = this;
  // clear timeout
  clearTimeout(self.timer);
  // clear request
  try {
    self.xhr.onreadystatechange = util.f;
    self.xhr.abort();
  } catch (e) {
    console.log('error:', 'ignore error ajax destroy,', e);
  }
  sp.destroy.call(self);
};

module.exports = ProxyXhr;

/***/ }),

/***/ "./src/util/ajax/upload.js":
/*!*********************************!*\
  !*** ./src/util/ajax/upload.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ajax = __webpack_require__(/*! ./ajax */ "./src/util/ajax/ajax.js");

var upload = function upload(url, options) {
  options.method = 'POST';
  options.headers = options.headers || {};
  options.headers['Content-Type'] = 'multipart/form-data';
  options.timeout = 0;
  options.type = options.type || 'json';
  return ajax(url, options);
};

module.exports = upload;

/***/ }),

/***/ "./src/util/blob.js":
/*!**************************!*\
  !*** ./src/util/blob.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./index */ "./src/util/index.js");
/**
 * NIM Blob 工具方法, 通过 `NIM.blob` 来获取此工具的引用
 *
 * @namespace blob
 */
var blob = {};

/**
 * 将包含 MIME type 和 base64 数据的 data URL 转换为 Blob 对象
 *
 * @memberOf blob
 * @method fromDataURL
 *
 * @param  {String} dataURL 包含 MIME type 和 base64 数据的 data URL
 * @return {Blob}           Blob对象
 *
 * @example
 * var dataURL = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAyADIDASIAAhEBAxEB/8QAGgABAAMBAQEAAAAAAAAAAAAAAAIEBgUDAf/EACwQAAEEAQMCBQMFAQAAAAAAAAEAAgMRBAUSISIxBhNBUWEUMnEjkaGxstH/xAAaAQACAwEBAAAAAAAAAAAAAAAAAQIDBAUG/8QAIREAAgIBAwUBAAAAAAAAAAAAAAECERIEFCExM0FxodH/2gAMAwEAAhEDEQA/ANkiKtm5gxI203fK87Y2XVnv+w7lXNpK2ebLKhHMyUuDHbtpokdr9lksjPzM187pMowYEBIfKw7TIR3ArsL4vuquJNlYenYub9TPE2U1I272lx4cGngjtYPp8rPuoWLI3SLlaTqr8pz8XLa2PNiHW1vZw9CPhdVXxkpK0MIiKQBZzXcgxZGVJz+hh20D3cTf+QtE40LDS4+gaLJXE13FfFqNSxyRvkg8qTpI2HktPNe7gVRqe2x4tqzh5OP5PhAxMaDULXHn1sElWtQo+HJdvb6cEbvwP5VbLex3hzJxnSmSXHjDJKFciq49vlT1SYjw8xrTuknYyNu1v3E1dD8WuZza9kPwSymAaRnMNzF7GFx4LmubyCtoOyxpx/q9UwtMi3mPGAllcfgU3n3WyW/SJ4EkERFrA+EWORahkxszJnS5QEz3MEZMguwBX9eq9FFzA4EEWCk0n1HbqjN5GmQyajKxkhDiwxuO8dba+1xruOVX1DCZp2JFPNlDysZrY4uN5DjxurgE178LRnToDN5vXd9r4UpNPxZQBLE14BsB3ItZ9tF3Y4OKmnNWvPNfTx0zAxsKHdj9Zl63yu5dIT6n/ivqLWNY3a0ABSWhJJUiIRETAIiIAIiIAIiIAIiIA//Z';
 * var blob = NIM.blob.fromDataURL(dataURL);
 * // blob instanceof Blob === true;
 */
blob.fromDataURL = function blobFromDataURL(dataURL) {
  var window = util.getGlobal();
  // convert base64/URLEncoded data component to raw binary data held in a string
  var byteString = void 0;
  if (dataURL.split(',')[0].indexOf('base64') >= 0) {
    byteString = window.atob(dataURL.split(',')[1]);
  } else {
    byteString = window.decodeURIComponent(dataURL.split(',')[1]);
  }

  // separate out the mime component
  var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];

  // write the bytes of the string to a typed array
  var ia = new Uint8Array(byteString.length);
  for (var i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }

  return new window.Blob([ia], { type: mimeString });
};

module.exports = blob;

/***/ }),

/***/ "./src/util/config.js":
/*!****************************!*\
  !*** ./src/util/config.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*** IMPORTS FROM imports-loader ***/
var hash = "3b59f3e215043c723b24615c42a6a16554b8d9a8";
var shortHash = "3b59f3e2";
var version = "6.8.0";
var agentVersion = "2.8.0.906";
var nrtcVersion = "4.8.0";
var sdkVersion = "68";
var nrtcSdkVersion = "1";
var protocolVersion = 1;
var lbsUrl = "https://imtest.netease.im/lbs/webconf.jsp";
var roomserver = "roomserver-test.netease.im";
var defaultReportUrl = "https://imtest.netease.im/1.gif";
var netDetectAddr = "https://roomserver-test.netease.im/v1/sdk/detect/local";
var nrtcNetcallCheckSumUrl = "https://webtest.netease.im/nrtcproxy/demo/getChecksum.action";
var nrtcNetcallGetChannelInfoUrl = "https://webtest.netease.im/nrtcproxy/nrtc/getChannelInfos.action";

/* globals hash:false, shortHash:false, version:false, agentVersion:false, nrtcVersion:fale, sdkVersion:false, nrtcSdkVersion:false, protocolVersion:false, lbsUrl:true, roomserver:true, defaultReportUrl: true */
// those globals will be injected via webpack, @see ./build/webpack.config.js

var theAnswerToEverything =  true ? 5 * 1000 : undefined;

// console.log('nrtcVersion', nrtcVersion)

var config = {
  info: {
    hash: hash,
    shortHash: shortHash,
    version: version,
    sdkVersion: sdkVersion,
    nrtcVersion: nrtcVersion,
    nrtcSdkVersion: nrtcSdkVersion,
    protocolVersion: protocolVersion
  },
  agentVersion: agentVersion,
  lbsUrl: lbsUrl,
  roomserver: roomserver,
  // lbs 最大重试次数, 当所有 lbs 地址都不可用的时候, 会尝试重新获取 lbs 地址, 目前只重试一次
  // lbsMaxRetryCount: 1,
  // 连接超时时间
  connectTimeout: theAnswerToEverything,
  // xhr 超时时间
  xhrTimeout: theAnswerToEverything,
  // socket 超时时间
  socketTimeout: theAnswerToEverything,
  // 重连间隔和最大间隔
  reconnectionDelay: 1600, // 656.25,
  reconnectionDelayMax: theAnswerToEverything,
  reconnectionJitter: 0.01,
  reconnectiontimer: null, // 断线重连超时时间
  // 心跳间隔
  heartbeatInterval: 8 * 1000,

  // 协议超时时间
  cmdTimeout: theAnswerToEverything,
  defaultReportUrl: defaultReportUrl,
  isWeixinApp: false, // isWeixinApp
  isNodejs: false, // isNodejs
  isRN: false,
  // 推送相关
  PUSHTOKEN: '',
  PUSHCONFIG: {},
  CLIENTTYPE: 16,
  // iOS只能询问1次
  PushPermissionAsked: false,
  iosPushConfig: null,
  androidPushConfig: null,
  // 网络探测地址 通过webpack注入
  netDetectAddr: netDetectAddr,
  // web端、微信端lbs地址请求失败的时候使用的默认link地址
  optionDefaultLinkUrl: '',
  defaultLinkUrl: 'weblink.netease.im',
  wxDefaultLinkUrl: 'wlnimsc0.netease.im'
  // 对配置的或默认的link地址进行处理
};config.getDefaultLinkUrl = function (secure) {
  var url = config.optionDefaultLinkUrl || (config.isWeixinApp ? config.wxDefaultLinkUrl : config.defaultLinkUrl);
  if (!url) {
    return false;
  }
  var prefix = secure ? 'https' : 'http';
  var port = secure ? '443' : '80';
  var resUrl = url;
  if (url.indexOf('http') === -1) {
    resUrl = prefix + '://' + resUrl;
  }
  if (url.indexOf(':') === -1) {
    resUrl = resUrl + ':' + port;
  }
  return resUrl;
};

// 通过webpack注入
config.weixinNetcall = config.nrtcNetcall = {
  checkSumUrl: nrtcNetcallCheckSumUrl,
  getChannelInfoUrl: nrtcNetcallGetChannelInfoUrl

  // process.env.NODE_ENV === 'production' ? {
  //   checkSumUrl: 'https://nrtc.netease.im/demo/getChecksum.action',
  //   // appkey: '4c418f22935f1e2cf8488ff1c84229c0',
  //   getChannelInfoUrl: 'https://nrtc.netease.im/nrtc/getChannelInfos.action'
  // } : {
  //   checkSumUrl: 'https://webtest.netease.im/nrtcproxy/demo/getChecksum.action',
  //   // appkey: 'a1266611da6dfb6fc59bc03df11ebdbd',
  //   getChannelInfoUrl: 'https://webtest.netease.im/nrtcproxy/nrtc/getChannelInfos.action'
  // }

  // =============================
  // socket 服务器地址相关
  // =============================
  // 格式化
};config.formatSocketUrl = function (_ref) {
  var url = _ref.url,
      secure = _ref.secure;

  var prefix = secure ? 'https' : 'http';
  if (url.indexOf('http') === -1) {
    return prefix + '://' + url;
  }
  return url;
};

// =====================================
// nos 相关
// =====================================
config.uploadUrl = 'https://nos.netease.com'; // 普通上传：表单提交上传，最大100M
config.chunkUploadUrl = null; // 直传（分片上传）域名：表单+参数提交上传，分片最大4M，最多10000片；null 没有初始化过，'' 经过初始化但没有此值说明不支持
config.commonMaxSize = 104857600; // 100M
config.chunkSize = 4194304; // 4M
config.chunkMaxSize = 41943040000; // 约39G
config.replaceUrl = 'https://{bucket}-nosdn.netease.im/{object}';
config.downloadHost = 'nos.netease.com';
config.downloadUrl = 'https://{bucket}-nosdn.netease.im/{object}';
config.httpsEnabled = false;
config.threshold = 0; // 可以文件快传的文件大小阈值，小于该阈值则不支持快传

// 上传地址
config.genUploadUrl = function (bucket) {
  return config.uploadUrl + '/' + bucket;
};
// 有 config.chunkUploadUrl 则可以使用直传，没有则不能使用直传
config.genChunkUploadUrl = function (nosToken) {
  if (config.chunkUploadUrl) {
    return config.chunkUploadUrl + '/' + nosToken.bucket + '/' + nosToken.objectName;
  }
  return '';
};
// 生成下载地址
config.genDownloadUrl = function (_ref2, object) {
  var bucket = _ref2.bucket,
      tag = _ref2.tag,
      expireSec = _ref2.expireSec;

  var now = +new Date();
  var survivalTime = expireSec ? "&survivalTime=" + expireSec : '';
  var replaceUrl = config.replaceUrl + "?createTime=" + now + survivalTime;
  replaceUrl = config.genNosProtocolUrl(replaceUrl);
  return replaceUrl.replace('{bucket}', bucket).replace('{object}', object);
};
// 生成获取文件信息地址
config.genFileUrl = function (_ref3) {
  var bucket = _ref3.bucket,
      objectName = _ref3.objectName;

  var replaceUrl = config.genNosProtocolUrl(config.replaceUrl);
  return replaceUrl.replace('{bucket}', bucket).replace('{object}', objectName);
};
config.genNosProtocolUrl = function (replaceUrl) {
  if (/^http/.test(replaceUrl)) {
    if (config.httpsEnabled && replaceUrl.indexOf('https://') !== 0) {
      replaceUrl = replaceUrl.replace('http', 'https');
    }
  } else {
    if (config.httpsEnabled) {
      replaceUrl = "https://" + replaceUrl;
    } else {
      replaceUrl = "http://" + replaceUrl;
    }
  }
  return replaceUrl;
};

module.exports = config;

/***/ }),

/***/ "./src/util/console.js":
/*!*****************************!*\
  !*** ./src/util/console.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");

if (typeof window !== 'undefined') {
  // 微信里面不要 shim console
  if (!window.console && !Config.isWeixinApp) {
    window.console = {
      log: function log() {},
      info: function info() {},
      warn: function warn() {},
      error: function error() {}
    };
  }
}

/***/ }),

/***/ "./src/util/device.js":
/*!****************************!*\
  !*** ./src/util/device.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./index.js */ "./src/util/index.js");
var device = {};

device.init = function () {
  // var key = 'nim_web_sdk_deviceId';
  // var deviceId = ls.get(key);
  // if (!deviceId) {
  //     deviceId = util.guid();
  //     ls.set(key, deviceId)
  // }
  // device.deviceId = deviceId;
  device.deviceId = util.guid();
};

device.init();

// 客户端id对应表
device.clientTypeMap = {
  1: 'Android',
  2: 'iOS',
  4: 'PC',
  8: 'WindowsPhone',
  16: 'Web',
  32: 'Server',
  64: 'Mac'
};

device.db = {
  open: function open() {}
};

module.exports = device;

/***/ }),

/***/ "./src/util/index.js":
/*!***************************!*\
  !*** ./src/util/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var naturalSort = __webpack_require__(/*! javascript-natural-sort */ "./node_modules/javascript-natural-sort/naturalSort.js");
var deep = __webpack_require__(/*! deep-access */ "./node_modules/deep-access/index.js");
__webpack_require__(/*! ./console */ "./src/util/console.js");

// error类
function ErrorObj(msg) {
  if ((typeof msg === 'undefined' ? 'undefined' : (0, _typeof3.default)(msg)) === 'object') {
    this.callFunc = msg.callFunc || null;
    this.message = msg.message || 'UNKNOW ERROR';
  } else {
    this.message = msg;
  }
  this.time = new Date();
  this.timetag = +this.time;
}

/**
 * NIM util 工具方法, 通过 `NIM.util` 来获取此工具的引用
 *
 * @namespace util
 */
var util = __webpack_require__(/*! ./util */ "./src/util/util.js");
var window = util.getGlobal();
var regWhiteSpace = /\s+/;

util.deduplicate = function (arr) {
  var rtn = [];
  arr.forEach(function (item) {
    if (rtn.indexOf(item) === -1) {
      rtn.push(item);
    }
  });
  return rtn;
};

util.capFirstLetter = function (str) {
  if (!str) {
    return '';
  }
  str = '' + str;
  return str.slice(0, 1).toUpperCase() + str.slice(1);
};

/**
 * 生成一个 32 位的 [GUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)/[UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
 *
 * @memberOf util
 * @method guid
 *
 * @return {String}   guid/uuid
 */
util.guid = function () {
  var _s4 = function _s4() {
    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
  };
  return function () {
    return _s4() + _s4() + _s4() + _s4() + _s4() + _s4() + _s4() + _s4();
  };
}();

util.extend = function (o1, o2, override) {
  for (var i in o2) {
    if (typeof o1[i] === 'undefined' || override === true) {
      o1[i] = o2[i];
    }
  }
};

util.filterObj = function (base, props) {
  var obj = {};
  if (util.isString(props)) {
    props = props.split(regWhiteSpace);
  }
  props.forEach(function (prop) {
    if (base.hasOwnProperty(prop)) {
      obj[prop] = base[prop];
    }
  });
  return obj;
};

/**
 * 将 target 复制到 base
 *
 * @private
 * @param  {Object} target 待复制的对象
 * @param  {Object} base   复制后的对象
 * @return {Object}        复制后的对象
 */
util.copy = function (target, base) {
  base = base || {};
  if (!target) {
    return base;
  }
  Object.keys(target).forEach(function (key) {
    if (util.exist(target[key])) {
      base[key] = target[key];
    }
  });
  return base;
};

/**
 * 将 target 复制到 base，null值也复制
 *
 * @private
 * @param  {Object} target 待复制的对象
 * @param  {Object} base   复制后的对象
 * @return {Object}        复制后的对象
 */
util.copyWithNull = function (target, base) {
  base = base || {};
  if (!target) {
    return base;
  }
  Object.keys(target).forEach(function (key) {
    if (util.exist(target[key]) || util.isnull(target[key])) {
      base[key] = target[key];
    }
  });
  return base;
};

util.findObjIndexInArray = function (array, options) {
  array = array || [];
  var keyPath = options.keyPath || 'id';
  var pos = -1;
  array.some(function (obj, index) {
    if (deep(obj, keyPath) === options.value) {
      pos = index;
      return true;
    }
  });
  return pos;
};

/**
 * 在数组里面找 keyPath 对应的属性值为 value 的元素
 * - 数组的每一项均为对象, 并且必须有由 keyPath 指定的属性
 *
 * @memberOf util
 * @method findObjInArray
 *
 * @param  {Object[]}   array               待查找的数组
 * @param  {Object}     options             查找的条件
 * @param  {String}     [options.keyPath]   keyPath, 匹配的字段, 默认为 'id'
 * @param  {Anything}   [options.value]     匹配的值
 * @return {Object}                         找到的元素, 或者 null
 *
 * @example
 * var array = [
 *     {name: 'tom'},
 *     {name: 'jack'},
 *     {name: 'dan'}
 * ];
 * var obj = NIM.util.findObjInArray(array, {
 *     keyPath: 'name',
 *     value: 'jack'
 * });
 * // obj 为 {name: 'jack'}
 */
util.findObjInArray = function (array, options) {
  var index = util.findObjIndexInArray(array, options);
  return index === -1 ? null : array[index];
};

/**
 * 合并数组
 * - 此方法接收不定量参数
 *     - 最后一个参数如果是对象, 那么就是配置参数
 *     - 除了配置参数之外, 所有其它的参数都必须是数组, 它们都会被合并
 * - 如果两个对象`keyPath`字段对应的属性值相同, 后面的对象会被合并到前面的对象
 *
 * @memberOf util
 * @method mergeObjArray
 *
 * @param  {Object[]}   arr1                    待合并的数组
 * @param  {Object[]}   arr2                    待合并的数组
 * @param  {Object}     [options]               配置参数
 * @param  {String}     [options.keyPath='id']  `keyPath`, 去重的字段, 默认为 `id`
 * @param  {Boolean}    [options.notSort]       是否要排序, 默认`false`要排序, 传`true`则不排序
 * @param  {Function}   [options.compare]       决定排序的方法, 如果不提供, 那么使用 {@link NIM.naturalSort|NIM.naturalSort} 进行排序
 * @param  {String}     [options.sortPath]      `sortPath`, 排序用的字段, 默认为 `keyPath`
 * @param  {Boolean}    [options.insensitive]   排序时是否不区分大小写, 默认区分
 * @param  {Boolean}    [options.desc]          是否逆序, 默认正序
 * @return {Object[]}                           合并并排序后的数组
 *
 * @example
 * var arr1 = [
 *     {
 *         account: 'tom',
 *         name: 'T'
 *     }
 * ];
 * var arr2 = [
 *     {
 *         account: 'adam'
 *     },
 *     {
 *         account: 'tom',
 *         name: 'T-new'
 *     }
 * ];
 * var options = {
 *     keyPath: 'account'
 * };
 * var resultArray = NIM.util.mergeObjArray(arr1, arr2, options);
 * // resultArray为
 * // [
 * //     {account: 'adam'},
 * //     {account: 'tom', name: 'T-new'},
 * // ]
 */
util.mergeObjArray = function () {
  var base = [];
  // 截取除了最后一个之外的参数, 这些就是待合并的数组
  var arrays = [].slice.call(arguments, 0, -1);
  // 最后一个参数是 options, 如果它是数组, 那么它也是待合并的数组
  var options = arguments[arguments.length - 1];
  if (util.isArray(options)) {
    arrays.push(options);
    options = {};
  }
  // options
  var keyPath = options.keyPath = options.keyPath || 'id';
  options.sortPath = options.sortPath || keyPath;
  // 如果 base 的长度为 0, 那么直接拷贝后一个数组里面的所有元素
  while (!base.length && !!arrays.length) {
    base = arrays.shift() || [];
    base = base.slice(0);
  }
  // 合并所有的数组
  var index;
  arrays.forEach(function (array) {
    if (!array) {
      return;
    }
    array.forEach(function (item) {
      index = util.findObjIndexInArray(base, {
        keyPath: keyPath,
        value: deep(item, keyPath)
      });
      if (index !== -1) {
        // 不修改原有的对象, 生成新的
        base[index] = util.merge({}, base[index], item);
      } else {
        base.push(item);
      }
    });
  });
  // 排序
  if (!options.notSort) {
    base = util.sortObjArray(base, options);
  }
  return base;
};

/**
 * 从数组里面去除某些项
 *
 * @memberOf util
 * @method cutObjArray
 *
 * @param  {Array}      base                    基数组
 * @param  {Object[]}   arr1                    待去除的数组
 * @param  {Object[]}   arr2                    待去除的数组
 * @param  {Object}     options                 配置参数
 * @param  {String}     [options.keyPath='id']  `keyPath`, 去重的字段, 默认为 `id`
 * @return {Array}                              去除后的数组
 *
 * @example
 * var olds = [
 *     { account: 'a' },
 *     { account: 'b' },
 *     { account: 'c' }
 * ];
 * var invalids = [
 *     { account: 'b' }
 * ];
 * var options = {
 *     keyPath: 'account'
 * };
 * var array = NIM.util.cutObjArray(olds, invalids, options);
 * // array 为
 * // [
 * //     { account: 'a' },
 * //     { account: 'c' }
 * // ]
 */
util.cutObjArray = function (base) {
  var rtn = base.slice(0);
  var argsLength = arguments.length;
  // 截取除了第一个和最后一个之外的参数, 这些就是待删除的数组
  var arrays = [].slice.call(arguments, 1, argsLength - 1);
  // 最后一个参数是 options, 如果它不是对象, 那么它也是待删除的数组
  var options = arguments[argsLength - 1];
  if (!util.isObject(options)) {
    arrays.push(options);
    options = {};
  }
  // keyPath
  var keyPath = options.keyPath = options.keyPath || 'id';
  // 删除
  var index;
  arrays.forEach(function (cuts) {
    if (!util.isArray(cuts)) {
      cuts = [cuts];
    }
    cuts.forEach(function (cut) {
      if (!cut) {
        return;
      }
      options.value = deep(cut, keyPath);
      index = util.findObjIndexInArray(rtn, options);
      if (index !== -1) {
        rtn.splice(index, 1);
      }
    });
  });
  return rtn;
};

/**
 * 返回排序后的数组
 * - 数组的每一项都为 `Object`, 并且必须有由 `sortPath` 指定的属性
 *
 * @memberOf util
 * @method sortObjArray
 *
 * @param  {Object[]}   array                   待排序的数组
 * @param  {Object}     [options]               配置参数
 * @param {Function}    [options.compare]       决定排序的方法, 如果不提供, 那么使用 {@link NIM.naturalSort|NIM.naturalSort} 进行排序
 * @param  {String}     [options.sortPath]      `sortPath`, 排序用的字段, 默认为 `id`
 * @param  {Boolean}    [options.insensitive]   排序时是否不区分大小写, 默认区分
 * @param  {Boolean}    [options.desc]          是否逆序, 默认正序
 * @return {Object[]}                           排序后的数组
 *
 * @example
 * var array = [
 *     { account: 'b' },
 *     { account: 'a' }
 * ];
 * var options = {
 *     sortPath: 'account'
 * };
 * NIM.util.sortObjArray(array, options);
 * // array 为
 * //[
 * //    { account: 'a' },
 * //    { account: 'b' }
 * //]
 */
util.sortObjArray = function (array, options) {
  options = options || {};
  var sortPath = options.sortPath || 'id';
  naturalSort.insensitive = !!options.insensitive;
  var desc = !!options.desc;
  var pa, pb;
  var compare;
  if (util.isFunction(options.compare)) {
    compare = options.compare;
  } else {
    compare = function compare(a, b) {
      pa = deep(a, sortPath);
      pb = deep(b, sortPath);
      if (desc) {
        return naturalSort(pb, pa);
      } else {
        return naturalSort(pa, pb);
      }
    };
  }
  return array.sort(compare);
};

util.emptyFunc = function () {};

util.isEmptyFunc = function (func) {
  return func === util.emptyFunc;
};

util.notEmptyFunc = function (func) {
  return func !== util.emptyFunc;
};

util.splice = function (obj, start, end) {
  return [].splice.call(obj, start, end);
};

// 重新切分数据，将一维数组切分成每列num个元素的二维数组
util.reshape2d = function (obj, num) {
  if (Array.isArray(obj)) {
    util.verifyParamType('type', num, 'number', 'util::reshape2d');
    var len = obj.length;
    if (len <= num) {
      return [obj];
    } else {
      var count = Math.ceil(len / num);
      var result = [];
      for (var i = 0; i < count; i++) {
        result.push(obj.slice(i * num, (i + 1) * num));
      }
      return result;
    }
  }
  // 如果不是数组则不做任何处理
  return obj;
};

// 扁平化数据，将2d数组转化为一维数组
util.flatten2d = function (obj) {
  if (Array.isArray(obj)) {
    var result = [];
    obj.forEach(function (item) {
      result = result.concat(item);
    });
    return result;
  }
  return obj;
};

// 数组去重
util.dropArrayDuplicates = function (arr) {
  if (Array.isArray(arr)) {
    var map = {};
    var result = [];
    while (arr.length > 0) {
      var item = arr.shift();
      map[item] = true;
    }
    for (var key in map) {
      if (map[key] === true) {
        result.push(key);
      }
    }
    return result;
  }
  return arr;
};

// error 处理
/*
msg: {
  event: ...,
  message: ...,
  callFunc: ...
}
*/
util.onError = function (msg) {
  throw new ErrorObj(msg);
};

/*
 * 参数处理相关 API
 */

util.verifyParamPresent = function (name, value, prefix, callFunc) {
  prefix = prefix || '';
  var absent = false;
  switch (util.typeOf(value)) {
    case 'undefined':
    case 'null':
      absent = true;
      break;
    case 'string':
      if (value === '') {
        absent = true;
      }
      break;
    case 'StrStrMap':
    case 'object':
      if (!Object.keys(value).length) {
        absent = true;
      }
      break;
    case 'array':
      if (!value.length) {
        absent = true;
      } else {
        value.some(function (item) {
          if (util.notexist(item)) {
            absent = true;
            return true;
          }
        });
      }
      break;
    default:
      break;
  }
  if (absent) {
    util.onParamAbsent(prefix + name, callFunc);
  }
};

util.onParamAbsent = function (name, callFunc) {
  util.onParamError('\u7F3A\u5C11\u53C2\u6570 ' + name + ', \u8BF7\u786E\u4FDD\u53C2\u6570\u4E0D\u662F \u7A7A\u5B57\u7B26\u4E32\u3001\u7A7A\u5BF9\u8C61\u3001\u7A7A\u6570\u7EC4\u3001null\u6216undefined, \u6216\u6570\u7EC4\u7684\u5185\u5BB9\u4E0D\u662F null/undefined', callFunc);
};

util.verifyParamAbsent = function (name, value, prefix, callFunc) {
  prefix = prefix || '';
  if (value !== undefined) {
    util.onParamPresent(prefix + name, callFunc);
  }
};

util.onParamPresent = function (name, callFunc) {
  util.onParamError('\u591A\u4F59\u7684\u53C2\u6570 ' + name, callFunc);
};

util.verifyParamType = function (name, value, validTypes, callFunc) {
  var type = util.typeOf(value).toLowerCase();
  if (!util.isArray(validTypes)) {
    validTypes = [validTypes];
  }
  validTypes = validTypes.map(function (type) {
    return type.toLowerCase();
  });
  var valid = true;
  if (validTypes.indexOf(type) === -1) {
    valid = false;
  }
  switch (type) {
    case 'number':
      if (isNaN(value)) {
        valid = false;
      }
      break;
    case 'string':
      if (validTypes.join('') === 'numeric or numeric string') {
        if (/^[0-9]+$/.test(value)) {
          valid = true;
        } else {
          valid = false;
        }
      }
      break;
    default:
      break;
  }
  if (!valid) {
    util.onParamInvalidType(name, validTypes, '', callFunc);
  }
};

util.onParamInvalidType = function (name, validTypes, prefix, callFunc) {
  prefix = prefix || '';
  if (util.isArray(validTypes)) {
    validTypes = validTypes.map(function (type) {
      return '"' + type + '"';
    });
    validTypes = validTypes.join(', ');
  } else {
    validTypes = '"' + validTypes + '"';
  }
  util.onParamError('参数"' + prefix + name + '"类型错误, 合法的类型包括: [' + validTypes + ']', callFunc);
};

util.verifyParamValid = function (name, value, validValues, callFunc) {
  if (!util.isArray(validValues)) {
    validValues = [validValues];
  }
  if (validValues.indexOf(value) === -1) {
    util.onParamInvalidValue(name, validValues, callFunc);
  }
};

util.onParamInvalidValue = function (name, validValues, callFunc) {
  if (!util.isArray(validValues)) {
    validValues = [validValues];
  }
  validValues = validValues.map(function (value) {
    return '"' + value + '"';
  });
  if (util.isArray(validValues)) {
    validValues = validValues.join(', ');
  }
  util.onParamError('\u53C2\u6570 ' + name + '\u503C\u9519\u8BEF, \u5408\u6CD5\u7684\u503C\u5305\u62EC: [' + JSON.stringify(validValues) + ']', callFunc);
};

util.verifyParamMin = function (name, value, min, callFunc) {
  if (value < min) {
    util.onParamError('参数' + name + '的值不能小于' + min, callFunc);
  }
};

util.verifyParamMax = function (name, value, max, callFunc) {
  if (value > max) {
    util.onParamError('参数' + name + '的值不能大于' + max, callFunc);
  }
};

util.verifyArrayMax = function (name, value, max, callFunc) {
  if (value.length > max) {
    util.onParamError('参数' + name + '的长度不能大于' + max, callFunc);
  }
};

util.verifyEmail = function () {
  var reg = /^\S+@\S+$/;
  return function (name, value, callFunc) {
    if (!reg.test(value)) {
      util.onParamError('参数' + name + '邮箱格式错误, 合法格式必须包含@符号, @符号前后至少要各有一个字符', callFunc);
    }
  };
}();

util.verifyTel = function () {
  var reg = /^[+\-()\d]+$/;
  return function (name, value, callFunc) {
    if (!reg.test(value)) {
      util.onParamError('参数' + name + '电话号码格式错误, 合法字符包括+、-、英文括号和数字', callFunc);
    }
  };
}();

util.verifyBirth = function () {
  var reg = /^(\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/;
  return function (name, value, callFunc) {
    if (!reg.test(value)) {
      util.onParamError('参数' + name + '生日格式错误, 合法为"yyyy-MM-dd"', callFunc);
    }
  };
}();

util.onParamError = function (message, callFunc) {
  util.onError({
    message: message,
    callFunc: callFunc
  });
};

/**
 * 验证options及其属性是否存在
 *
 * @private
 * @param  {Object}       options       配置参数
 * @param  {String|Array} params        属性列表
 * @param  {Boolean}      shouldPresent 是否应该存在
 * @return {Void}
 */
util.verifyOptions = function (options, params, shouldPresent, prefix, callFunc) {
  options = options || {};
  if (params) {
    if (util.isString(params)) {
      params = params.split(regWhiteSpace);
    }
    if (util.isArray(params)) {
      if (typeof shouldPresent !== 'boolean') {
        callFunc = shouldPresent || null;
        shouldPresent = true;
        prefix = '';
      }
      // shouldPresent = shouldPresent === undefined ? true : !!shouldPresent
      var func = shouldPresent ? util.verifyParamPresent : util.verifyParamAbsent;
      params.forEach(function (param) {
        func.call(util, param, options[param], prefix, callFunc);
      });
    }
  }
  return options;
};

util.verifyParamAtLeastPresentOne = function (options, params, callFunc) {
  if (params) {
    if (util.isString(params)) {
      params = params.split(regWhiteSpace);
    }
    if (util.isArray(params)) {
      var presentOne = params.some(function (param) {
        return util.exist(options[param]);
      });
      if (!presentOne) {
        util.onParamError('以下参数[' + params.join(', ') + ']至少需要传入一个', callFunc);
      }
    }
  }
};

util.verifyParamPresentJustOne = function (options, params, callFunc) {
  if (params) {
    if (util.isString(params)) {
      params = params.split(regWhiteSpace);
    }
    if (util.isArray(params)) {
      var counter = params.reduce(function (p, param) {
        if (util.exist(options[param])) {
          p++;
        }
        return p;
      }, 0);
      if (counter !== 1) {
        util.onParamError('以下参数[' + params.join(', ') + ']必须且只能传入一个', callFunc);
      }
    }
  }
};

util.verifyBooleanWithDefault = function (options, name, defaultValue, prefix, callFunc) {
  if (util.undef(defaultValue)) {
    defaultValue = true;
  }
  if (regWhiteSpace.test(name)) {
    name = name.split(regWhiteSpace);
  }
  if (util.isArray(name)) {
    name.forEach(function (n) {
      util.verifyBooleanWithDefault(options, n, defaultValue, prefix, callFunc);
    });
  } else {
    if (typeof options[name] === 'undefined') {
      options[name] = defaultValue;
    } else if (!util.isBoolean(options[name])) {
      util.onParamInvalidType(name, 'boolean', prefix, callFunc);
    }
  }
};

util.verifyFileInput = function (fileInput, callFunc) {
  util.verifyParamPresent('fileInput', fileInput, '', callFunc);
  if (util.isString(fileInput)) {
    if (typeof document === 'undefined') {
      fileInput = undefined;
    } else {
      fileInput = document.getElementById(fileInput);
    }
    if (!fileInput) {
      util.onParamError('\u627E\u4E0D\u5230\u8981\u4E0A\u4F20\u7684\u6587\u4EF6\u5BF9\u5E94\u7684input, \u8BF7\u68C0\u67E5fileInput id ' + fileInput, callFunc);
    }
  }
  if (!fileInput.tagName || fileInput.tagName.toLowerCase() !== 'input' || fileInput.type.toLowerCase() !== 'file') {
    util.onParamError('\u8BF7\u63D0\u4F9B\u6B63\u786E\u7684 fileInput, \u5FC5\u987B\u4E3A file \u7C7B\u578B\u7684 input \u8282\u70B9 tagname:' + fileInput.tagName + ', filetype:' + fileInput.type, callFunc);
  }
  return fileInput;
};

/**
 * 验证是否是合法的文件类型
 *
 * @private
 * @param  {type} type 待验证的文件类型
 * @return {bool}      是否是合法的文件类型
 */
util.verifyFileType = function (type, callFunc) {
  util.verifyParamValid('type', type, util.validFileTypes, callFunc);
};

util.verifyCallback = function (options, name, callFunc) {
  if (regWhiteSpace.test(name)) {
    name = name.split(regWhiteSpace);
  }
  if (util.isArray(name)) {
    name.forEach(function (n) {
      util.verifyCallback(options, n, callFunc);
    });
  } else {
    if (!options[name]) {
      options[name] = util.emptyFunc;
    } else if (!util.isFunction(options[name])) {
      util.onParamInvalidType(name, 'function', '', callFunc);
    }
  }
};

util.verifyFileUploadCallback = function (options, callFunc) {
  util.verifyCallback(options, 'uploadprogress uploaddone uploaderror uploadcancel', callFunc);
};

/*
 * 文件相关 API
 */

util.validFileTypes = ['image', 'audio', 'video', 'file'];

util.validFileExts = {
  image: ['bmp', 'gif', 'jpg', 'jpeg', 'jng', 'png', 'webp'],
  audio: ['mp3', 'wav', 'aac', 'wma', 'wmv', 'amr', 'mp2', 'flac', 'vorbis', 'ac3'],
  video: ['mp4', 'rm', 'rmvb', 'wmv', 'avi', 'mpg', 'mpeg']
};

util.filterFiles = function (files, targetType) {
  targetType = targetType.toLowerCase();
  var anyfile = targetType === 'file';
  var arr = [];
  var ext;
  var mime;
  var type
  //   var subtype
  ;[].forEach.call(files, function (file) {
    if (anyfile) {
      arr.push(file);
    } else {
      ext = file.name.slice(file.name.lastIndexOf('.') + 1);
      mime = file.type.split('/');
      if (!!mime[0] && !!mime[1]) {
        type = mime[0].toLowerCase();
        // subtype = mime[1].toLowerCase()
        var match = false;
        if (type === targetType) {
          match = true;
        } else {
          match = util.validFileExts[targetType].indexOf(ext) !== -1;
        }
        if (match) {
          arr.push(file);
        }
      } else {
        // unknow mime
      }
    }
  });
  return arr;
};

var supportFormData = util.supportFormData = util.notundef(window.FormData);
util.getFileName = function () {
  return function (fileInput) {
    fileInput = util.verifyFileInput(fileInput);
    if (supportFormData) {
      return fileInput.files[0].name;
    } else {
      return fileInput.value.slice(fileInput.value.lastIndexOf('\\') + 1);
    }
  };
}();

// 获取文件信息
util.getFileInfo = function () {
  var map = {
    ppt: 1,
    pptx: 2,
    pdf: 3
  };
  return function (fileInput) {
    fileInput = util.verifyFileInput(fileInput);
    var res = {};
    if (!fileInput.files) {
      return res;
    }
    var file = fileInput.files[0];
    if (supportFormData) {
      res.name = file.name;
      res.size = file.size;
      res.type = file.name.match(/\.(\w+)$/);
      res.type = res.type && res.type[1].toLowerCase();
      res.transcodeType = map[res.type] || 0;
    }
    return res;
  };
}();

util.sizeText = function () {
  var sizeUnit = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'BB'];
  return function (size) {
    var text;
    var index = 0;
    do {
      size = Math.floor(size * 100) / 100;
      var unit = sizeUnit[index];
      text = size + unit;
      size /= 1024;
      index++;
    } while (size > 1);
    return text;
  };
}();

util.promises2cmds = function (promises) {
  return promises.map(function (promise) {
    return promise.cmd;
  });
};

util.objs2accounts = function (objs) {
  return objs.map(function (obj) {
    return obj.account;
  });
};

util.teams2ids = function (teams) {
  return teams.map(function (team) {
    return team.teamId;
  });
};

util.objs2ids = function (objs) {
  return objs.map(function (obj) {
    return obj.id;
  });
};

util.getMaxUpdateTime = function (array) {
  var timetags = array.map(function (item) {
    return +item.updateTime;
  });
  return Math.max.apply(Math, timetags);
};

// util.genCheckUniqueFunc = function (keyPath, size) {
//   var array = []
//   var set = {}
//   keyPath = keyPath || 'id'
//   size = size || 1000
//   return function (obj) {
//     var id
//     if (array.length >= size) {
//       id = array.shift()
//       delete set[id]
//     }
//     id = deep(obj, keyPath)
//     if (!set[id]) {
//       set[id] = true
//       array.push(id)
//       return true
//     } else {
//       return false
//     }
//   }
// }

util.genCheckUniqueFunc = function (keyPath, size) {
  keyPath = keyPath || 'id';
  size = size || 1000;
  return function (obj) {
    this.uniqueSet = this.uniqueSet || {};
    this.uniqueSet[keyPath] = this.uniqueSet[keyPath] || {};
    var currSet = this.uniqueSet[keyPath];
    var setId = obj[keyPath];
    if (currSet[setId]) {
      return false;
    } else {
      currSet[setId] = true;
      return true;
    }
  };
};

util.fillPropertyWithDefault = function (obj, name, defaultValue) {
  if (util.undef(obj[name])) {
    obj[name] = defaultValue;
    return true;
  }
  return false;
};

module.exports = util;

/***/ }),

/***/ "./src/util/logger.js":
/*!****************************!*\
  !*** ./src/util/logger.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var platform = __webpack_require__(/*! platform */ "./src/polyfill/weixin-app/platform.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var ajax = __webpack_require__(/*! utiljs/ajax */ "./src/util/ajax/index.js");

/**
 * 日志, SDK内部使用
 *
 * @constructor
 * @alias Logger
 * @private
 */

function Logger() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  util.merge(this, {
    options: options,
    debug: false,
    api: 'log',
    style: 'color:blue;',
    log: util.emptyFunc,
    info: util.emptyFunc,
    warn: util.emptyFunc,
    error: util.emptyFunc
  });
  this.prefix = options.prefix || '';
  this.setDebug(options.debug);
}

var pro = Logger.prototype;

var supportedBrowsers = ['Chrome', 'Safari', 'Firefox'];

pro.setDebug = function () {
  var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var logger = this;
  logger.debug = debug;
  if (debug.style) {
    logger.style = debug.style;
  }
  if (logger.debug && util.exist(console)) {
    var cs = console;
    logger.debug = function () {
      var args = logger.formatArgs(arguments);
      if (supportedBrowsers.indexOf(platform.name) !== -1 && util.isString(args[0])) {
        args[0] = '%c' + args[0];
        args.splice(1, 0, logger.style);
      }
      logger._log('debug', args);
    };
    logger.log = function () {
      var args = logger.formatArgs(arguments);
      if (supportedBrowsers.indexOf(platform.name) !== -1 && util.isString(args[0])) {
        args[0] = '%c' + args[0];
        args.splice(1, 0, logger.style);
      }
      logger._log('log', args);
    };
    logger.info = function () {
      var args = logger.formatArgs(arguments);
      if (supportedBrowsers.indexOf(platform.name) !== -1 && util.isString(args[0])) {
        args[0] = '%c' + args[0];
        args.splice(1, 0, logger.style);
      }
      logger._log('info', args);
    };
    logger.warn = function () {
      var args = logger.formatArgs(arguments);
      if (supportedBrowsers.indexOf(platform.name) !== -1 && util.isString(args[0])) {
        args[0] = '%c' + args[0];
        args.splice(1, 0, logger.style);
      }
      logger._log('warn', args);
    };
    logger.error = function () {
      var args = logger.formatArgs(arguments);
      if (supportedBrowsers.indexOf(platform.name) !== -1 && util.isString(args[0])) {
        args[0] = '%c' + args[0];
        args.splice(1, 0, logger.style);
      }
      logger._log('error', args);
    };
    logger._log = function (name, args) {
      var isIE8 = '\v' == 'v';
      // 使用开发者传入的方法来记录日志
      var logFuncObj = logger.options.logFunc;
      var logFunc = null;
      if (logFuncObj && !isIE8) {
        if (logFuncObj[name]) {
          logFunc = logFuncObj[name];
        }
        if (util.isFunction(logFunc)) {
          logFunc.apply(logFuncObj, args);
          return;
        }
      }
      // 使用 console 来记录日志
      if (cs[name]) {
        try {
          if (cs[name].apply) {
            logger.chrome(name, args);
          } else {
            logger.ie(name, args);
          }
        } catch (e) {
          // ignore error
        }
      }
    };
    // use this form to skip drop_console of uglify
    logger.chrome = function (func, args) {
      if (supportedBrowsers.indexOf(platform.name) !== -1) {
        cs[func].apply(cs, args);
      } else {
        logger.ie(func, args);
      }
    };
    logger.ie = function (func, args) {
      args.forEach(function (arg) {
        cs[func](JSON.stringify(arg, null, 4));
      });
    };
  }
};

pro.formatArgs = function (args) {
  var logger = this;
  args = [].slice.call(args, 0);
  var date = new Date();
  var dateStr = formatTimeUnit(date.getMonth() + 1) + '-' + formatTimeUnit(date.getDate()) + ' ' + formatTimeUnit(date.getHours()) + ':' + formatTimeUnit(date.getMinutes()) + ':' + formatTimeUnit(date.getSeconds()) + ':' + formatTimeUnit(date.getMilliseconds(), 3);
  var prefix = '[NIM LOG ' + dateStr + ' ' + logger.prefix.toUpperCase() + ']  ';
  if (util.isString(args[0])) {
    args[0] = prefix + args[0];
  } else {
    args.splice(0, 0, prefix);
  }
  args.forEach(function (arg, index) {
    if (util.isArray(arg) || util.isObject(arg)) {
      args[index] = util.simpleClone(arg);
    }
  });
  return args;
};

var formatTimeUnit = function formatTimeUnit(num, count) {
  count = count || 2;
  var str = '' + num;
  while (str.length < count) {
    str = '0' + str;
  }
  return str;
};

module.exports = Logger;

/***/ }),

/***/ "./src/util/loggerPlugin.js":
/*!**********************************!*\
  !*** ./src/util/loggerPlugin.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LoggerPlugin(options) {
  var logLevelMap = {
    debug: 0,
    log: 1,
    info: 2,
    warn: 3,
    error: 4
  };
  var self = this;
  var postUrl = options.url || null;
  self.level = logLevelMap[options.level] || 0;
  self.logCache = [];
  self.logNum = 1;
  self.timeInterval = 5000;
  window.onerror = function (errorMessage, scriptURI, lineNumber, columnNumber, errorObj) {
    self.error(errorObj);
  };
  setInterval(function () {
    if (self.logCache.length > 0 && postUrl) {
      self.postLogs(postUrl, self.logCache);
    }
  }, self.timeInterval);
}

LoggerPlugin.prototype.debug = function () {
  if (this.level > 0) {
    return;
  }
  console.debug.apply(this, arguments);
  this.cacheLogs.apply(this, ['[degbug]'].concat(arguments));
};

LoggerPlugin.prototype.log = function () {
  if (this.level > 1) {
    return;
  }
  console.log.apply(this, arguments);
  this.cacheLogs.apply(this, ['[log]'].concat(arguments));
};

LoggerPlugin.prototype.info = function () {
  if (this.level > 2) {
    return;
  }
  console.info.apply(this, arguments);
  this.cacheLogs.apply(this, ['[info]'].concat(arguments));
};

LoggerPlugin.prototype.warn = function () {
  if (this.level > 3) {
    return;
  }
  console.warn.apply(this, arguments);
  this.cacheLogs.apply(this, ['[warn]'].concat(arguments));
};

LoggerPlugin.prototype.error = function () {
  if (this.level > 4) {
    return;
  }
  console.error.apply(this, arguments);
  this.cacheLogs.apply(this, ['[error]'].concat(arguments));
};

LoggerPlugin.prototype.cacheLogs = function (logLevel, args) {
  var currentCache = [];
  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    if ((typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'object') {
      currentCache.push(JSON.stringify(arg));
    } else {
      currentCache.push(arg);
    }
  }
  var logStr = this.logNum++ + ' ' + logLevel + ' ' + currentCache.join('; ');
  this.logCache.push(logStr.replace('%c', ''));
};

LoggerPlugin.prototype.postLogs = function (url, data) {
  var self = this;
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        console.info('LoggerPlugin::日志上报完成');
        self.logCache = [];
        self.timeInterval = 5000;
      } else {
        self.timeInterval += 5000;
      }
    }
  };
  xhr.open('POST', url);
  xhr.setRequestHeader('Content-Type', 'plain/text;charset=utf-8');
  xhr.timeout = 360;
  xhr.send(data.join('\n'));
};

module.exports = LoggerPlugin;

/***/ }),

/***/ "./src/util/nos.js":
/*!*************************!*\
  !*** ./src/util/nos.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");

var responseBodyMap = {
  file: {
    // url: '',                 // url 根据Bucket和ObjectName拼装
    // ext: '',                 // 文件后缀, 根据name来截取
    // name: '$(FileName)',     // 文件名由程序自己获取
    md5: '$(Etag)',
    size: '$(ObjectSize)' // long 单位byte
  },
  image: {
    // url: '',
    // ext: '',
    // name: '$(FileName)',
    md5: '$(Etag)',
    size: '$(ObjectSize)',
    w: '$(ImageInfo.Width)', // 图片宽度 int 单位: 像素
    h: '$(ImageInfo.Height)', // 图片高度 int 单位: 像素
    orientation: '$(ImageInfo.Orientation)'
  },
  audio: {
    // url: '',
    // ext: '',
    // name: '$(FileName)',
    md5: '$(Etag)',
    size: '$(ObjectSize)',
    dur: '$(AVinfo.Audio.Duration)' // 持续时间, 单位ms
  },
  video: {
    // url: '',
    // ext: '',
    // name: '$(FileName)',
    md5: '$(Etag)',
    size: '$(ObjectSize)',
    dur: '$(AVinfo.Video.Duration)', // 持续时间, 单位ms
    w: '$(AVinfo.Video.Width)', // 分辨率
    h: '$(AVinfo.Video.Height)' // 分辨率
  }
};

var nos = {};

nos.genResponseBody = function (type) {
  type = type || 'file';
  return responseBodyMap[type];
};

// https://en.wikipedia.org/wiki/Exchangeable_image_file_format
// http://www.impulseadventure.com/photo/exif-orientation.html
// top, left      Orientation: Horizontal (normal)
// right, top     Orientation: Rotate 90 CW
// bottom, right  Orientation: Rotate 180
// left, bottom   Orientation: Rotate 270 CW
/**
 * 解析 nos 返回的数据
 * @param  {Object} obj             nos 返回的数据
 * @param  {Boolean} exifOrientation 是否需要根据 exif orientation 信息来交换宽高
 * @return {Object}                 解析后的数据
 */
nos.parseResponse = function (obj, exifOrientation) {
  if (util.notundef(obj.size)) {
    obj.size = +obj.size;
  }
  if (util.notundef(obj.w)) {
    obj.w = +obj.w;
  }
  if (util.notundef(obj.h)) {
    obj.h = +obj.h;
  }
  if (util.notundef(obj.dur)) {
    obj.dur = +obj.dur;
  }
  var orientation = obj.orientation;
  if (util.notundef(orientation)) {
    delete obj.orientation;
    if (exifOrientation) {
      if (orientation === 'right, top' || orientation === 'left, bottom') {
        var temp = obj.w;
        obj.w = obj.h;
        obj.h = temp;
      }
    }
  }
  return obj;
};

module.exports = nos;

/***/ }),

/***/ "./src/util/support.js":
/*!*****************************!*\
  !*** ./src/util/support.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * NIM support 工具对象, 通过 `NIM.support` 来获取此工具的引用
 *
 * @namespace support
 */
var support = {};

support.set = function (name, flag, obj) {
  support[name] = flag;
  if (obj) {
    obj.support = flag;
  }
};

/**
 * 是否支持数据库
 * @memberOf support
 * @name db
 * @type {Boolean}
 */

module.exports = support;

/***/ }),

/***/ "./src/util/upload.js":
/*!****************************!*\
  !*** ./src/util/upload.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Config = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");
var util = __webpack_require__(/*! utiljs */ "./src/util/index.js");
var NIMError = __webpack_require__(/*! im/model/nimerror */ "./src/im/model/nimerror.js");
var upload = __webpack_require__(/*! utiljs/ajax */ "./src/util/ajax/index.js").upload;
var chunkUpload = __webpack_require__(/*! utiljs/ajax */ "./src/util/ajax/index.js").chunkUpload;
var abort = __webpack_require__(/*! utiljs/ajax */ "./src/util/ajax/index.js").abort;
// 是否支持FormData
var supportFormData = util.supportFormData;
// var supportFormData = false; // test code for mock IE 8/9

/**
 * 文件上传控件, 使用FormData或者Iframe上传文件
 *
 * @param {options} options 配置参数
 * @param {String}          options.url             服务器url
 * @param {String|Node}     options.fileInput       文件选择input的id或者节点对象
 * @param {String}          options.type            文件类型过滤
 * @param {Object}          options.params          其它参数
 * @param {Function}        options.beginupload     开始上传图片的回调, 如果开发者传入 fileInput, 在此回调之前不能修改 fileInput, 否则上传的文件会错乱
 * @param {Function}        options.uploadprogress  上传进度, ie9以下不支持上传进度
 * @param {Function}        options.uploaddone      上传完成, 成功或者失败
 * @param {Object}        headers                 请求头
 */
function Upload(options) {
  var self = this;
  self.options = util.copy(options);
  util.verifyOptions(options, 'url fileName');
  util.verifyParamPresentJustOne(options, 'blob fileInput');
  util.verifyCallback(options, 'beginupload uploadprogress uploaddone');
  if (options.fileInput) {
    options.fileInput = util.verifyFileInput(options.fileInput);
  }
  if (options.type) {
    util.verifyFileType(options.type);
  }
  if (options.timeout) {
    util.verifyParamType('timeout', options.timeout, 'number');
  } else {
    // 0 means no timeout
    options.timeout = 1000 * 60 * 10;
  }
  util.verifyFileUploadCallback(options);

  options.data = {};

  // 添加其它参数
  if (options.params) {
    util.merge(options.data, options.params);
  }

  // 名字
  var fileName = options.fileName;
  var fileInput = options.fileInput;
  if (supportFormData) {
    // 如果是fileInput
    if (fileInput) {
      // 过滤
      var fileList = options.type ? util.filterFiles(fileInput.files, options.type) : [].slice.call(fileInput.files, 0);
      if (!fileList || !fileList.length) {
        options.uploaddone(NIMError.newWrongFileTypeError('未读取到' + options.type + '类型的文件, 请确保文件选择节点的文件不为空, 并且请确保选择了' + options.type + '类型的文件'));
        return;
      }
      options.data[fileName] = fileList[0];
      var fileSize = fileInput.files[0].size;
    } else if (options.blob) {
      options.data[fileName] = options.blob;
      // 过滤
      if (options.type !== 'file' && options.blob.type && options.blob.type.indexOf(options.type) === -1) {
        options.uploaddone(NIMError.newWrongFileTypeError('未读取到' + options.type + '类型的文件, 请确保选择了' + options.type + '类型的文件'));
        return;
      }
      var fileSize = options.blob.size;
    }
    // 验证大小
    if (options.maxSize && fileSize > options.maxSize) {
      options.uploaddone(NIMError.newFileTooLargeError('\u4E0A\u4F20\u6587\u4EF6\u5927\u5C0F\u8D85\u8FC7' + options.maxSize + '\u9650\u5236'));
      return;
    }
    if (!options.commonUpload) {
      if (fileSize > Config.chunkMaxSize) {
        // 10000个100
        options.uploaddone(NIMError.newFileTooLargeError('\u76F4\u4F20\u6587\u4EF6\u5927\u5C0F\u8D85\u8FC7' + Config.chunkMaxSize + '\u9650\u5236'));
        return;
      }
      self.sn = chunkUpload(options, fileName, self);
      return;
    }
    if (fileSize > Config.commonMaxSize) {
      options.uploaddone(NIMError.newFileTooLargeError('\u666E\u901A\u4E0A\u4F20\u6587\u4EF6\u5927\u5C0F\u8D85\u8FC7' + Config.commonMaxSize + '\u9650\u5236'));
      return;
    }
  } else {
    util.dataset(fileInput, 'name', fileName);
    options.data.input = fileInput;
  }

  var uploadOptions = {
    data: options.data,
    onaftersend: function onaftersend() {
      options.beginupload(self);
    },
    onuploading: function onuploading(event) {
      var percentage = Math.floor(event.loaded * 10000 / event.total) / 100.0;
      var obj = {
        docId: options.docId,
        total: event.total,
        loaded: event.loaded,
        percentage: percentage,
        percentageText: percentage + '%'
      };
      if (options.fileInput) {
        obj.fileInput = options.fileInput;
      }
      if (options.blob) {
        obj.blob = options.blob;
      }
      options.uploadprogress(obj);
    },
    onload: function onload(obj) {
      // IE 8/9 报错走这里, see onerror
      obj.docId = options.docId;
      if (obj.Error) {
        self.onError(obj);
      } else {
        options.uploaddone(null, obj);
      }
    },
    onerror: function onerror(obj) {
      // 高级浏览器报错走这里, see onload
      try {
        // 能解析 obj.result 的时候, 它包含 nos 错误的详情, 其它情况 see catch
        if (obj.result) {
          var result = JSON.parse(obj.result);
        } else {
          result = obj;
        }
        self.onError(result);
      } catch (error) {
        console.log('error: ignore error if could not parse obj.result', error);
        options.uploaddone(new NIMError(obj.message, obj.code), self.options);
      }
    }

    // 其实并不需要指定 mode, 会自动识别, 这里是为了在 chrome 上测试 mode 才加了这段代码
  };if (!supportFormData) {
    uploadOptions.mode = 'iframe';
  }

  uploadOptions.putFileAtEnd = true;

  self.sn = upload(options.url, uploadOptions);
}

Upload.prototype.onError = function (obj) {
  var self = this;
  var options = self.options;
  var error, reason, message;
  obj = obj || {};
  error = obj.Error || obj || {};
  reason = error.Code || error.code || 'unknown';
  message = error.Message || error.message || '未知错误';
  options.uploaddone(new NIMError(reason + '(' + message + ')', reason));
};

Upload.prototype.abort = function () {
  abort(this.sn);
};

module.exports = Upload;

/***/ }),

/***/ "./src/util/url.js":
/*!*************************!*\
  !*** ./src/util/url.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CONFIG = __webpack_require__(/*! utiljs/config */ "./src/util/config.js");

var Instance = {
  genUrlSep: function genUrlSep(url) {
    url = '' + url;
    var sep = url.indexOf('?') === -1 ? '?imageView&' : '&';
    return sep;
  },
  urlQuery2Object: function urlQuery2Object(url) {
    if (Object.prototype.toString.call(url) !== '[object String]' || url === '') {
      return {};
    }
    var queryStart = url.indexOf('?');
    if (queryStart === -1) {
      return;
    }
    var queryStr = url.slice(queryStart + 1);
    var queryArr = queryStr.split('&');
    var resObj = {};
    queryArr.forEach(function (item) {
      if (~item.indexOf('=')) {
        var temp = item.split('=');
        resObj[temp[0]] = decodeURIComponent(temp[1]);
      } else {
        resObj[item] = '';
      }
    });
    return resObj;
  },
  url2object: function url2object(url) {
    if (Object.prototype.toString.call(url) !== '[object String]') {
      url = '';
    }
    url = url || '';
    var protocol = url.indexOf('https') >= 0 ? 'https://' : 'http://';
    var hostname = url.replace(protocol, '');
    if (hostname.indexOf('?') >= 0) {
      hostname = hostname.substring(0, hostname.indexOf('?'));
    }
    var hostItems = hostname.split('/');
    hostname = hostItems[0];
    var path = '';
    if (hostItems.length > 0) {
      path = hostItems.slice(1).join('/');
    }
    if (url.indexOf('?') === -1) {
      return {
        protocol: protocol,
        hostname: hostname,
        path: path,
        query: {}
      };
    } else {
      var query = url.substr(url.indexOf('?') + 1);
      var queryItems = query.split('&');
      var result = {};
      queryItems.forEach(function (item) {
        if (item.indexOf('=') > 0) {
          var temp = item.split('=');
          result[temp[0]] = decodeURIComponent(temp[1]);
        } else {
          result[item] = '';
        }
      });
      return {
        protocol: protocol,
        hostname: hostname,
        path: path,
        query: result
      };
    }
  },
  object2url: function object2url(obj) {
    var protocol = obj.protocol,
        hostname = obj.hostname,
        path = obj.path,
        query = obj.query;

    protocol = protocol || 'http://';
    hostname = hostname || '';
    if (path) {
      hostname = hostname + '/' + path;
    }
    query = query || {};
    var queryItems = [];
    for (var key in query) {
      if (key === 'imageView') {
        continue;
      } else {
        queryItems.push(key + '=' + encodeURIComponent(query[key]));
      }
    }
    if (queryItems.length > 0) {
      return '' + protocol + hostname + '?imageView&' + queryItems.join('&');
    } else {
      return '' + protocol + hostname;
    }
  },

  // http://doc.hz.netease.com/pages/viewpage.action?pageId=95782286
  // nos地址替换兼容
  genPrivateUrl: function genPrivateUrl(url) {
    var urlObj = Instance.url2object(url);
    var host = urlObj.hostname;
    var path = urlObj.path;
    var downloadHost = CONFIG.downloadHost;
    var downloadUrl = CONFIG.downloadUrl;
    if (host === downloadHost) {
      // 收到nos.netease.com/{bucket}/{obj}
      var index = path.indexOf('/');
      if (index !== -1) {
        var nosBucket = path.substring(0, index);
        var nosObj = path.substring(index + 1);
        return downloadUrl.replace('{bucket}', nosBucket).replace('{object}', nosObj);
      }
    } else if (host && Object.prototype.toString.call(host) == '[object String]' && ~host.indexOf(downloadHost)) {
      // 收到{bucket}.nos.netease.com/{obj}
      var _path = urlObj.path;
      var _index = _path.indexOf('.');
      if (_index !== -1) {
        var _nosBucket = _path.substring(0, _index);
        var _nosObj = _path;
        return downloadUrl.replace('{bucket}', _nosBucket).replace('{object}', _nosObj);
      }
    }
    return url;
  }
};

module.exports = Instance;

/***/ }),

/***/ "./src/util/usePlugin.js":
/*!*******************************!*\
  !*** ./src/util/usePlugin.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var device = __webpack_require__(/*! utiljs/device */ "./src/util/device.js");

function usePlugin(config) {
  if (config.db) {
    device.db = config.db;
  }
}

module.exports = usePlugin;

/***/ }),

/***/ "./src/util/util.js":
/*!**************************!*\
  !*** ./src/util/util.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.url2origin = exports.uniqueID = exports.off = exports.removeEventListener = exports.on = exports.addEventListener = exports.format = exports.regWhiteSpace = exports.regBlank = exports.emptyFunc = exports.f = exports.emptyObj = exports.o = undefined;

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

exports.getGlobal = getGlobal;
exports.detectCSSFeature = detectCSSFeature;
exports.fix = fix;
exports.getYearStr = getYearStr;
exports.getMonthStr = getMonthStr;
exports.getDayStr = getDayStr;
exports.getHourStr = getHourStr;
exports.getMinuteStr = getMinuteStr;
exports.getSecondStr = getSecondStr;
exports.getMillisecondStr = getMillisecondStr;
exports.dateFromDateTimeLocal = dateFromDateTimeLocal;
exports.getClass = getClass;
exports.typeOf = typeOf;
exports.isString = isString;
exports.isNumber = isNumber;
exports.isBoolean = isBoolean;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isDate = isDate;
exports.isRegExp = isRegExp;
exports.isError = isError;
exports.isnull = isnull;
exports.notnull = notnull;
exports.undef = undef;
exports.notundef = notundef;
exports.exist = exist;
exports.notexist = notexist;
exports.isObject = isObject;
exports.isEmpty = isEmpty;
exports.containsNode = containsNode;
exports.calcHeight = calcHeight;
exports.remove = remove;
exports.dataset = dataset;
exports.target = target;
exports.createIframe = createIframe;
exports.html2node = html2node;
exports.scrollTop = scrollTop;
exports.forOwn = forOwn;
exports.mixin = mixin;
exports.isJSON = isJSON;
exports.parseJSON = parseJSON;
exports.simpleClone = simpleClone;
exports.merge = merge;
exports.fillUndef = fillUndef;
exports.checkWithDefault = checkWithDefault;
exports.fetch = fetch;
exports.string2object = string2object;
exports.object2string = object2string;
exports.genUrlSep = genUrlSep;
exports.object2query = object2query;
exports.isFileInput = isFileInput;
exports.getKeys = getKeys;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// const.js
var o = exports.o = {};
var emptyObj = exports.emptyObj = {};

var f = exports.f = function f() {};
var emptyFunc = exports.emptyFunc = function emptyFunc() {};

var regBlank = exports.regBlank = /\s+/gi;
var regWhiteSpace = exports.regWhiteSpace = /\s+/gi;

// getGlobal.js
function getGlobal() {
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  return {};
}

// css.js
function detectCSSFeature(featurename) {
  var feature = false;
  var domPrefixes = 'Webkit Moz ms O'.split(' ');
  if (typeof document === 'undefined') {
    console.log('error:fn:detectCSSFeature document is undefined');
    return;
  }
  var elm = document.createElement('div');
  var featurenameCapital = null;

  featurename = featurename.toLowerCase();

  if (elm.style[featurename] !== undefined) {
    feature = true;
  }

  if (feature === false) {
    featurenameCapital = featurename.charAt(0).toUpperCase() + featurename.substr(1);
    for (var i = 0; i < domPrefixes.length; i++) {
      if (elm.style[domPrefixes[i] + featurenameCapital] !== undefined) {
        feature = true;
        break;
      }
    }
  }
  return feature;
}

// date.js
function fix(number, count) {
  count = count || 2;
  var str = '' + number;
  while (str.length < count) {
    str = '0' + str;
  }
  return str;
}

function getYearStr(date) {
  return '' + date.getFullYear();
}

function getMonthStr(date) {
  return fix(date.getMonth() + 1);
}

function getDayStr(date) {
  return fix(date.getDate());
}

function getHourStr(date) {
  return fix(date.getHours());
}

function getMinuteStr(date) {
  return fix(date.getMinutes());
}

function getSecondStr(date) {
  return fix(date.getSeconds());
}

function getMillisecondStr(date) {
  return fix(date.getMilliseconds(), 3);
}

var format = exports.format = function () {
  var reg = /yyyy|MM|dd|hh|mm|ss|SSS/g;
  var mappers = {
    yyyy: getYearStr,
    MM: getMonthStr,
    dd: getDayStr,
    hh: getHourStr,
    mm: getMinuteStr,
    ss: getSecondStr,
    SSS: getMillisecondStr
  };
  return function (date, format) {
    date = new Date(date);
    if (isNaN(+date)) {
      return 'invalid date';
    }
    format = format || 'yyyy-MM-dd';
    return format.replace(reg, function (match) {
      return mappers[match](date);
    });
  };
}();

function dateFromDateTimeLocal(str) {
  str = '' + str;
  return new Date(str.replace(/-/g, '/').replace('T', ' '));
}

// type.js
function getClass(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1);
}

function typeOf(obj) {
  return getClass(obj).toLowerCase();
}

function isString(obj) {
  return typeOf(obj) === 'string';
}

function isNumber(obj) {
  return typeOf(obj) === 'number';
}

function isBoolean(obj) {
  return typeOf(obj) === 'boolean';
}

function isArray(obj) {
  return typeOf(obj) === 'array';
}

function isFunction(obj) {
  return typeOf(obj) === 'function';
}

function isDate(obj) {
  return typeOf(obj) === 'date';
}

function isRegExp(obj) {
  return typeOf(obj) === 'regexp';
}

function isError(obj) {
  return typeOf(obj) === 'error';
}

function isnull(obj) {
  return obj === null;
}

function notnull(obj) {
  return obj !== null;
}

// 需要用 typeof 来比较，兼容性好
function undef(obj) {
  return typeof obj === 'undefined';
}

function notundef(obj) {
  return typeof obj !== 'undefined';
}

function exist(obj) {
  return notundef(obj) && notnull(obj);
}

function notexist(obj) {
  return undef(obj) || isnull(obj);
}

function isObject(obj) {
  return exist(obj) && typeOf(obj) === 'object';
}

/**
 * 是否是空值
 * @param  {Object}  obj 待检查的对象
 * @return {Boolean}     如果是 null/undefined/''/[] 返回 true
 */
function isEmpty(obj) {
  return notexist(obj) || (isString(obj) || isArray(obj)) && obj.length === 0;
}

// dom.js
function containsNode(parent, child) {
  if (parent === child) {
    return true;
  }
  while (child.parentNode) {
    if (child.parentNode === parent) {
      return true;
    }
    child = child.parentNode;
  }
  return false;
}

function calcHeight(node) {
  var parent = node.parentNode || (typeof document === 'undefined' ? null : document.body);
  if (!parent) {
    return 0;
  }
  node = node.cloneNode(true);
  node.style.display = 'block';
  node.style.opacity = 0;
  node.style.height = 'auto';
  parent.appendChild(node);
  var height = node.offsetHeight;
  parent.removeChild(node);
  return height;
}

function remove(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}

function dataset(node, key, value) {
  if (exist(value)) {
    node.setAttribute('data-' + key, value);
  } else {
    return node.getAttribute('data-' + key);
  }
}

var addEventListener = exports.addEventListener = function addEventListener(node, type, callback) {
  if (node.addEventListener) {
    node.addEventListener(type, callback, false);
  } else if (node.attachEvent) {
    node.attachEvent('on' + type, callback);
  }
};
var on = exports.on = addEventListener;

var removeEventListener = exports.removeEventListener = function removeEventListener(node, type, callback) {
  if (node.removeEventListener) {
    node.removeEventListener(type, callback, false);
  } else if (node.detachEvent) {
    node.detachEvent('on' + type, callback);
  }
};
var off = exports.off = removeEventListener;

function target(event) {
  return event.target || event.srcElement;
}

function createIframe(options) {
  if (typeof document === 'undefined') {
    return;
  }
  options = options || {};
  var iframe;
  if (options.name) {
    try {
      iframe = document.createElement('<iframe name="' + options.name + '"></iframe>');
      iframe.frameBorder = 0;
    } catch (error) {
      iframe = document.createElement('iframe');
      iframe.name = options.name;
    }
  } else {
    iframe = document.createElement('iframe');
  }
  if (!options.visible) {
    iframe.style.display = 'none';
  }
  // on load
  function onIframeLoad(event) {
    if (!iframe.src) {
      return;
    }
    if (!options.multi) {
      off(iframe, 'load', onIframeLoad);
    }
    options.onload(event);
  }
  if (isFunction(options.onload)) {
    on(iframe, 'load', onIframeLoad);
  }
  // will trigger onload
  var parent = options.parent;(parent || document.body).appendChild(iframe);
  // ensure trigger onload async
  var src = options.src || 'about:blank';
  setTimeout(function () {
    iframe.src = src;
  }, 0);
  return iframe;
}

function html2node(html) {
  if (typeof document === 'undefined') {
    return;
  }
  var div = document.createElement('div');
  div.innerHTML = html;
  var children = [];
  var i = void 0;
  var l = void 0;
  if (div.children) {
    for (i = 0, l = div.children.length; i < l; i++) {
      children.push(div.children[i]);
    }
  } else {
    for (i = 0, l = div.childNodes.length; i < l; i++) {
      var child = div.childNodes[i];
      if (child.nodeType === 1) {
        children.push(child);
      }
    }
  }
  return children.length > 1 ? div : children[0];
}

function scrollTop(top) {
  if (typeof document !== 'undefined' && exist(top)) {
    document.documentElement.scrollTop = document.body.scrollTop = top;
  }
  return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
}

// forOwn.js
function forOwn() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
  var that = arguments[2];

  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      callback.call(that, key, obj[key]);
    }
  }
}

// mixin.js
function mixin(target, source) {
  forOwn(source, function (key, value) {
    target[key] = value;
  });
}

// id.js
var uniqueID = exports.uniqueID = function () {
  var id = 0;
  return function () {
    return '' + id++;
  };
}();

// json.js
function isJSON(str) {
  return isString(str) && str.indexOf('{') === 0 && str.lastIndexOf('}') === str.length - 1;
}

function parseJSON(obj) {
  try {
    if (isJSON(obj)) {
      obj = JSON.parse(obj);
    }
    if (isObject(obj)) {
      forOwn(obj, function (key, value) {
        switch (typeOf(value)) {
          case 'string':
          case 'object':
            obj[key] = parseJSON(value);
            break;
        }
      });
    }
  } catch (error) {
    console.log('error:', error);
  }
  return obj;
}

// object.js
function simpleClone(obj) {
  var cache = [];
  var strObj = JSON.stringify(obj, function (key, value) {
    if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && value !== null) {
      if (cache.indexOf(value) !== -1) {
        // Circular reference found, discard key
        return;
      }
      // Store value in our collection
      cache.push(value);
    }
    return value;
  });
  return JSON.parse(strObj);
}

/**
 * mock Object.assign
 * - 将 sources 的 enumerable own properties 拷贝到 target
 * @param  {Object} target={}  目标对象
 * @param  {Object} ...sources 待拷贝的对象
 * @return {Object}            目标对象
 */
function merge() {
  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (source) {
    mixin(target, source);
  });
  return target;
}

/**
 * 对于 source 的 enumerable own properties, 如果 target 没有此属性, 将 source 的值赋给 target
 * @param  {Object} target 目标对象
 * @param  {Object} source 源对象
 * @return {Object}        目标对象
 */
function fillUndef(target, source) {
  forOwn(source, function (key, value) {
    if (undef(target[key])) {
      target[key] = value;
    }
  });
  return target;
}

/**
 * 如果 target 没有 key 对应的属性, 那么将 value 赋给他
 * @param  {Object} target 目标对象
 * @param  {String} key    属性名
 * @param  {Object} value  属性值
 * @return {Object}        属性值
 */
function checkWithDefault(target, key, value) {
  var v = target[key] || target[key.toLowerCase()];
  if (notexist(v)) {
    v = value;
    target[key] = v;
  }
  return v;
}

/**
 * 对于 target 的 enumerable own properties, 如果 source 存在对应的值, 将其赋给 target
 * @param  {Object} target 目标对象
 * @param  {Object} source 源对象
 * @return {Object}        目标对象
 */
function fetch(target, source) {
  forOwn(target, function (key, value) {
    if (exist(source[key])) {
      target[key] = source[key];
    }
  });
  return target;
}

function string2object() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';

  var obj = {};
  string.split(sep).forEach(function (pair) {
    var arr = pair.split('=');
    var key = arr.shift();
    if (!key) {
      return;
    }
    obj[decodeURIComponent(key)] = decodeURIComponent(arr.join('='));
  });
  return obj;
}

function object2string(obj, sep, encode) {
  if (!obj) {
    return '';
  }
  var arr = [];
  forOwn(obj, function (key, value) {
    if (isFunction(value)) {
      return;
    }
    if (isDate(value)) {
      value = value.getTime();
    } else if (isArray(value)) {
      value = value.join(',');
    } else if (isObject(value)) {
      value = JSON.stringify(value);
    }
    if (encode) {
      value = encodeURIComponent(value);
    }
    arr.push(encodeURIComponent(key) + '=' + value);
  });
  return arr.join(sep || ',');
}

function genUrlSep(url) {
  return url.indexOf('?') < 0 ? '?' : '&';
}

function object2query(obj) {
  return object2string(obj, '&', true);
}

var url2origin = exports.url2origin = function () {
  var reg = /^([\w]+?:\/\/.*?(?=\/|$))/i;
  return function (url) {
    if (reg.test(url || '')) {
      return RegExp.$1.toLowerCase();
    }
    return '';
  };
}();

// ajax
function isFileInput(value) {
  var window = getGlobal();
  return value.tagName && value.tagName.toUpperCase() === 'INPUT' || window.Blob && value instanceof window.Blob;
}

/**
 * 获取所有的 keys
 * putFileAtEnd 表示将文件对应的 keys 放在最后
 */
function getKeys(data, putFileAtEnd) {
  var keys = Object.keys(data);
  if (putFileAtEnd) {
    keys.sort(function (key1, key2) {
      var value1IsFileInput = isFileInput(data[key1]);
      var value2IsFileInput = isFileInput(data[key2]);
      // 如果两个值相等, 说明都是文件或者都不是文件, 那么顺序不变
      if (value1IsFileInput === value2IsFileInput) {
        return 0;
      } else {
        return value1IsFileInput ? 1 : -1;
      }
    });
  }
  return keys;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ })

/******/ });